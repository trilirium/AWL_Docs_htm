<HTML>
<HEAD>
<TITLE>List of functors</TITLE>
</HEAD>
<BODY>
<CENTER>Version: <B>0.8.0</B>.</CENTER>
<CENTER>[ <A href=AWL_Functors.htm><B>Functors</B></A> | <A href=AWL_Categories.htm><B>Categories</B></A> | <A href=AWL_Types.htm><B>Metatypes</B></A> | <A href=AWL_Syntax.htm><B>Syntax</B></A> ]</CENTER>
<H1>List of functors
</H1>
<P>[ <B><A href=#_95>_</A></B> | <B><A href=#_65>A</A></B> | <B><A href=#_66>B</A></B> | <B><A href=#_67>C</A></B> | <B><A href=#_68>D</A></B> | <B><A href=#_69>E</A></B> | <B><A href=#_70>F</A></B> | <B><A href=#_71>G</A></B> | <B><A href=#_72>H</A></B> | <B><A href=#_73>I</A></B> | <B><A href=#_76>L</A></B> | <B><A href=#_77>M</A></B> | <B><A href=#_78>N</A></B> | <B><A href=#_79>O</A></B> | <B><A href=#_80>P</A></B> | <B><A href=#_82>R</A></B> | <B><A href=#_83>S</A></B> | <B><A href=#_84>T</A></B> | <B><A href=#_85>U</A></B> | <B><A href=#_86>V</A></B> | <B><A href=#_87>W</A></B> | <B><A href=#_88>X</A></B> ]</P>
<HR /><a name="_95"></a>
<P><font size=+1 color=red>= <B>_</B> =</font></P>
<HR />
<a name="__arguments"></a>
<P><font face=Arial size=+1 color=#808080><B>_arguments</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_System">System</a></b> ]</LI>
<LI type=disc><B>_arguments </B> () &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Module arguments.</I></P>
<P>Returns current module arguments (as list of string values, or <b>undef</b>, when empty).</P>
<P></P>
<!-- ../src/Kernel.cpp:1742 -->

<HR />
<a name="__environ"></a>
<P><font face=Arial size=+1 color=#808080><B>_environ</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_System">System</a></b> ]</LI>
<LI type=disc><B>_environ </B> () &#8658; <b><a href="AWL_Types.htm#_Hash">Hash</a></b>.</LI>
<P><I>System environment.</I></P>
<P>Returns system environment (as hash of key/value pairs).</P>
<P></P>
<!-- ../src/Kernel.cpp:1749 -->

<HR />
<a name="__version"></a>
<P><font face=Arial size=+1 color=#808080><B>_version</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_System">System</a></b> ]</LI>
<LI type=disc><B>_version </B> () &#8658; (<b><a href="AWL_Types.htm#_Int">Int</a></b>, <b><a href="AWL_Types.htm#_Int">Int</a></b>, <b><a href="AWL_Types.htm#_Int">Int</a></b>).</LI>
<P><I>Interpreter version.</I></P>
<P>Returns interpreter version (as <i>Major</i>, <i>Minor</i>, <i>Patchlevel</i>).</P>
<P></P>
<!-- ../src/Kernel.cpp:1756 -->

<HR /><a name="_65"></a>
<P><font size=+1 color=red>= <B>A</B> =</font></P>
<HR />
<a name="_a_copy"></a>
<P><font face=Arial size=+1 color=#808080><B>a_copy</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>a_copy </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Copy array.</I></P>
<P>Makes and returns copy of array <i>Array</i> (both copies of array are sharing same elements).</P>
<P></P>
<!-- ../src/E_Array.cpp:1423 -->

<HR />
<a name="_a_delete"></a>
<P><font face=Arial size=+1 color=#808080><B>a_delete</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>a_delete </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>DimIndex</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>DeleteRange</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Delete elements block from array.</I></P>
<P>Shrink array <i>Array</i> at dimension <i>DimIndex</i> by deleting elements block at <i>DeleteRange</i>.<br>Returns <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_insert">a_insert</a></B> | <B><a href="#_a_reshape">a_reshape</a></B> ]</P>
<!-- ../src/E_Array.cpp:1451 -->

<HR />
<a name="_a_dims"></a>
<P><font face=Arial size=+1 color=#808080><B>a_dims</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> ]</LI>
<LI type=disc><B>a_dims </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Array dimensions.</I></P>
<P>Returns list of dimensions of array <i>Array</i> (in order from outer to inner).</P>
<P><I>See also: </I>[ <B><a href="#_a_rank">a_rank</a></B> | <B><a href="#_a_total">a_total</a></B> ]</P>
<!-- ../src/E_Array.cpp:1362 -->

<HR />
<a name="_a_elem"></a>
<P><font face=Arial size=+1 color=#808080><B>a_elem</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>a_elem </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>Index</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>Array element accessor.</I></P>
<P>Returns mutable reference to element of array <i>Array</i> with index list <i>Index</i> (from outer indexes to inner).<br>Syntax: <i>Array</i> {<i>Index</i>}.</P>
<P></P>
<!-- ../src/E_Array.cpp:1378 -->

<HR />
<a name="_a_fill"></a>
<P><font face=Arial size=+1 color=#808080><B>a_fill</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>a_fill </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>Elem</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Fill array with value.</I></P>
<P>Fills entire array <i>Array</i> with value of <i>Elem</i>.<br>Returns <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_load">a_load</a></B> | <B><a href="#_a_save">a_save</a></B> ]</P>
<!-- ../src/E_Array.cpp:1388 -->

<HR />
<a name="_a_init_all"></a>
<P><font face=Arial size=+1 color=#808080><B>a_init_all</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>a_init_all </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>FnVal</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; ().</LI>
<P><I>Array functional initializer.</I></P>
<P>Initializes all elements of array <i>Array</i> by using functor reference <i>FnVal</i>.<br>(Each element is initialized by <i>FnVal</i> ! <i>Index</i>, where <i>Index</i> is list of element indexes, from outer to inner.)</P>
<P></P>
<!-- ../src/E_Array.cpp:1413 -->

<HR />
<a name="_a_insert"></a>
<P><font face=Arial size=+1 color=#808080><B>a_insert</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>a_insert </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>DimIndex</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>InsertRange</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, [<i>Init</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Insert elements block into array.</I></P>
<P>Expand array <i>Array</i> by dimension <i>DimIndex</i> by inserting elements block at <i>InsertRange</i>.<br>(Inserted block is initialized with <i>Init</i>.)<br>Returns <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_delete">a_delete</a></B> | <B><a href="#_a_reshape">a_reshape</a></B> ]</P>
<!-- ../src/E_Array.cpp:1443 -->

<HR />
<a name="_a_load"></a>
<P><font face=Arial size=+1 color=#808080><B>a_load</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>a_load </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>Elems</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Load array elements from list of values.</I></P>
<P>Loads array <i>Array</i> with list of <i>Elems</i> (according to internal elements ordering).<br>(Extra elements are ignored).<br>Returns <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_fill">a_fill</a></B> | <B><a href="#_a_save">a_save</a></B> ]</P>
<!-- ../src/E_Array.cpp:1396 -->

<HR />
<a name="_a_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>a_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>a_loop </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Array iterator.</I></P>
<P>Evaluates <i>Body</i> for all elements of the <i>Array</i> (in internal order), assigning current element to <i>Var</i> before each iteration.</P>
<P></P>
<!-- ../src/E_Array.cpp:1433 -->

<HR />
<a name="_a_rank"></a>
<P><font face=Arial size=+1 color=#808080><B>a_rank</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> ]</LI>
<LI type=disc><B>a_rank </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Array rank.</I></P>
<P>Returns rank (total number of dimensions) of array <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_dims">a_dims</a></B> | <B><a href="#_a_total">a_total</a></B> ]</P>
<!-- ../src/E_Array.cpp:1355 -->

<HR />
<a name="_a_reshape"></a>
<P><font face=Arial size=+1 color=#808080><B>a_reshape</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>a_reshape </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>, <i>DimRange0</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, ... . <i>DimRangeN</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>,  ) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Reshape array.</I></P>
<P>Reshape array <i>Array</i>, changing dimension ranges to <i>DimRange0</i> .. <i>DimRangeN</i>.<br>Returns <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_insert">a_insert</a></B> | <B><a href="#_a_delete">a_delete</a></B> ]</P>
<!-- ../src/E_Array.cpp:1461 -->

<HR />
<a name="_a_save"></a>
<P><font face=Arial size=+1 color=#808080><B>a_save</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>a_save </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Save array elements to list of values.</I></P>
<P>Returns contents of array <i>Array</i> as list (according to internal elements ordering).<br>(Final undefined elements are NOT included.)</P>
<P><I>See also: </I>[ <B><a href="#_a_fill">a_fill</a></B> | <B><a href="#_a_load">a_load</a></B> ]</P>
<!-- ../src/E_Array.cpp:1405 -->

<HR />
<a name="_a_total"></a>
<P><font face=Arial size=+1 color=#808080><B>a_total</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> ]</LI>
<LI type=disc><B>a_total </B> (<i>Array</i>: <b><a href="AWL_Types.htm#_Array">Array</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Total elements in array.</I></P>
<P>Returns total number of elements in array <i>Array</i>.</P>
<P><I>See also: </I>[ <B><a href="#_a_rank">a_rank</a></B> | <B><a href="#_a_dims">a_dims</a></B> ]</P>
<!-- ../src/E_Array.cpp:1369 -->

<HR />
<a name="_abs"></a>
<P><font face=Arial size=+1 color=#808080><B>abs</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>abs </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric absolute value.</I></P>
<P>Arithmetic absolute value of numeric argument <i>A</i>.<br>(Equivalent to: (<i>A</i> >= 0 ? <i>A</i> : -<i>A</i>), but with <i>A</i> evaluated once).<br>Syntax: +<i>A</i>.</P>
<P><I>See also: </I>[ <B><a href="#_sgn">sgn</a></B> ]</P>
<!-- ../src/E_Num.cpp:802 -->

<HR />
<a name="_acos"></a>
<P><font face=Arial size=+1 color=#808080><B>acos</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>acos </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric arccosine.</I></P>
<P>ArcCosine of <i>X</i> (with result in radians).</P>
<P><I>See also: </I>[ <B><a href="#_asin">asin</a></B> | <B><a href="#_atan">atan</a></B> | <B><a href="#_cos">cos</a></B> ]</P>
<!-- ../src/E_Num.cpp:895 -->

<HR />
<a name="_add"></a>
<P><font face=Arial size=+1 color=#808080><B>add</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>add </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric addition.</I></P>
<P>Arithmetic sum of arguments <i>A</i> and <i>B</i>.<br>Syntax: <i>A</i> + <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_sub">sub</a></B> ]</P>
<!-- ../src/E_Num.cpp:939 -->

<HR />
<a name="_and"></a>
<P><font face=Arial size=+1 color=#808080><B>and</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>and </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise conjunction.</I></P>
<P>Bitwise AND of arguments <i>I</i> and <i>J</i>.<br>Syntax: <i>I</i> & <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_or">or</a></B> | <B><a href="#_xor">xor</a></B> ]</P>
<!-- ../src/E_Num.cpp:1073 -->

<HR />
<a name="_ang"></a>
<P><font face=Arial size=+1 color=#808080><B>ang</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>ang </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>Y</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric polar angle.</I></P>
<P>Polar angle of point (<i>X</i>, <i>Y</i>), with result in radians.</P>
<P><I>See also: </I>[ <B><a href="#_rad">rad</a></B> ]</P>
<!-- ../src/E_Num.cpp:1166 -->

<HR />
<a name="_apply"></a>
<P><font face=Arial size=+1 color=#808080><B>apply</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>apply</B> (<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>Args</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Apply functor to argument(s).</I></P>
<P>Invokes functor reference <i>F</i> with argument(s) <i>Args</i>, returning result of invocation.</P>
<P></P>
<!-- ../src/E_Func.cpp:671 -->

<HR />
<a name="_array"></a>
<P><font face=Arial size=+1 color=#808080><B>array</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Array">Array</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>array </B> (<i>Dims</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Array">Array</a></b>.</LI>
<P><I>Array constructor.</I></P>
<P>Creates new array (list <i>Dims</i> contains dimensions, from outer to inner).<br>(Elements of created array are initialised to <b>undef</b>.)</P>
<P></P>
<!-- ../src/E_Array.cpp:1344 -->

<HR />
<a name="_asin"></a>
<P><font face=Arial size=+1 color=#808080><B>asin</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>asin </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric arcsine.</I></P>
<P>ArcSine of <i>X</i> (with result in radians).</P>
<P><I>See also: </I>[ <B><a href="#_acos">acos</a></B> | <B><a href="#_atan">atan</a></B> | <B><a href="#_sin">sin</a></B> ]</P>
<!-- ../src/E_Num.cpp:890 -->

<HR />
<a name="_assert"></a>
<P><font face=Arial size=+1 color=#808080><B>assert</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> ]</LI>
<LI type=disc><B>assert </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Assertion check.</I></P>
<P>Reports error, if condition <i>Cond</i> failed (not true).<br>Returns <i>Cond</i>.</P>
<P></P>
<!-- ../src/E_Control.cpp:361 -->

<HR />
<a name="_atan"></a>
<P><font face=Arial size=+1 color=#808080><B>atan</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>atan </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric arctangent.</I></P>
<P>ArcTangent of <i>X</i> (with result in radians).</P>
<P><I>See also: </I>[ <B><a href="#_asin">asin</a></B> | <B><a href="#_acos">acos</a></B> | <B><a href="#_tan">tan</a></B> ]</P>
<!-- ../src/E_Num.cpp:900 -->

<HR /><a name="_66"></a>
<P><font size=+1 color=red>= <B>B</B> =</font></P>
<HR />
<a name="_bitclr_count"></a>
<P><font face=Arial size=+1 color=#808080><B>bitclr_count</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitclr_count </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Count all clear bits.</I></P>
<P>Return total count of all clear bits in <i>Value</i> (0, if <i>Value</i> == ~0).</P>
<P><I>See also: </I>[ <B><a href="#_bitset_count">bitset_count</a></B> ]</P>
<!-- ../src/E_Num.cpp:1213 -->

<HR />
<a name="_bitclr_hi"></a>
<P><font face=Arial size=+1 color=#808080><B>bitclr_hi</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitclr_hi </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Locate highest clear bit.</I></P>
<P>Return index of highest clear bit in <i>Value</i> (or -1, if <i>Value</i> == ~0).</P>
<P><I>See also: </I>[ <B><a href="#_bitset_hi">bitset_hi</a></B> | <B><a href="#_bitset_lo">bitset_lo</a></B> | <B><a href="#_bitclr_lo">bitclr_lo</a></B> ]</P>
<!-- ../src/E_Num.cpp:1188 -->

<HR />
<a name="_bitclr_lo"></a>
<P><font face=Arial size=+1 color=#808080><B>bitclr_lo</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitclr_lo </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Locate lowest clear bit.</I></P>
<P>Return index of lowest clear bit in <i>Value</i> (or -1, if <i>Value</i> == ~0).</P>
<P><I>See also: </I>[ <B><a href="#_bitset_hi">bitset_hi</a></B> | <B><a href="#_bitset_lo">bitset_lo</a></B> | <B><a href="#_bitclr_hi">bitclr_hi</a></B> ]</P>
<!-- ../src/E_Num.cpp:1194 -->

<HR />
<a name="_bitrev"></a>
<P><font face=Arial size=+1 color=#808080><B>bitrev</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitrev </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Reverse bits order.</I></P>
<P>Return bit reversion of <i>Value</i>.</P>
<P></P>
<!-- ../src/E_Num.cpp:1222 -->

<HR />
<a name="_bitset_count"></a>
<P><font face=Arial size=+1 color=#808080><B>bitset_count</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitset_count </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Count all set bits.</I></P>
<P>Return total count of all set bits in <i>Value</i> (0, if <i>Value</i> == 0).</P>
<P><I>See also: </I>[ <B><a href="#_bitclr_count">bitclr_count</a></B> ]</P>
<!-- ../src/E_Num.cpp:1207 -->

<HR />
<a name="_bitset_hi"></a>
<P><font face=Arial size=+1 color=#808080><B>bitset_hi</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitset_hi </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Locate highest set bit.</I></P>
<P>Return index of highest set bit in <i>Value</i> (or -1, if <i>Value</i> == 0).</P>
<P><I>See also: </I>[ <B><a href="#_bitset_lo">bitset_lo</a></B> | <B><a href="#_bitclr_hi">bitclr_hi</a></B> | <B><a href="#_bitclr_lo">bitclr_lo</a></B> ]</P>
<!-- ../src/E_Num.cpp:1176 -->

<HR />
<a name="_bitset_lo"></a>
<P><font face=Arial size=+1 color=#808080><B>bitset_lo</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>bitset_lo </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Locate lowest set bit.</I></P>
<P>Return index of lowest set bit in <i>Value</i> (or -1, if <i>Value</i> == 0).</P>
<P><I>See also: </I>[ <B><a href="#_bitset_hi">bitset_hi</a></B> | <B><a href="#_bitclr_hi">bitclr_hi</a></B> | <B><a href="#_bitclr_lo">bitclr_lo</a></B> ]</P>
<!-- ../src/E_Num.cpp:1182 -->

<HR /><a name="_67"></a>
<P><font size=+1 color=red>= <B>C</B> =</font></P>
<HR />
<a name="_c_and"></a>
<P><font face=Arial size=+1 color=#808080><B>c_and</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>c_and </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_0">0</a></b> | <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Conditional short-circuit "AND" operation.</I></P>
<P>If boolean condition <i>Cond</i> is <b>true</b>, evaluates and returns <i>Body</i>; otherwise returns <b>false</b> (0).<br>Equivalent to: <b>if</b> (<i>Cond</i>, <i>Body</i>, 0).</P>
<P><I>See also: </I>[ <B><a href="#_c_not">c_not</a></B> | <B><a href="#_c_or">c_or</a></B> ]</P>
<!-- ../src/E_Control.cpp:379 -->

<HR />
<a name="_c_not"></a>
<P><font face=Arial size=+1 color=#808080><B>c_not</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>c_not </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Conditional "NOT" operation.</I></P>
<P>If boolean condition <i>Cond</i> is <b>false</b>, returns <b>true</b> (1); otherwise returns <b>false</b> (0).<br>Equivalent to: <b>if</b> (<i>Cond</i>, 0, 1).</P>
<P><I>See also: </I>[ <B><a href="#_c_and">c_and</a></B> | <B><a href="#_c_or">c_or</a></B> ]</P>
<!-- ../src/E_Control.cpp:371 -->

<HR />
<a name="_c_or"></a>
<P><font face=Arial size=+1 color=#808080><B>c_or</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>c_or </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_1">1</a></b> | <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Conditional short-circuit "OR" operation.</I></P>
<P>If boolean condition <i>Cond</i> is <b>false</b>, evaluates and returns <i>Body</i>; otherwise returns <b>true</b> (1).<br>Equivalent to: <b>unless</b> (<i>Cond</i>, <i>Body</i>, 1).</P>
<P><I>See also: </I>[ <B><a href="#_c_not">c_not</a></B> | <B><a href="#_c_and">c_and</a></B> ]</P>
<!-- ../src/E_Control.cpp:386 -->

<HR />
<a name="_cc_alpha"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_alpha</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_alpha </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for any letter.</I></P>
<P>True, if <i>CharCode</i> is letter.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2867 -->

<HR />
<a name="_cc_blank"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_blank</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_blank </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for blank character.</I></P>
<P>True, if <i>CharCode</i> is blank char.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> ]</P>
<!-- ../src/E_String.cpp:2887 -->

<HR />
<a name="_cc_digit"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_digit</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_digit </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for decimal digit.</I></P>
<P>True, if <i>CharCode</i> is decimal digit.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2872 -->

<HR />
<a name="_cc_excl"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_excl</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>cc_excl </B> (<i>CharSet</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Charset predicate exclusive composer.</I></P>
<P>Create and return predicate, returning <b>true</b> for characters present in <i>CharSet</i> (and <b>false</b> for all other).</P>
<P><I>See also: </I>[ <B><a href="#_cc_incl">cc_incl</a></B> ]</P>
<!-- ../src/E_String.cpp:2640 -->

<HR />
<a name="_cc_incl"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_incl</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>cc_incl </B> (<i>CharSet</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Charset predicate inclusive composer.</I></P>
<P>Create and return predicate, returning <b>false</b> for characters present in <i>CharSet</i> (and <b>true</b> for all other).</P>
<P><I>See also: </I>[ <B><a href="#_cc_excl">cc_excl</a></B> ]</P>
<!-- ../src/E_String.cpp:2646 -->

<HR />
<a name="_cc_lower"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_lower</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_lower </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for lowercase letter.</I></P>
<P>True, if <i>CharCode</i> is lowercase letter.</P>
<P><I>See also: </I>[ <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2857 -->

<HR />
<a name="_cc_odigit"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_odigit</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_odigit </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for octal digit.</I></P>
<P>True, if <i>CharCode</i> is octal digit.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2877 -->

<HR />
<a name="_cc_upper"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_upper</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_upper </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for uppercase letter.</I></P>
<P>True, if <i>CharCode</i> is uppercase letter.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_xdigit">cc_xdigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2862 -->

<HR />
<a name="_cc_xdigit"></a>
<P><font face=Arial size=+1 color=#808080><B>cc_xdigit</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Character">Character</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>cc_xdigit </B> (<i>CharCode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check code for hex digit.</I></P>
<P>True, if <i>CharCode</i> is hexadecimal digit.</P>
<P><I>See also: </I>[ <B><a href="#_cc_lower">cc_lower</a></B> | <B><a href="#_cc_upper">cc_upper</a></B> | <B><a href="#_cc_alpha">cc_alpha</a></B> | <B><a href="#_cc_digit">cc_digit</a></B> | <B><a href="#_cc_odigit">cc_odigit</a></B> | <B><a href="#_cc_blank">cc_blank</a></B> ]</P>
<!-- ../src/E_String.cpp:2882 -->

<HR />
<a name="_ceil"></a>
<P><font face=Arial size=+1 color=#808080><B>ceil</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>ceil </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric rounding up.</I></P>
<P>Arithmetic "ceiling" value: round <i>X</i> up to nearest integer.</P>
<P><I>See also: </I>[ <B><a href="#_floor">floor</a></B> ]</P>
<!-- ../src/E_Num.cpp:826 -->

<HR />
<a name="_class_of"></a>
<P><font face=Arial size=+1 color=#808080><B>class_of</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>class_of </B> (<i>Object</i>: <b><a href="AWL_Types.htm#_Object">Object</a></b>) &#8658; <b><a href="AWL_Types.htm#_Class">Class</a></b>.</LI>
<P><I>Retrieve class of object.</I></P>
<P>Evaluates object <i>Object</i>, and returns class, to which <i>Object</i> belongs.<br>(Returns <b>undef</b>, if <i>Object</i> is not a class instance.)</P>
<P><I>See also: </I>[ <B><a href="#_self">self</a></B> | <B><a href="#_super_of">super_of</a></B> ]</P>
<!-- ../src/E_Object.cpp:377 -->

<HR />
<a name="_closure"></a>
<P><font face=Arial size=+1 color=#808080><B>closure</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>closure </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>Callee</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Closure constructor.</I></P>
<P>Create and return closure: <i>Callee</i> with bound context of <i>Context</i>.</P>
<P></P>
<!-- ../src/E_Func.cpp:752 -->

<HR />
<a name="_clr"></a>
<P><font face=Arial size=+1 color=#808080><B>clr</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>clr </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Clear mutable.</I></P>
<P>Resets value of mutable <i>V</i> (which must belong to numeric type) to 0.<br>Returns 0.</P>
<P><I>See also: </I>[ <B><a href="#_inc">inc</a></B> | <B><a href="#_dec">dec</a></B> | <B><a href="#_inc_p">inc_p</a></B> | <B><a href="#_dec_p">dec_p</a></B> ]</P>
<!-- ../src/E_Mut.cpp:596 -->

<HR />
<a name="_cmp"></a>
<P><font face=Arial size=+1 color=#808080><B>cmp</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Compare">Compare</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>cmp </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Sign">Sign</a></b>.</LI>
<P><I>Numeric signed comparison.</I></P>
<P>Arithmetic signed compare: equivalent to <i>A</i> < <i>B</i> ? -1 : <i>A</i> > <i>B</i> ? 1 : 0 (with <i>A</i> and <i>B</i> evaluated once).<br>Syntax: <i>A</i> <?> <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_u_cmp">u_cmp</a></B> ]</P>
<!-- ../src/E_Num.cpp:1142 -->

<HR />
<a name="_codec_codepage"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_codepage</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_codepage </B> (<i>CodePage</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>Code page codec.</I></P>
<P>Creates codec for data encoding/decoding with codepage defined with <i>Codepage</i>.</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF8">codec_UTF8</a></B> | <B><a href="#_codec_UTF16">codec_UTF16</a></B> | <B><a href="#_codec_UTF32">codec_UTF32</a></B> | <B><a href="#_codec_SMBC">codec_SMBC</a></B> | <B><a href="#_codec_hexdump">codec_hexdump</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1909 -->

<HR />
<a name="_codec_hexdump"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_hexdump</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_hexdump </B> () &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>Hexdump codec.</I></P>
<P>Creates codec for data encoding/decoding as plain hexdigits sequences.</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF8">codec_UTF8</a></B> | <B><a href="#_codec_UTF16">codec_UTF16</a></B> | <B><a href="#_codec_UTF32">codec_UTF32</a></B> | <B><a href="#_codec_SMBC">codec_SMBC</a></B> | <B><a href="#_codec_codepage">codec_codepage</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1914 -->

<HR />
<a name="_codec_SMBC"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_SMBC</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_SMBC </B> () &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>SMBC codec.</I></P>
<P>Creates codec for SMBC data encoding/decoding.</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF8">codec_UTF8</a></B> | <B><a href="#_codec_UTF16">codec_UTF16</a></B> | <B><a href="#_codec_UTF32">codec_UTF32</a></B> | <B><a href="#_codec_codepage">codec_codepage</a></B> | <B><a href="#_codec_hexdump">codec_hexdump</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1904 -->

<HR />
<a name="_codec_UTF16"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_UTF16</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_UTF16 </B> (<i>Endianness</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>UTF-16 codec.</I></P>
<P>Creates codec for UTF-16 data encoding/decoding (<i>Endianness</i> ? Big Endian : Little Endian).</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF8">codec_UTF8</a></B> | <B><a href="#_codec_UTF32">codec_UTF32</a></B> | <B><a href="#_codec_SMBC">codec_SMBC</a></B> | <B><a href="#_codec_codepage">codec_codepage</a></B> | <B><a href="#_codec_hexdump">codec_hexdump</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1894 -->

<HR />
<a name="_codec_UTF32"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_UTF32</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_UTF32 </B> (<i>Endianness</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>UTF-32 codec.</I></P>
<P>Creates codec for UTF-32 data encoding/decoding (<i>Endianness</i> ? Big Endian : Little Endian).</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF8">codec_UTF8</a></B> | <B><a href="#_codec_UTF16">codec_UTF16</a></B> | <B><a href="#_codec_SMBC">codec_SMBC</a></B> | <B><a href="#_codec_codepage">codec_codepage</a></B> | <B><a href="#_codec_hexdump">codec_hexdump</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1899 -->

<HR />
<a name="_codec_UTF8"></a>
<P><font face=Arial size=+1 color=#808080><B>codec_UTF8</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>codec_UTF8 </B> () &#8658; <b><a href="AWL_Types.htm#_Codec">Codec</a></b>.</LI>
<P><I>UTF-8 codec.</I></P>
<P>Creates codec for UTF-8 data encoding/decoding.</P>
<P><I>See also: </I>[ <B><a href="#_codec_UTF16">codec_UTF16</a></B> | <B><a href="#_codec_UTF32">codec_UTF32</a></B> | <B><a href="#_codec_SMBC">codec_SMBC</a></B> | <B><a href="#_codec_codepage">codec_codepage</a></B> | <B><a href="#_codec_hexdump">codec_hexdump</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1889 -->

<HR />
<a name="_comb"></a>
<P><font face=Arial size=+1 color=#808080><B>comb</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Meta">Meta</a></b> ]</LI>
<LI type=disc><B>comb </B> (<i>Operation</i>: <b><a href="AWL_Types.htm#_Term">Term</a></b>) &#8658; <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>.</LI>
<P><I>Implements combined assignment.</I></P>
<P>Evaluation of assignment combined with unary/binary term <i>Operation</i>.</P>
<P><I>See also: </I>[ <B><a href="#_reduce">reduce</a></B> ]</P>
<!-- ../src/E_Mut.cpp:579 -->

<HR />
<a name="_cons_time"></a>
<P><font face=Arial size=+1 color=#808080><B>cons_time</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>cons_time </B> (<i>Year</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Month</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Day</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Hour</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Min</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Sec</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Construct time from list.</I></P>
<P>Convert time in (Year:Month:Day), (Hour.Min.Sec) format to Epoch seconds.</P>
<P></P>
<!-- ../src/E_System.cpp:740 -->

<HR />
<a name="_cos"></a>
<P><font face=Arial size=+1 color=#808080><B>cos</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>cos </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric cosine.</I></P>
<P>Cosine of <i>X</i> (with argument in radians).</P>
<P><I>See also: </I>[ <B><a href="#_sin">sin</a></B> | <B><a href="#_tan">tan</a></B> | <B><a href="#_acos">acos</a></B> ]</P>
<!-- ../src/E_Num.cpp:874 -->

<HR />
<a name="_cosh"></a>
<P><font face=Arial size=+1 color=#808080><B>cosh</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>cosh </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric hyperbolic cosine.</I></P>
<P>Hyperbolic Cosine of <i>X</i>.<br>(Equals to: (<b>exp</b>(<i>X</i>) + <b>exp</b>(-<i>X</i>)) / 2).</P>
<P><I>See also: </I>[ <B><a href="#_sinh">sinh</a></B> | <B><a href="#_tanh">tanh</a></B> ]</P>
<!-- ../src/E_Num.cpp:921 -->

<HR /><a name="_68"></a>
<P><font size=+1 color=red>= <B>D</B> =</font></P>
<HR />
<a name="_dc_b"></a>
<P><font face=Arial size=+1 color=#808080><B>dc_b</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Decoder">Decoder</a></b> ]</LI>
<LI type=disc><B>dc_b </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Decode unsigned byte.</I></P>
<P>Decode (from string fragment to 8 bit unsigned integer): convert 1 byte of string <i>S</i> at offset <i>Offset</i> (defaults to 0) to unsigned integer.</P>
<P><I>See also: </I>[ <B><a href="#_dc_sb">dc_sb</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> | <B><a href="#_dc_w">dc_w</a></B> | <B><a href="#_dc_l">dc_l</a></B> | <B><a href="#_ec_b">ec_b</a></B> | <B><a href="#_dc_sb">dc_sb</a></B> ]</P>
<!-- ../src/E_String.cpp:2468 -->

<HR />
<a name="_dc_l"></a>
<P><font face=Arial size=+1 color=#808080><B>dc_l</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Decoder">Decoder</a></b> ]</LI>
<LI type=disc><B>dc_l </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Decode long.</I></P>
<P>Decode (from string fragment to 32 bit signed/unsigned integer): convert 4 bytes of string <i>S</i> at offset <i>Offset</i> (defaults to 0) to integer.</P>
<P><I>See also: </I>[ <B><a href="#_dc_sb">dc_sb</a></B> | <B><a href="#_dc_b">dc_b</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> | <B><a href="#_dc_w">dc_w</a></B> | <B><a href="#_ec_l">ec_l</a></B> ]</P>
<!-- ../src/E_String.cpp:2486 -->

<HR />
<a name="_dc_sb"></a>
<P><font face=Arial size=+1 color=#808080><B>dc_sb</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Decoder">Decoder</a></b> ]</LI>
<LI type=disc><B>dc_sb </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Decode signed byte.</I></P>
<P>Decode (from string fragment to 8 bit signed integer): convert 1 byte of string <i>S</i> at offset <i>Offset</i> (defaults to 0) to signed integer.</P>
<P><I>See also: </I>[ <B><a href="#_dc_b">dc_b</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> | <B><a href="#_dc_w">dc_w</a></B> | <B><a href="#_dc_l">dc_l</a></B> | <B><a href="#_ec_b">ec_b</a></B> | <B><a href="#_dc_b">dc_b</a></B> ]</P>
<!-- ../src/E_String.cpp:2462 -->

<HR />
<a name="_dc_sw"></a>
<P><font face=Arial size=+1 color=#808080><B>dc_sw</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Decoder">Decoder</a></b> ]</LI>
<LI type=disc><B>dc_sw </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Decode signed word.</I></P>
<P>Decode (from string fragment to 16 bit signed integer): convert 2 bytes of string <i>S</i> at offset <i>Offset</i> (defaults to 0) to signed integer.</P>
<P><I>See also: </I>[ <B><a href="#_dc_sb">dc_sb</a></B> | <B><a href="#_dc_b">dc_b</a></B> | <B><a href="#_dc_w">dc_w</a></B> | <B><a href="#_dc_l">dc_l</a></B> | <B><a href="#_ec_w">ec_w</a></B> | <B><a href="#_dc_w">dc_w</a></B> ]</P>
<!-- ../src/E_String.cpp:2474 -->

<HR />
<a name="_dc_w"></a>
<P><font face=Arial size=+1 color=#808080><B>dc_w</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Decoder">Decoder</a></b> ]</LI>
<LI type=disc><B>dc_w </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Decode unsigned word.</I></P>
<P>Decode (from string fragment to 16 bit unsigned integer): convert 2 bytes of string <i>S</i> at offset <i>Offset</i> (defaults to 0) to unsigned integer.</P>
<P><I>See also: </I>[ <B><a href="#_dc_sb">dc_sb</a></B> | <B><a href="#_dc_b">dc_b</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> | <B><a href="#_dc_l">dc_l</a></B> | <B><a href="#_ec_w">ec_w</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> ]</P>
<!-- ../src/E_String.cpp:2480 -->

<HR />
<a name="_deblock"></a>
<P><font face=Arial size=+1 color=#808080><B>deblock</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Block">Block</a></b> ]</LI>
<LI type=disc><B>deblock</B> (<i>B</i>: <b><a href="AWL_Types.htm#_Block">Block</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Deconstruct block to item list.</I></P>
<P>Deconstruct block <i>B</i> to list of expressions.<br>(Reverse to <b>enblock</b>).</P>
<P><I>See also: </I>[ <B><a href="#_enblock">enblock</a></B> ]</P>
<!-- ../src/E_Func.cpp:703 -->

<HR />
<a name="_dec"></a>
<P><font face=Arial size=+1 color=#808080><B>dec</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>dec </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Pre-decrement.</I></P>
<P>Decrements value of mutable <i>V</i> (which must belong to numeric type) by 1.<br>Returns: value of <i>V</i> after decrement.<br>Syntax: -- <i>V</i>.</P>
<P><I>See also: </I>[ <B><a href="#_clr">clr</a></B> | <B><a href="#_inc">inc</a></B> | <B><a href="#_inc_p">inc_p</a></B> | <B><a href="#_dec_p">dec_p</a></B> ]</P>
<!-- ../src/E_Mut.cpp:611 -->

<HR />
<a name="_dec_p"></a>
<P><font face=Arial size=+1 color=#808080><B>dec_p</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>dec_p </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Post-decrement.</I></P>
<P>Decrements value of mutable <i>V</i> (which must belong to numeric type) by 1.<br>Returns value of <i>V</i> before decrement.<br>Syntax: <i>V</i> --.</P>
<P><I>See also: </I>[ <B><a href="#_clr">clr</a></B> | <B><a href="#_inc">inc</a></B> | <B><a href="#_dec">dec</a></B> | <B><a href="#_inc_p">inc_p</a></B> ]</P>
<!-- ../src/E_Mut.cpp:625 -->

<HR />
<a name="_determ"></a>
<P><font face=Arial size=+1 color=#808080><B>determ</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Term">Term</a></b> ]</LI>
<LI type=disc><B>determ</B> (<i>T</i>: <b><a href="AWL_Types.htm#_Term">Term</a></b>) &#8658; (<b><a href="AWL_Types.htm#_Func">Func</a></b>, <b><a href="AWL_Types.htm#_Any">Any</a></b>).</LI>
<P><I>Deconstruct term to functor and argument(s).</I></P>
<P>Deconstruct term <i>T</i> to list of functor reference and argument(s).<br>(Reverse to <b>enterm</b>).</P>
<P><I>See also: </I>[ <B><a href="#_enterm">enterm</a></B> ]</P>
<!-- ../src/E_Func.cpp:686 -->

<HR />
<a name="_deval"></a>
<P><font face=Arial size=+1 color=#808080><B>deval</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>deval </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expression devaluation.</I></P>
<P>Inhibit evaluation of expression <i>X</i> (returning <i>X</i> proper).<br>Syntax: @<i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_reval">reval</a></B> ]</P>
<!-- ../src/E_Mut.cpp:647 -->

<HR />
<a name="_devirt"></a>
<P><font face=Arial size=+1 color=#808080><B>devirt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>devirt </B> (<i>Virtual</i>: <b><a href="AWL_Types.htm#_Virtual">Virtual</a></b>, <i>Class</i>: <b><a href="AWL_Types.htm#_Class">Class</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Explicit devirtualization.</I></P>
<P>Returns proper version of virtual method <i>Virtual</i>, implemented in class <i>Class</i>.</P>
<P><I>See also: </I>[ <B><a href="#_originator">originator</a></B> ]</P>
<!-- ../src/E_Object.cpp:425 -->

<HR />
<a name="_differ"></a>
<P><font face=Arial size=+1 color=#808080><B>differ</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>differ </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>W</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Test for difference.</I></P>
<P>Check results of <i>V</i> and <i>W</i> for structural difference: <b>false</b> (0), if both operands evaluate to same result; <b>true</b> (1) otherwise.<br>Syntax: <i>V</i> [<>] <i>W</i>.</P>
<P><I>See also: </I>[ <B><a href="#_hcode">hcode</a></B> | <B><a href="#_ident">ident</a></B> ]</P>
<!-- ../src/E_Hash.cpp:780 -->

<HR />
<a name="_dir_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>dir_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>dir_loop </B> (<i>DirName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>FileName</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Directory iterator.</I></P>
<P>Iterate through directory <i>DirName</i>, setting <i>FileName</i> to each file, and evaluating <i>Body</i>.<br>Returns final result of <i>Body</i>.</P>
<P></P>
<!-- ../src/E_System.cpp:700 -->

<HR />
<a name="_div"></a>
<P><font face=Arial size=+1 color=#808080><B>div</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>div </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Y</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric division.</I></P>
<P>Arithmetic ratio of arguments <i>X</i> and <i>Y</i>.<br>Syntax: <i>X</i> / <i>Y</i>.</P>
<P><I>See also: </I>[ <B><a href="#_mul">mul</a></B> ]</P>
<!-- ../src/E_Num.cpp:962 -->

<HR />
<a name="_do_until"></a>
<P><font face=Arial size=+1 color=#808080><B>do_until</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>do_until </B> (@<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterator with negative postcondition.</I></P>
<P>Repeatedly pre-evaluates <i>Body</i>, while <i>Cond</i> remains <b>false</b>.<br>Returns final value of <i>Body</i> (which is always evaluated at least once).</P>
<P><I>See also: </I>[ <B><a href="#_while">while</a></B> | <B><a href="#_until">until</a></B> | <B><a href="#_do_while">do_while</a></B> ]</P>
<!-- ../src/E_Control.cpp:436 -->

<HR />
<a name="_do_while"></a>
<P><font face=Arial size=+1 color=#808080><B>do_while</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>do_while </B> (@<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterator with positive postcondition.</I></P>
<P>Repeatedly pre-evaluates <i>Body</i>, while <i>Cond</i> remains <b>true</b>.<br>Returns final value of <i>Body</i> (which is always evaluated at least once).</P>
<P><I>See also: </I>[ <B><a href="#_while">while</a></B> | <B><a href="#_until">until</a></B> | <B><a href="#_do_until">do_until</a></B> ]</P>
<!-- ../src/E_Control.cpp:430 -->

<HR /><a name="_69"></a>
<P><font size=+1 color=red>= <B>E</B> =</font></P>
<HR />
<a name="_ec_b"></a>
<P><font face=Arial size=+1 color=#808080><B>ec_b</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Encoder">Encoder</a></b> ]</LI>
<LI type=disc><B>ec_b </B> (<i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Encode byte.</I></P>
<P>Encode (from 8 bit signed/unsigned to string):  convert integer <i>Code</i> to string of length 1.</P>
<P><I>See also: </I>[ <B><a href="#_ec_w">ec_w</a></B> | <B><a href="#_ec_l">ec_l</a></B> | <B><a href="#_dc_b">dc_b</a></B> | <B><a href="#_dc_sb">dc_sb</a></B> ]</P>
<!-- ../src/E_String.cpp:2500 -->

<HR />
<a name="_ec_l"></a>
<P><font face=Arial size=+1 color=#808080><B>ec_l</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Encoder">Encoder</a></b> ]</LI>
<LI type=disc><B>ec_l </B> (<i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Encode long.</I></P>
<P>Encode (from 32 bit signed/unsigned to string):  convert integer <i>Code</i> to string of length 4.</P>
<P><I>See also: </I>[ <B><a href="#_ec_b">ec_b</a></B> | <B><a href="#_ec_w">ec_w</a></B> | <B><a href="#_dc_l">dc_l</a></B> ]</P>
<!-- ../src/E_String.cpp:2512 -->

<HR />
<a name="_ec_w"></a>
<P><font face=Arial size=+1 color=#808080><B>ec_w</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Encoder">Encoder</a></b> ]</LI>
<LI type=disc><B>ec_w </B> (<i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Encode word.</I></P>
<P>Encode (from 16 bit signed/unsigned to string):  convert integer <i>Code</i> to string of length 2.</P>
<P><I>See also: </I>[ <B><a href="#_ec_b">ec_b</a></B> | <B><a href="#_ec_l">ec_l</a></B> | <B><a href="#_dc_w">dc_w</a></B> | <B><a href="#_dc_sw">dc_sw</a></B> ]</P>
<!-- ../src/E_String.cpp:2506 -->

<HR />
<a name="_enblock"></a>
<P><font face=Arial size=+1 color=#808080><B>enblock</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Block">Block</a></b> ]</LI>
<LI type=disc><B>enblock</B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Block">Block</a></b>.</LI>
<P><I>Construct block from item list.</I></P>
<P>Construct block from list of expressions <i>L</i>.<br>(Reverse to <b>deblock</b>).</P>
<P><I>See also: </I>[ <B><a href="#_deblock">deblock</a></B> ]</P>
<!-- ../src/E_Func.cpp:697 -->

<HR />
<a name="_enterm"></a>
<P><font face=Arial size=+1 color=#808080><B>enterm</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Term">Term</a></b> ]</LI>
<LI type=disc><B>enterm</B> (<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>A</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Term">Term</a></b>.</LI>
<P><I>Construct term from functor and argument(s).</I></P>
<P>Construct term from functor reference <i>F</i> and argument(s) <i>A</i>.<br>(Reverse to <b>determ</b>).</P>
<P><I>See also: </I>[ <B><a href="#_determ">determ</a></B> ]</P>
<!-- ../src/E_Func.cpp:680 -->

<HR />
<a name="_eq"></a>
<P><font face=Arial size=+1 color=#808080><B>eq</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>eq </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric equality.</I></P>
<P>Arithmetic equality test: true, if <i>A</i> equals to <i>B</i>.<br>Syntax: <i>A</i> == <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_lt">lt</a></B> | <B><a href="#_le">le</a></B> | <B><a href="#_gt">gt</a></B> | <B><a href="#_ge">ge</a></B> | <B><a href="#_ne">ne</a></B> ]</P>
<!-- ../src/E_Num.cpp:1121 -->

<HR />
<a name="_eval_r"></a>
<P><font face=Arial size=+1 color=#808080><B>eval_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>eval_r </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>R-evaluation.</I></P>
<P>Internal: R-mode evaluation of mutable expression <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_eval_v">eval_v</a></B> | <B><a href="#_eval_x">eval_x</a></B> ]</P>
<!-- ../src/E_Mut.cpp:675 -->

<HR />
<a name="_eval_v"></a>
<P><font face=Arial size=+1 color=#808080><B>eval_v</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>eval_v </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>V-evaluation.</I></P>
<P>Internal: V-mode evaluation of expression <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_eval_x">eval_x</a></B> | <B><a href="#_eval_r">eval_r</a></B> ]</P>
<!-- ../src/E_Mut.cpp:665 -->

<HR />
<a name="_eval_x"></a>
<P><font face=Arial size=+1 color=#808080><B>eval_x</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>eval_x </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>X-evaluation.</I></P>
<P>Internal: X-mode evaluation of expression <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_eval_v">eval_v</a></B> | <B><a href="#_eval_r">eval_r</a></B> ]</P>
<!-- ../src/E_Mut.cpp:670 -->

<HR />
<a name="_ever"></a>
<P><font face=Arial size=+1 color=#808080><B>ever</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>ever </B> (@<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterate forever.</I></P>
<P>Evaluates <i>Body</i> infinitely (or until exception interrupts).<br>Returns final value of <i>Body</i>.</P>
<P><I>See also: </I>[ <B><a href="#_for_inc">for_inc</a></B> | <B><a href="#_for_dec">for_dec</a></B> | <B><a href="#_times">times</a></B> ]</P>
<!-- ../src/E_Control.cpp:474 -->

<HR />
<a name="_exp"></a>
<P><font face=Arial size=+1 color=#808080><B>exp</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>exp </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric exponentiation.</I></P>
<P>Exponent of <i>X</i>: <i>e</i> raised to power <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_log">log</a></B> | <B><a href="#_exp_by">exp_by</a></B> | <B><a href="#_log_by">log_by</a></B> ]</P>
<!-- ../src/E_Num.cpp:845 -->

<HR />
<a name="_exp_by"></a>
<P><font face=Arial size=+1 color=#808080><B>exp_by</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>exp_by </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Y</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric rise to power.</I></P>
<P>Returns <i>X</i> raised to power <i>Y</i>.<br>(Same as: <b>exp</b> (<b>log</b>(<i>X</i>) * <i>Y</i>) ).</P>
<P><I>See also: </I>[ <B><a href="#_exp">exp</a></B> | <B><a href="#_log">log</a></B> | <B><a href="#_log_by">log_by</a></B> ]</P>
<!-- ../src/E_Num.cpp:1056 -->

<HR />
<a name="_expect_array"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_array</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Array">Array</a></b> ]</LI>
<LI type=disc><B>expect_array </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect array value.</I></P>
<P>If argument <i>V</i> evaluates to array, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P></P>
<!-- ../src/E_Array.cpp:1334 -->

<HR />
<a name="_expect_float"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_float</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>expect_float </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect float value.</I></P>
<P>If argument <i>V</i> evaluates to float scalar, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P><I>See also: </I>[ <B><a href="#_expect_int">expect_int</a></B> ]</P>
<!-- ../src/E_Num.cpp:774 -->

<HR />
<a name="_expect_hash"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_hash</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>expect_hash </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect hash value.</I></P>
<P>If argument <i>V</i> evaluates to hash, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P><I>See also: </I>[ <B><a href="#_is_hash">is_hash</a></B> ]</P>
<!-- ../src/E_Hash.cpp:799 -->

<HR />
<a name="_expect_int"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_int</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>expect_int </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect integer value.</I></P>
<P>If argument <i>V</i> evaluates to integer scalar, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P><I>See also: </I>[ <B><a href="#_expect_float">expect_float</a></B> ]</P>
<!-- ../src/E_Num.cpp:768 -->

<HR />
<a name="_expect_list"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_list</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>expect_list </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect list value.</I></P>
<P>If argument <i>V</i> evaluates to list, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P></P>
<!-- ../src/E_List.cpp:1143 -->

<HR />
<a name="_expect_object"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_object</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>expect_object </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect object value.</I></P>
<P>If argument <i>V</i> evaluates to any class instance, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P><I>See also: </I>[ <B><a href="#_is_object">is_object</a></B> | <B><a href="#_is_class">is_class</a></B> | <B><a href="#_is_virtual">is_virtual</a></B> ]</P>
<!-- ../src/E_Object.cpp:353 -->

<HR />
<a name="_expect_pattern"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_pattern</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>expect_pattern </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect pattern value.</I></P>
<P>If argument <i>V</i> evaluates to pattern, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2329 -->

<HR />
<a name="_expect_string"></a>
<P><font face=Arial size=+1 color=#808080><B>expect_string</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>expect_string </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expect string value.</I></P>
<P>If argument <i>V</i> evaluates to string, evaluates and returns <i>Body</i>.<br>(Reports type error otherwise.)</P>
<P><I>See also: </I>[ <B><a href="#_is_string">is_string</a></B> ]</P>
<!-- ../src/E_String.cpp:2281 -->

<HR /><a name="_70"></a>
<P><font size=+1 color=red>= <B>F</B> =</font></P>
<HR />
<a name="_f_access"></a>
<P><font face=Arial size=+1 color=#808080><B>f_access</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_access </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Mode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Verify access to file.</I></P>
<P>Check, is file <i>FileName</i> accessible by <i>Mode</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:637 -->

<HR />
<a name="_f_and"></a>
<P><font face=Arial size=+1 color=#808080><B>f_and</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>f_and </B> (<i>Pred1</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>Pred2</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Functional "AND" predicates composition.</I></P>
<P>For predicates <i>Pred1</i> and <i>Pred2</i>, results in predicate, evaluating to conditional AND of <i>Pred1</i> and <i>Pred2</i>.<br>( <b>f_and</b> (<i>Pred1</i>, <i>Pred2</i>) ! (<i>Arg</i>) == <b>c_and</b> (<i>Pred1</i> ! <i>Arg</i>, <i>Pred2</i> ! <i>Arg</i>) ).</P>
<P><I>See also: </I>[ <B><a href="#_f_not">f_not</a></B> | <B><a href="#_f_or">f_or</a></B> ]</P>
<!-- ../src/E_Func.cpp:737 -->

<HR />
<a name="_f_at_end"></a>
<P><font face=Arial size=+1 color=#808080><B>f_at_end</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>f_at_end </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for end of stream.</I></P>
<P>Return true, if <i>Stream</i> has reached end.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1833 -->

<HR />
<a name="_f_attr"></a>
<P><font face=Arial size=+1 color=#808080><B>f_attr</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_attr </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Get stream info.</I></P>
<P>Return list of attributes and properties of <i>Stream</i>.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1876 -->

<HR />
<a name="_f_bufmode"></a>
<P><font face=Arial size=+1 color=#808080><B>f_bufmode</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_bufmode </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>BufSize</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Set stream buffer size.</I></P>
<P>Set size of internal I/O buffer of stream <i>Stream</i> to <i>BufSize</i>.<br>(Disable buffering completely, if 0).</P>
<P><I>See also: </I>[ <B><a href="#_f_sync">f_sync</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1825 -->

<HR />
<a name="_f_chdir"></a>
<P><font face=Arial size=+1 color=#808080><B>f_chdir</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_chdir </B> (<i>DirName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Change current directory.</I></P>
<P>Change current directory to <i>DirName</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:661 -->

<HR />
<a name="_f_chmod"></a>
<P><font face=Arial size=+1 color=#808080><B>f_chmod</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_chmod </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>FileMode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Change file access mode.</I></P>
<P>Change access mode of file <i>FileName</i> to <i>FileMode</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:685 -->

<HR />
<a name="_f_close"></a>
<P><font face=Arial size=+1 color=#808080><B>f_close</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Destructor">Destructor</a></b> ]</LI>
<LI type=disc><B>f_close </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; ().</LI>
<P><I>Close opened stream.</I></P>
<P>Close previously opened <i>Stream</i>.</P>
<P><I>See also: </I>[ <B><a href="#_f_open">f_open</a></B> | <B><a href="#_f_create">f_create</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1746 -->

<HR />
<a name="_f_compose"></a>
<P><font face=Arial size=+1 color=#808080><B>f_compose</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>f_compose </B> (<i>F_f</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>F_g</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Functional composition.</I></P>
<P>Returns functional composition of <i>F_f</i> and <i>F_g</i>.<br>(Result of (<b>f_compose</b> (<i>F_f</i>, <i>F_g</i>)) ! (<i>V</i>) is equal to <i>F_f</i> ! (<i>F_g</i> ! (<i>V</i>)) for any <i>V</i>.)</P>
<P></P>
<!-- ../src/E_Func.cpp:719 -->

<HR />
<a name="_f_create"></a>
<P><font face=Arial size=+1 color=#808080><B>f_create</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>f_create </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b> [, <i>AccessMode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Stream">Stream</a></b>.</LI>
<P><I>Open file as stream.</I></P>
<P>Opens system file <i>FileName</i> with <i>AccessMode</i> (as for C "open" library func).<br>Defaults <i>AccessMode</i> to O_WRONLY|O_CREAT|O_BINARY.<br>Returns new stream or <b>undef</b>, if open failed.</P>
<P><I>See also: </I>[ <B><a href="#_f_open">f_open</a></B> | <B><a href="#_f_close">f_close</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1737 -->

<HR />
<a name="_f_err"></a>
<P><font face=Arial size=+1 color=#808080><B>f_err</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>f_err </B> () &#8658; <b><a href="AWL_Types.htm#_Stream">Stream</a></b>.</LI>
<P><I>Standard error output.</I></P>
<P>Returns default error output stream.</P>
<P><I>See also: </I>[ <B><a href="#_f_in">f_in</a></B> | <B><a href="#_f_out">f_out</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1696 -->

<HR />
<a name="_f_get"></a>
<P><font face=Arial size=+1 color=#808080><B>f_get</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>f_get </B> ([<i>In</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>], <i>Line</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>,  ...) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get line(s) from stream (as strings).</I></P>
<P>Reads lines from the input stream <i>In</i> (or default input, if <i>In</i> is undefined).<br>Assigns all strings values read to mutables from list of <i>Line</i>.<br>(Final EOLs are removed.)<br>Returns: number of lines successfully read and stored.</P>
<P><I>See also: </I>[ <B><a href="#_f_put">f_put</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1707 -->

<HR />
<a name="_f_get_length"></a>
<P><font face=Arial size=+1 color=#808080><B>f_get_length</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_get_length </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get stream file length.</I></P>
<P>Return current length of file for <i>Stream</i> (or -1, if <i>Stream</i> is not a file).</P>
<P></P>
<!-- ../src/E_Stream.cpp:1847 -->

<HR />
<a name="_f_getc"></a>
<P><font face=Arial size=+1 color=#808080><B>f_getc</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_getc </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get character from stream.</I></P>
<P>Returns code of next character read from input stream <i>Stream</i> (or <b>undef</b> on EOF).</P>
<P><I>See also: </I>[ <B><a href="#_f_putc">f_putc</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1777 -->

<HR />
<a name="_f_getline"></a>
<P><font face=Arial size=+1 color=#808080><B>f_getline</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_getline </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Get line from stream.</I></P>
<P>Read and return new line from input <i>Stream</i>.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1753 -->

<HR />
<a name="_f_ident"></a>
<P><font face=Arial size=+1 color=#808080><B>f_ident</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>f_ident </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Identity.</I></P>
<P>Identity functor (for any argument <i>V</i> returns <i>V</i> as is).</P>
<P></P>
<!-- ../src/E_Func.cpp:712 -->

<HR />
<a name="_f_in"></a>
<P><font face=Arial size=+1 color=#808080><B>f_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>f_in </B> () &#8658; <b><a href="AWL_Types.htm#_Stream">Stream</a></b>.</LI>
<P><I>Standard input.</I></P>
<P>Returns default input stream.</P>
<P><I>See also: </I>[ <B><a href="#_f_out">f_out</a></B> | <B><a href="#_f_err">f_err</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1686 -->

<HR />
<a name="_f_is_console"></a>
<P><font face=Arial size=+1 color=#808080><B>f_is_console</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>f_is_console </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for console device.</I></P>
<P>Return true, if <i>Stream</i> is console device.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1840 -->

<HR />
<a name="_f_mkdir"></a>
<P><font face=Arial size=+1 color=#808080><B>f_mkdir</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_mkdir </B> (<i>DirName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Create new directory.</I></P>
<P>Create new directory <i>DirName</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:669 -->

<HR />
<a name="_f_not"></a>
<P><font face=Arial size=+1 color=#808080><B>f_not</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>f_not </B> (<i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Functional "NOT" predicate composition.</I></P>
<P>For predicates <i>Pred</i>, results in predicate, evaluating to conditional NOT of <i>Pred</i>.<br>( <b>f_not</b> (<i>Pred</i>) ! (<i>Arg</i>) == <b>c_not</b> (<i>Pred1</i> ! <i>Arg</i>) ).</P>
<P><I>See also: </I>[ <B><a href="#_f_and">f_and</a></B> | <B><a href="#_f_or">f_or</a></B> ]</P>
<!-- ../src/E_Func.cpp:729 -->

<HR />
<a name="_f_open"></a>
<P><font face=Arial size=+1 color=#808080><B>f_open</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>f_open </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b> [, <i>AccessMode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Stream">Stream</a></b>.</LI>
<P><I>Open file as stream.</I></P>
<P>Opens system file <i>FileName</i> with <i>AccessMode</i> (as for C "open" library func).<br>Defaults <i>AccessMode</i> to O_RDONLY|O_BINARY.<br>Returns new stream or <b>undef</b>, if open failed.</P>
<P><I>See also: </I>[ <B><a href="#_f_create">f_create</a></B> | <B><a href="#_f_close">f_close</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1728 -->

<HR />
<a name="_f_or"></a>
<P><font face=Arial size=+1 color=#808080><B>f_or</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Func">Func</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Composer">Composer</a></b> ]</LI>
<LI type=disc><B>f_or </B> (<i>Pred1</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>Pred2</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Func">Func</a></b>.</LI>
<P><I>Functional "OR" predicates composition.</I></P>
<P>For predicates <i>Pred1</i> and <i>Pred2</i>, results in predicate, evaluating to conditional OR of <i>Pred1</i> and <i>Pred2</i>.<br>( <b>f_or</b> (<i>Pred1</i>, <i>Pred2</i>) ! (<i>Arg</i>) == <b>c_or</b> (<i>Pred1</i> ! <i>Arg</i>, <i>Pred2</i> ! <i>Arg</i>) ).</P>
<P><I>See also: </I>[ <B><a href="#_f_not">f_not</a></B> | <B><a href="#_f_and">f_and</a></B> ]</P>
<!-- ../src/E_Func.cpp:743 -->

<HR />
<a name="_f_out"></a>
<P><font face=Arial size=+1 color=#808080><B>f_out</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>f_out </B> () &#8658; <b><a href="AWL_Types.htm#_Stream">Stream</a></b>.</LI>
<P><I>Standard output.</I></P>
<P>Returns default output stream.</P>
<P><I>See also: </I>[ <B><a href="#_f_in">f_in</a></B> | <B><a href="#_f_err">f_err</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1691 -->

<HR />
<a name="_f_put"></a>
<P><font face=Arial size=+1 color=#808080><B>f_put</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_put </B> ([<i>Out</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>], { <i>Value</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>,  } ...) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Put value(s) to stream (as strings).</I></P>
<P>Evaluates and writes values from list of <i>Value</i><br>to the output stream <i>Out</i> (or default output, if <i>Out</i> is undefined).<br>Returns: number of values successfully written.</P>
<P><I>See also: </I>[ <B><a href="#_f_get">f_get</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1717 -->

<HR />
<a name="_f_putc"></a>
<P><font face=Arial size=+1 color=#808080><B>f_putc</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_putc </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Put character to stream.</I></P>
<P>Writes character with <i>Code</i> to output stream <i>Stream</i>.<br>Returns <i>Code</i>.</P>
<P><I>See also: </I>[ <B><a href="#_f_getc">f_getc</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1782 -->

<HR />
<a name="_f_putline"></a>
<P><font face=Arial size=+1 color=#808080><B>f_putline</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_putline </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>String</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Put string to stream.</I></P>
<P>Output <i>String</i> to output <i>Stream</i>.<br>Returns <i>String</i>.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1760 -->

<HR />
<a name="_f_read"></a>
<P><font face=Arial size=+1 color=#808080><B>f_read</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_read </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>Count</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Read string from stream.</I></P>
<P>Reads exactly <i>Count</i> characters (including EOLs) from input <i>Stream</i> (returning string result).</P>
<P></P>
<!-- ../src/E_Stream.cpp:1768 -->

<HR />
<a name="_f_remove"></a>
<P><font face=Arial size=+1 color=#808080><B>f_remove</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_remove </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Remove file permanently.</I></P>
<P>Remove file <i>FileName</i> from file system.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:645 -->

<HR />
<a name="_f_rename"></a>
<P><font face=Arial size=+1 color=#808080><B>f_rename</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_rename </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>NewName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Rename or move file.</I></P>
<P>Rename (or move) file <i>FileName</i> to <i>NewName</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:653 -->

<HR />
<a name="_f_rmdir"></a>
<P><font face=Arial size=+1 color=#808080><B>f_rmdir</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_rmdir </B> (<i>DirName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Remove old directory.</I></P>
<P>Remove existing directory <i>DirName</i>.<br>Returns system error status (ERRNO).</P>
<P></P>
<!-- ../src/E_System.cpp:677 -->

<HR />
<a name="_f_seek"></a>
<P><font face=Arial size=+1 color=#808080><B>f_seek</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_seek </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>Position</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Seek absolutely in stream.</I></P>
<P>Seek in seekable stream <i>Stream</i> to <i>Position</i>, relative to start (if >=0) or to end (if < 0).<br>Returns new stream position.</P>
<P><I>See also: </I>[ <B><a href="#_f_tell">f_tell</a></B> | <B><a href="#_f_skip">f_skip</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1800 -->

<HR />
<a name="_f_set_length"></a>
<P><font face=Arial size=+1 color=#808080><B>f_set_length</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_set_length </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>Length</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Set stream file length.</I></P>
<P>Set new length of file for <i>Stream</i> to <i>Length</i> (expanding or truncating file).</P>
<P></P>
<!-- ../src/E_Stream.cpp:1854 -->

<HR />
<a name="_f_skip"></a>
<P><font face=Arial size=+1 color=#808080><B>f_skip</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_skip </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, <i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Seek relatively in stream.</I></P>
<P>Seek in seekable stream <i>Stream</i> relative by <i>Offset</i> (either positive or negative).<br>Returns new stream position.</P>
<P><I>See also: </I>[ <B><a href="#_f_tell">f_tell</a></B> | <B><a href="#_f_seek">f_seek</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1808 -->

<HR />
<a name="_f_stat"></a>
<P><font face=Arial size=+1 color=#808080><B>f_stat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>f_stat </B> (<i>FileName</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Get file information.</I></P>
<P>Returns filesystem information about file <i>FileName</i>.<br>Result is: (Device: Int, Inode: Int, Mode: Int, Links: Int, UID: Int, GID: Int, Size: Int, ATime: Int, MTime: Int, CTime: Int)</P>
<P></P>
<!-- ../src/E_System.cpp:708 -->

<HR />
<a name="_f_sync"></a>
<P><font face=Arial size=+1 color=#808080><B>f_sync</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_sync </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Sync stream.</I></P>
<P>Sync stream <i>Stream</i>, flushing and/or discarding I/O buffers.</P>
<P><I>See also: </I>[ <B><a href="#_f_bufmode">f_bufmode</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1818 -->

<HR />
<a name="_f_tell"></a>
<P><font face=Arial size=+1 color=#808080><B>f_tell</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> ]</LI>
<LI type=disc><B>f_tell </B> (<i>Stream</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Tell current position in stream.</I></P>
<P>Returns current pointer position in seekable stream <i>Stream</i>.</P>
<P><I>See also: </I>[ <B><a href="#_f_seek">f_seek</a></B> | <B><a href="#_f_skip">f_skip</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1793 -->

<HR />
<a name="_false"></a>
<P><font face=Arial size=+1 color=#808080><B>false</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> ]</LI>
<LI type=disc><B>false </B> () &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Literal false value.</I></P>
<P>Returns <b>false</b> value (always 0).</P>
<P><I>See also: </I>[ <B><a href="#_true">true</a></B> ]</P>
<!-- ../src/E_Control.cpp:346 -->

<HR />
<a name="_float"></a>
<P><font face=Arial size=+1 color=#808080><B>float</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Coercion">Coercion</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>float </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Coerce scalar to float.</I></P>
<P>Explicit float coercion: from scalar <i>V</i> to float value (according to default coercion rules).</P>
<P><I>See also: </I>[ <B><a href="#_int">int</a></B> | <B><a href="#_num">num</a></B> ]</P>
<!-- ../src/E_Num.cpp:1237 -->

<HR />
<a name="_floor"></a>
<P><font face=Arial size=+1 color=#808080><B>floor</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>floor </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric rounding down.</I></P>
<P>Arithmetic "floor" value: round <i>X</i> down to nearest integer.</P>
<P><I>See also: </I>[ <B><a href="#_ceil">ceil</a></B> ]</P>
<!-- ../src/E_Num.cpp:821 -->

<HR />
<a name="_for_dec"></a>
<P><font face=Arial size=+1 color=#808080><B>for_dec</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Ternary">Ternary</a></b> ]</LI>
<LI type=disc><B>for_dec </B> (<i>Index</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Decremental range iterator.</I></P>
<P>Decrements value of mutable <i>Index</i>, starting from (excluding) end of range <i>R</i> down to (including) start of range <i>R</i>, evaluating <i>Body</i> for each value of <i>Index</i>.<br>Returns final value of <i>Body</i> (or <b>undef</b>, if <i>Body</i> never was evaluated).</P>
<P><I>See also: </I>[ <B><a href="#_for_inc">for_inc</a></B> | <B><a href="#_times">times</a></B> | <B><a href="#_ever">ever</a></B> ]</P>
<!-- ../src/E_Control.cpp:455 -->

<HR />
<a name="_for_inc"></a>
<P><font face=Arial size=+1 color=#808080><B>for_inc</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Ternary">Ternary</a></b> ]</LI>
<LI type=disc><B>for_inc </B> (<i>Index</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Incremental range iterator.</I></P>
<P>Increments value of mutable <i>Index</i>, starting from (including) start of range <i>R</i> up to (excluding) end of range <i>R</i>, evaluating <i>Body</i> for each value of <i>Index</i>.<br>Returns final value of <i>Body</i> (or <b>undef</b>, if <i>Body</i> never was evaluated).</P>
<P><I>See also: </I>[ <B><a href="#_for_dec">for_dec</a></B> | <B><a href="#_times">times</a></B> | <B><a href="#_ever">ever</a></B> ]</P>
<!-- ../src/E_Control.cpp:447 -->

<HR /><a name="_71"></a>
<P><font size=+1 color=red>= <B>G</B> =</font></P>
<HR />
<a name="_ge"></a>
<P><font face=Arial size=+1 color=#808080><B>ge</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>ge </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric "greater than or equal" compare.</I></P>
<P>Arithmetic "greater than/equal" test: true, if <i>A</i> >= <i>B</i>.<br>Syntax: <i>A</i> >= <i>B</i> or <i>A</i> ~< <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_lt">lt</a></B> | <B><a href="#_le">le</a></B> | <B><a href="#_gt">gt</a></B> | <B><a href="#_eq">eq</a></B> | <B><a href="#_ne">ne</a></B> ]</P>
<!-- ../src/E_Num.cpp:1115 -->

<HR />
<a name="_get_curdir"></a>
<P><font face=Arial size=+1 color=#808080><B>get_curdir</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>get_curdir </B> () &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Get current directory.</I></P>
<P>Get and return current working directory.</P>
<P></P>
<!-- ../src/E_System.cpp:693 -->

<HR />
<a name="_gt"></a>
<P><font face=Arial size=+1 color=#808080><B>gt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>gt </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric "greater than" compare.</I></P>
<P>Arithmetic "greater than" test: true, if <i>A</i> > <i>B</i>.<br>Syntax: <i>A</i> > <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_lt">lt</a></B> | <B><a href="#_le">le</a></B> | <B><a href="#_ge">ge</a></B> | <B><a href="#_eq">eq</a></B> | <B><a href="#_ne">ne</a></B> ]</P>
<!-- ../src/E_Num.cpp:1109 -->

<HR /><a name="_72"></a>
<P><font size=+1 color=red>= <B>H</B> =</font></P>
<HR />
<a name="_h_clear"></a>
<P><font face=Arial size=+1 color=#808080><B>h_clear</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>h_clear </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Clear hash.</I></P>
<P>Clears hash <i>Hash</i>, removing all elements from it.<br>Returns number of elements, which were present in hash.</P>
<P></P>
<!-- ../src/E_Hash.cpp:851 -->

<HR />
<a name="_h_count"></a>
<P><font face=Arial size=+1 color=#808080><B>h_count</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>h_count </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Hash counter.</I></P>
<P>Returns total number of key/value pairs in hash <i>Hash</i>.</P>
<P></P>
<!-- ../src/E_Hash.cpp:844 -->

<HR />
<a name="_h_elem"></a>
<P><font face=Arial size=+1 color=#808080><B>h_elem</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>h_elem </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Key</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>Hash value accessor.</I></P>
<P>Returns mutable reference to value associated with <i>Key</i> in hash <i>Hash</i>.<br>(If <i>Key</i> was not in <i>Hash</i>, it is created with undefined initial value.)<br>Syntax: <i>Hash</i>-><i>Key</i>.</P>
<P><I>See also: </I>[ <B><a href="#_h_lookup">h_lookup</a></B> | <B><a href="#_h_remove">h_remove</a></B> ]</P>
<!-- ../src/E_Hash.cpp:819 -->

<HR />
<a name="_h_exists"></a>
<P><font face=Arial size=+1 color=#808080><B>h_exists</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>h_exists </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Key</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check key for presence in hash.</I></P>
<P>Returns <b>true</b>, if <i>Key</i> present in hash <i>Hash</i>; <b>false</b> otherwise.</P>
<P></P>
<!-- ../src/E_Hash.cpp:915 -->

<HR />
<a name="_h_inspect"></a>
<P><font face=Arial size=+1 color=#808080><B>h_inspect</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>h_inspect </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Inspect hash internal allocation.</I></P>
<P>Returns list of internal bucket capacities in hash <i>Hash</i>.</P>
<P></P>
<!-- ../src/E_Hash.cpp:908 -->

<HR />
<a name="_h_keys"></a>
<P><font face=Arial size=+1 color=#808080><B>h_keys</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>h_keys </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List of hash keys.</I></P>
<P>Return open list of all keys in <i>Hash</i>, in no predictable (but same, as in <b>h_values</b>) order.</P>
<P><I>See also: </I>[ <B><a href="#_h_values">h_values</a></B> | <B><a href="#_h_save">h_save</a></B> | <B><a href="#_h_load">h_load</a></B> ]</P>
<!-- ../src/E_Hash.cpp:873 -->

<HR />
<a name="_h_load"></a>
<P><font face=Arial size=+1 color=#808080><B>h_load</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>h_load </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, (<i>Key1</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>Value1</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>), (<i>Key2</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>Value2</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>), ... (<i>KeyN</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>ValueN</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>),  ) &#8658; <b><a href="AWL_Types.htm#_Hash">Hash</a></b>.</LI>
<P><I>Load hash with list of elements.</I></P>
<P>Loads N pairs of (<i>Key</i>, <i>Value</i>) into hash <i>Hash</i>.<br>Returns <i>Hash</i>.</P>
<P><I>See also: </I>[ <B><a href="#_h_keys">h_keys</a></B> | <B><a href="#_h_values">h_values</a></B> | <B><a href="#_h_save">h_save</a></B> ]</P>
<!-- ../src/E_Hash.cpp:892 -->

<HR />
<a name="_h_lookup"></a>
<P><font face=Arial size=+1 color=#808080><B>h_lookup</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>h_lookup </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Key</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Hash value lookup.</I></P>
<P>Returns value associated with <i>Key</i> in hash <i>Hash</i>.<br>(If <i>Key</i> is not in <i>Hash</i> returns <b>undef</b>; new key is NOT created).</P>
<P><I>See also: </I>[ <B><a href="#_h_elem">h_elem</a></B> | <B><a href="#_h_remove">h_remove</a></B> ]</P>
<!-- ../src/E_Hash.cpp:828 -->

<HR />
<a name="_h_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>h_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>h_loop </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Hash iterator.</I></P>
<P>Iterates through hash <i>Hash</i>.<br>For each element of hash, list of (key, value) is assigned to mutable <i>Var</i>, then <i>Body</i> is evaluated.<br>(Keys/values order is unpredictable.)<br>Returns result of final evaluation of <i>Body</i>.</P>
<P></P>
<!-- ../src/E_Hash.cpp:861 -->

<HR />
<a name="_h_rehash"></a>
<P><font face=Arial size=+1 color=#808080><B>h_rehash</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>h_rehash </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Capacity</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Change hash capacity.</I></P>
<P>Explicitly change capacity of hash <i>Hash</i> to <i>Capacity</i> (preserving current hash contents).<br>Returns: current number of hash entries.</P>
<P><I>See also: </I>[ <B><a href="#_hash">hash</a></B> ]</P>
<!-- ../src/E_Hash.cpp:900 -->

<HR />
<a name="_h_remove"></a>
<P><font face=Arial size=+1 color=#808080><B>h_remove</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>h_remove </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>, <i>Key</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Hash value remove.</I></P>
<P>Removes value associated with <i>Key</i> from hash <i>Hash</i>.<br>(Returns removed value; or <b>undef</b>, if there was no value with <i>Key</i>.)</P>
<P><I>See also: </I>[ <B><a href="#_h_elem">h_elem</a></B> | <B><a href="#_h_lookup">h_lookup</a></B> ]</P>
<!-- ../src/E_Hash.cpp:836 -->

<HR />
<a name="_h_save"></a>
<P><font face=Arial size=+1 color=#808080><B>h_save</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>h_save </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List of hash elements.</I></P>
<P>Return open list of all (Key, Value) pairs in <i>Hash</i>, in no predictable (but same, as in <b>h_keys</b> and <b>h_values</b>) order.</P>
<P><I>See also: </I>[ <B><a href="#_h_keys">h_keys</a></B> | <B><a href="#_h_values">h_values</a></B> | <B><a href="#_h_load">h_load</a></B> ]</P>
<!-- ../src/E_Hash.cpp:883 -->

<HR />
<a name="_h_values"></a>
<P><font face=Arial size=+1 color=#808080><B>h_values</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>h_values </B> (<i>Hash</i>: <b><a href="AWL_Types.htm#_Hash">Hash</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List of hash values.</I></P>
<P>Return open list of all values in <i>Hash</i>, in no predictable (but same, as in <b>h_keys</b>) order.</P>
<P><I>See also: </I>[ <B><a href="#_h_keys">h_keys</a></B> | <B><a href="#_h_save">h_save</a></B> | <B><a href="#_h_load">h_load</a></B> ]</P>
<!-- ../src/E_Hash.cpp:878 -->

<HR />
<a name="_hash"></a>
<P><font face=Arial size=+1 color=#808080><B>hash</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>hash </B> ([<i>Capacity</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Hash">Hash</a></b>.</LI>
<P><I>Hash constructor.</I></P>
<P>Creates and returns new (empty) hash (with optional initial <i>Capacity</i>).</P>
<P><I>See also: </I>[ <B><a href="#_h_rehash">h_rehash</a></B> ]</P>
<!-- ../src/E_Hash.cpp:809 -->

<HR />
<a name="_hcode"></a>
<P><font face=Arial size=+1 color=#808080><B>hcode</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>hcode </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Hash code value.</I></P>
<P>Calculate hash code of result of <i>V</i>.</P>
<P><I>See also: </I>[ <B><a href="#_ident">ident</a></B> | <B><a href="#_differ">differ</a></B> ]</P>
<!-- ../src/E_Hash.cpp:766 -->

<HR /><a name="_73"></a>
<P><font size=+1 color=red>= <B>I</B> =</font></P>
<HR />
<a name="_ident"></a>
<P><font face=Arial size=+1 color=#808080><B>ident</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>ident </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>W</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Test for identity.</I></P>
<P>Check results of <i>V</i> and <i>W</i> for structural identity: <b>true</b> (1), if both operands evaluate to same result; <b>false</b> (0) otherwise.<br>Syntax: <i>V</i> [==] <i>W</i>.</P>
<P><I>See also: </I>[ <B><a href="#_hcode">hcode</a></B> | <B><a href="#_differ">differ</a></B> ]</P>
<!-- ../src/E_Hash.cpp:773 -->

<HR />
<a name="_idiv"></a>
<P><font face=Arial size=+1 color=#808080><B>idiv</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>idiv </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer ratio.</I></P>
<P>Integer division of arguments <i>I</i> and <i>J</i>.<br>(Same as <b>int</b>(<i>I</i> / <i>J</i>); always rounding result towards 0).<br>Syntax: <i>I</i> % <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_irem">irem</a></B> | <B><a href="#_rdiv">rdiv</a></B> | <B><a href="#_rrem">rrem</a></B> ]</P>
<!-- ../src/E_Num.cpp:970 -->

<HR />
<a name="_if"></a>
<P><font face=Arial size=+1 color=#808080><B>if</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Ternary">Ternary</a></b> ]</LI>
<LI type=disc><B>if </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Then</i>: <b><a href="AWL_Types.htm#_Any1">Any1</a></b> [, @<i>Else</i>: <b><a href="AWL_Types.htm#_Any2">Any2</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Any1">Any1</a></b> | <b><a href="AWL_Types.htm#_Any2">Any2</a></b>.</LI>
<P><I>Conditional positive test.</I></P>
<P>If boolean <i>Cond</i> is <b>true</b>, evaluates and returns <i>Then</i>; otherwise evaluates and returns <i>Else</i>.</P>
<P><I>See also: </I>[ <B><a href="#_unless">unless</a></B> ]</P>
<!-- ../src/E_Control.cpp:398 -->

<HR />
<a name="_inc"></a>
<P><font face=Arial size=+1 color=#808080><B>inc</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>inc </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Pre-increment.</I></P>
<P>Increments value of mutable <i>V</i> (which must belong to numeric type) by 1.<br>Returns: value of <i>V</i> after increment.<br>Syntax: ++ <i>V</i>.</P>
<P><I>See also: </I>[ <B><a href="#_clr">clr</a></B> | <B><a href="#_dec">dec</a></B> | <B><a href="#_inc_p">inc_p</a></B> | <B><a href="#_dec_p">dec_p</a></B> ]</P>
<!-- ../src/E_Mut.cpp:604 -->

<HR />
<a name="_inc_p"></a>
<P><font face=Arial size=+1 color=#808080><B>inc_p</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>inc_p </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Post-increment.</I></P>
<P>Increments value of mutable <i>V</i> (which must belong to numeric type) by 1.<br>Returns: value of <i>V</i> before increment.<br>Syntax: <i>V</i> ++.</P>
<P><I>See also: </I>[ <B><a href="#_clr">clr</a></B> | <B><a href="#_inc">inc</a></B> | <B><a href="#_dec">dec</a></B> | <B><a href="#_dec_p">dec_p</a></B> ]</P>
<!-- ../src/E_Mut.cpp:618 -->

<HR />
<a name="_include"></a>
<P><font face=Arial size=+1 color=#808080><B>include</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_System">System</a></b> ]</LI>
<LI type=disc><B>include </B> (<i>Filename</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Include module.</I></P>
<P>Include source file <i>Filename</i> (evaluating all top-level expressions and module definitions).</P>
<P></P>
<!-- ../src/Kernel.cpp:1763 -->

<HR />
<a name="_inf_neg"></a>
<P><font face=Arial size=+1 color=#808080><B>inf_neg</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>inf_neg </B> () &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Negative infinity.</I></P>
<P>Returns negative infinite value.</P>
<P><I>See also: </I>[ <B><a href="#_inf_pos">inf_pos</a></B> | <B><a href="#_nan">nan</a></B> ]</P>
<!-- ../src/E_Num.cpp:1294 -->

<HR />
<a name="_inf_pos"></a>
<P><font face=Arial size=+1 color=#808080><B>inf_pos</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>inf_pos </B> () &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Positive infinity.</I></P>
<P>Returns positive infinite value.</P>
<P><I>See also: </I>[ <B><a href="#_inf_neg">inf_neg</a></B> | <B><a href="#_nan">nan</a></B> ]</P>
<!-- ../src/E_Num.cpp:1289 -->

<HR />
<a name="_inside"></a>
<P><font face=Arial size=+1 color=#808080><B>inside</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>inside </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for value inclusion in range.</I></P>
<P>True, if integer <i>Value</i> is inside range <i>R</i><br>(same as: <i>R</i>[0] <= <i>Value</i> && <i>Value</i> < <i>R</i>[1]).</P>
<P><I>See also: </I>[ <B><a href="#_outside">outside</a></B> ]</P>
<!-- ../src/E_Control.cpp:484 -->

<HR />
<a name="_int"></a>
<P><font face=Arial size=+1 color=#808080><B>int</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Coercion">Coercion</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>int </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Coerce scalar to integer.</I></P>
<P>Explicit integer coercion: from scalar <i>V</i> to integer value (according to default coercion rules).</P>
<P><I>See also: </I>[ <B><a href="#_float">float</a></B> | <B><a href="#_num">num</a></B> ]</P>
<!-- ../src/E_Num.cpp:1231 -->

<HR />
<a name="_irem"></a>
<P><font face=Arial size=+1 color=#808080><B>irem</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>irem </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer remainder.</I></P>
<P>Integer remainder of arguments <i>I</i> and <i>J</i>.<br>(Same as <i>I</i> - <i>J</i> * (<i>I</i> % <i>J</i>)).<br>Syntax: <i>I</i> %% <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_idiv">idiv</a></B> | <B><a href="#_rdiv">rdiv</a></B> | <B><a href="#_rrem">rrem</a></B> ]</P>
<!-- ../src/E_Num.cpp:977 -->

<HR />
<a name="_is_array"></a>
<P><font face=Arial size=+1 color=#808080><B>is_array</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Array">Array</a></b> ]</LI>
<LI type=disc><B>is_array </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for array value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to array.</P>
<P></P>
<!-- ../src/E_Array.cpp:1327 -->

<HR />
<a name="_is_block"></a>
<P><font face=Arial size=+1 color=#808080><B>is_block</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_block</B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for block.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to block.</P>
<P><I>See also: </I>[ <B><a href="#_is_var">is_var</a></B> | <B><a href="#_is_term">is_term</a></B> | <B><a href="#_is_func">is_func</a></B> ]</P>
<!-- ../src/E_Func.cpp:654 -->

<HR />
<a name="_is_class"></a>
<P><font face=Arial size=+1 color=#808080><B>is_class</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>is_class </B> (<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for class reference.</I></P>
<P>Predicate: <b>true</b>, if functor <i>F</i> is reference to any class.</P>
<P><I>See also: </I>[ <B><a href="#_is_object">is_object</a></B> | <B><a href="#_expect_object">expect_object</a></B> | <B><a href="#_is_virtual">is_virtual</a></B> ]</P>
<!-- ../src/E_Object.cpp:361 -->

<HR />
<a name="_is_float"></a>
<P><font face=Arial size=+1 color=#808080><B>is_float</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>is_float </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for float value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to float scalar.</P>
<P><I>See also: </I>[ <B><a href="#_is_int">is_int</a></B> | <B><a href="#_is_num">is_num</a></B> ]</P>
<!-- ../src/E_Num.cpp:752 -->

<HR />
<a name="_is_func"></a>
<P><font face=Arial size=+1 color=#808080><B>is_func</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_func</B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for functor.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to functor reference.</P>
<P><I>See also: </I>[ <B><a href="#_is_var">is_var</a></B> | <B><a href="#_is_term">is_term</a></B> | <B><a href="#_is_block">is_block</a></B> ]</P>
<!-- ../src/E_Func.cpp:659 -->

<HR />
<a name="_is_hash"></a>
<P><font face=Arial size=+1 color=#808080><B>is_hash</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Hash">Hash</a></b> ]</LI>
<LI type=disc><B>is_hash </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for hash value.</I></P>
<P>Predicate: true, if argument <i>V</i> evaluates to hash.</P>
<P><I>See also: </I>[ <B><a href="#_expect_hash">expect_hash</a></B> ]</P>
<!-- ../src/E_Hash.cpp:792 -->

<HR />
<a name="_is_int"></a>
<P><font face=Arial size=+1 color=#808080><B>is_int</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>is_int </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for integer value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to integer scalar.</P>
<P><I>See also: </I>[ <B><a href="#_is_float">is_float</a></B> | <B><a href="#_is_num">is_num</a></B> ]</P>
<!-- ../src/E_Num.cpp:747 -->

<HR />
<a name="_is_list"></a>
<P><font face=Arial size=+1 color=#808080><B>is_list</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>is_list </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for list.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to list.</P>
<P></P>
<!-- ../src/E_List.cpp:1135 -->

<HR />
<a name="_is_mut"></a>
<P><font face=Arial size=+1 color=#808080><B>is_mut</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_mut </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check mutability.</I></P>
<P>Return <b>true</b>, if <i>V</i> evaluates to mutable result.</P>
<P></P>
<!-- ../src/E_Mut.cpp:550 -->

<HR />
<a name="_is_num"></a>
<P><font face=Arial size=+1 color=#808080><B>is_num</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>is_num </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for numeric value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to numeric (int or float) scalar.</P>
<P><I>See also: </I>[ <B><a href="#_is_int">is_int</a></B> | <B><a href="#_is_float">is_float</a></B> ]</P>
<!-- ../src/E_Num.cpp:757 -->

<HR />
<a name="_is_object"></a>
<P><font face=Arial size=+1 color=#808080><B>is_object</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>is_object </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for object value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to instance of any class.</P>
<P><I>See also: </I>[ <B><a href="#_expect_object">expect_object</a></B> | <B><a href="#_is_class">is_class</a></B> | <B><a href="#_is_virtual">is_virtual</a></B> ]</P>
<!-- ../src/E_Object.cpp:346 -->

<HR />
<a name="_is_pattern"></a>
<P><font face=Arial size=+1 color=#808080><B>is_pattern</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>is_pattern </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for pattern value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to pattern.</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2322 -->

<HR />
<a name="_is_stream"></a>
<P><font face=Arial size=+1 color=#808080><B>is_stream</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_stream </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for stream.</I></P>
<P>Predicate: <b>true</b>, if <i>V</i> evaluates to stream.</P>
<P></P>
<!-- ../src/E_Stream.cpp:1677 -->

<HR />
<a name="_is_string"></a>
<P><font face=Arial size=+1 color=#808080><B>is_string</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>is_string </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for string value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to string scalar.</P>
<P><I>See also: </I>[ <B><a href="#_expect_string">expect_string</a></B> ]</P>
<!-- ../src/E_String.cpp:2274 -->

<HR />
<a name="_is_term"></a>
<P><font face=Arial size=+1 color=#808080><B>is_term</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_term</B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for term.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to term.</P>
<P><I>See also: </I>[ <B><a href="#_is_var">is_var</a></B> | <B><a href="#_is_block">is_block</a></B> | <B><a href="#_is_func">is_func</a></B> ]</P>
<!-- ../src/E_Func.cpp:649 -->

<HR />
<a name="_is_undef"></a>
<P><font face=Arial size=+1 color=#808080><B>is_undef</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_undef </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for undefined value.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to <b>undef</b>.</P>
<P></P>
<!-- ../src/E_List.cpp:1130 -->

<HR />
<a name="_is_var"></a>
<P><font face=Arial size=+1 color=#808080><B>is_var</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>is_var</B> (<i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for variable.</I></P>
<P>Predicate: <b>true</b>, if argument <i>V</i> evaluates to variable.</P>
<P><I>See also: </I>[ <B><a href="#_is_term">is_term</a></B> | <B><a href="#_is_block">is_block</a></B> | <B><a href="#_is_func">is_func</a></B> ]</P>
<!-- ../src/E_Func.cpp:644 -->

<HR />
<a name="_is_virtual"></a>
<P><font face=Arial size=+1 color=#808080><B>is_virtual</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>is_virtual </B> (<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for virtual reference.</I></P>
<P>Predicate: <b>true</b>, if functor <i>F</i> is reference to virtual of any class.</P>
<P><I>See also: </I>[ <B><a href="#_is_object">is_object</a></B> | <B><a href="#_expect_object">expect_object</a></B> | <B><a href="#_is_class">is_class</a></B> ]</P>
<!-- ../src/E_Object.cpp:368 -->

<HR /><a name="_76"></a>
<P><font size=+1 color=red>= <B>L</B> =</font></P>
<HR />
<a name="_l_cat"></a>
<P><font face=Arial size=+1 color=#808080><B>l_cat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_cat </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, <i>M</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List concatenation.</I></P>
<P>Returns concatenation of <i>L</i> and <i>M</i>, evaluated as lists.<br>(Returns copy of <i>L</i>, if <i>M</i> is <b>undef</b>; returns <i>M</i>, if <i>L</i> is <b>undef</b>.)<br>(If <i>M</i> is open list, result is open too.)<br>Syntax: <i>L</i> [+] <i>M</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_copy">l_copy</a></B> | <B><a href="#_l_rep">l_rep</a></B> | <B><a href="#_l_rev">l_rev</a></B> ]</P>
<!-- ../src/E_List.cpp:1178 -->

<HR />
<a name="_l_cmp"></a>
<P><font face=Arial size=+1 color=#808080><B>l_cmp</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_cmp </B> (<i>Compare</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, <i>M</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Compare lists of ordered elements.</I></P>
<P>Compares lists <i>L</i> and <i>M</i>, applying <i>Compare</i> to each pair of elements from <i>L</i> and <i>M</i>.<br>Returns result of first non-zero comparison (or 0, if all elements compare to 0).</P>
<P></P>
<!-- ../src/E_List.cpp:1406 -->

<HR />
<a name="_l_copy"></a>
<P><font face=Arial size=+1 color=#808080><B>l_copy</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_copy </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List copying.</I></P>
<P>Returns exact copy of list <i>L</i> (copying all list elements, including nested lists).</P>
<P><I>See also: </I>[ <B><a href="#_l_cat">l_cat</a></B> | <B><a href="#_l_rep">l_rep</a></B> | <B><a href="#_l_rev">l_rev</a></B> ]</P>
<!-- ../src/E_List.cpp:1171 -->

<HR />
<a name="_l_count_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>l_count_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_count_ex </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Count list items exclusively.</I></P>
<P>Returns total count of elements of <i>List</i>, for which application of <i>Predicate</i> evaluates to <b>false</b>.</P>
<P><I>See also: </I>[ <B><a href="#_l_count_in">l_count_in</a></B> ]</P>
<!-- ../src/E_List.cpp:1386 -->

<HR />
<a name="_l_count_in"></a>
<P><font face=Arial size=+1 color=#808080><B>l_count_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_count_in </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Count list items inclusively.</I></P>
<P>Returns total count of elements of <i>List</i>, for which application of <i>Predicate</i> evaluates to <b>true</b>.</P>
<P><I>See also: </I>[ <B><a href="#_l_count_ex">l_count_ex</a></B> ]</P>
<!-- ../src/E_List.cpp:1381 -->

<HR />
<a name="_l_filter_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>l_filter_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_filter_ex </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Filter list exclusively.</I></P>
<P>Creates and returns new list, containing all elements of <i>List</i>, for which application of <i>Predicate</i> evaluates to <b>false</b>.</P>
<P><I>See also: </I>[ <B><a href="#_l_filter_in">l_filter_in</a></B> ]</P>
<!-- ../src/E_List.cpp:1371 -->

<HR />
<a name="_l_filter_in"></a>
<P><font face=Arial size=+1 color=#808080><B>l_filter_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_filter_in </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Filter list inclusively.</I></P>
<P>Creates and returns new list, containing all elements of <i>List</i>, for which application of <i>Predicate</i> evaluates to <b>true</b>.</P>
<P><I>See also: </I>[ <B><a href="#_l_filter_ex">l_filter_ex</a></B> ]</P>
<!-- ../src/E_List.cpp:1366 -->

<HR />
<a name="_l_head"></a>
<P><font face=Arial size=+1 color=#808080><B>l_head</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>l_head </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>List head accessor.</I></P>
<P>Returns mutable reference to head (first item) of list <i>L</i>.<br>(Equivalent to <b>l_item</b> (0, <i>L</i>)).</P>
<P><I>See also: </I>[ <B><a href="#_l_tail">l_tail</a></B> | <B><a href="#_l_head_by">l_head_by</a></B> | <B><a href="#_l_tail_by">l_tail_by</a></B> ]</P>
<!-- ../src/E_List.cpp:1218 -->

<HR />
<a name="_l_head_by"></a>
<P><font face=Arial size=+1 color=#808080><B>l_head_by</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>l_head_by </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>Head of list, with offset.</I></P>
<P>Equivalent of <b>l_head</b>(L) applied <i>N</i> times.<br>(Returns <i>L</i>, if <i>N</i> == 0; equivalent to <b>l_head</b>(L), if <i>N</i> == 1.)</P>
<P><I>See also: </I>[ <B><a href="#_l_head">l_head</a></B> | <B><a href="#_l_tail">l_tail</a></B> | <B><a href="#_l_tail_by">l_tail_by</a></B> ]</P>
<!-- ../src/E_List.cpp:1232 -->

<HR />
<a name="_l_item"></a>
<P><font face=Arial size=+1 color=#808080><B>l_item</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>l_item </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>List element accessor.</I></P>
<P>Returns mutable reference to item <i>I</i> (starting at 0) of <i>L</i>, evaluated as list.<br>Syntax: <i>L</i> [<i>I</i>].</P>
<P></P>
<!-- ../src/E_List.cpp:1208 -->

<HR />
<a name="_l_len"></a>
<P><font face=Arial size=+1 color=#808080><B>l_len</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_len </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Length of list.</I></P>
<P>Returns length of list <i>L</i> (total # of list items).<br>(Returns 1 for atomic values and 0 for <b>undef</b>.)<br>Syntax: #<i>L</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_ref">l_ref</a></B> ]</P>
<!-- ../src/E_List.cpp:1153 -->

<HR />
<a name="_l_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>l_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>l_loop </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Direct order list iterator.</I></P>
<P>Evaluates <i>Body</i> for all items in list <i>L</i> (from first to last).<br>On each iteration, reference to current list item is assigned to mutable <i>V</i>.<br>Returns result of last evaluation of <i>Body</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_loop_r">l_loop_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1278 -->

<HR />
<a name="_l_loop_r"></a>
<P><font face=Arial size=+1 color=#808080><B>l_loop_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>l_loop_r </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Reverse order list iterator.</I></P>
<P>Evaluates <i>Body</i> for all items in list <i>L</i> (from last to first).<br>On each iteration, reference to current list item is assigned to mutable <i>V</i>.<br>Returns result of last evaluation of <i>Body</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_loop">l_loop</a></B> ]</P>
<!-- ../src/E_List.cpp:1285 -->

<HR />
<a name="_l_map"></a>
<P><font face=Arial size=+1 color=#808080><B>l_map</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_map </B> (<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Functional list mapping.</I></P>
<P>Returns new list, constructed by applying functor <i>F</i> to all elements of list <i>L</i>.<br>Note: <b>l_map</b> maps open lists to open lists.</P>
<P></P>
<!-- ../src/E_List.cpp:1320 -->

<HR />
<a name="_l_pop"></a>
<P><font face=Arial size=+1 color=#808080><B>l_pop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>l_pop </B> (<i>L</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Pop elements from list.</I></P>
<P>Removes (in direct order) elements from list <i>L</i> into list of mutables <i>V</i>.<br>Returns: new value of <i>L</i>.<br>Syntax: <i>L</i> [->] <i>V</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_push">l_push</a></B> | <B><a href="#_l_split">l_split</a></B> ]</P>
<!-- ../src/E_List.cpp:1266 -->

<HR />
<a name="_l_push"></a>
<P><font face=Arial size=+1 color=#808080><B>l_push</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>l_push </B> (<i>L</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>V</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Push elements to list.</I></P>
<P>Evaluates elements of list <i>V</i>, and inserts them (in reverse order) into list <i>L</i>.<br>Returns: new value of <i>L</i>.<br>Syntax: <i>L</i> [<-] <i>V</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_pop">l_pop</a></B> | <B><a href="#_l_split">l_split</a></B> ]</P>
<!-- ../src/E_List.cpp:1259 -->

<HR />
<a name="_l_range"></a>
<P><font face=Arial size=+1 color=#808080><B>l_range</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_range </B> (<i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, [<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>]) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Convert range to incremental list.</I></P>
<P>Constructs and returns new list, containing all integers from range <i>R</i>, in ascending order from first to last.<br>If optional functor <i>F</i> is specified, it is applied to elements of resulting list.</P>
<P><I>See also: </I>[ <B><a href="#_l_range_r">l_range_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1297 -->

<HR />
<a name="_l_range_r"></a>
<P><font face=Arial size=+1 color=#808080><B>l_range_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_range_r </B> (<i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, [<i>F</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>]) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Convert range to decremental list.</I></P>
<P>Constructs and returns new list, containing all integers from range <i>R</i>, in descending order from last to first.<br>If optional functor <i>F</i> is specified, it is applied to elements of resulting list.</P>
<P><I>See also: </I>[ <B><a href="#_l_range">l_range</a></B> ]</P>
<!-- ../src/E_List.cpp:1303 -->

<HR />
<a name="_l_ref"></a>
<P><font face=Arial size=+1 color=#808080><B>l_ref</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_ref </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List reference.</I></P>
<P>Return reference to <i>L</i> (evaluated as list).</P>
<P><I>See also: </I>[ <B><a href="#_l_len">l_len</a></B> ]</P>
<!-- ../src/E_List.cpp:1162 -->

<HR />
<a name="_l_rep"></a>
<P><font face=Arial size=+1 color=#808080><B>l_rep</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_rep </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List replication.</I></P>
<P>Returns replication of <i>L</i> (evaluated as list) N times in succession.<br>(Returns <b>undef</b>, if <i>N</i> <= 0; returns <i>L</i> , if <i>N</i> == 1.)<br>(If <i>L</i> is open list, result is open too.)<br>Syntax: <i>L</i> [*] <i>N</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_copy">l_copy</a></B> | <B><a href="#_l_cat">l_cat</a></B> | <B><a href="#_l_rev">l_rev</a></B> ]</P>
<!-- ../src/E_List.cpp:1188 -->

<HR />
<a name="_l_resize"></a>
<P><font face=Arial size=+1 color=#808080><B>l_resize</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>l_resize </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, <i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Resize list.</I></P>
<P>Shrink or expand list <i>L</i> to length <i>N</i>.</P>
<P></P>
<!-- ../src/E_List.cpp:1423 -->

<HR />
<a name="_l_rev"></a>
<P><font face=Arial size=+1 color=#808080><B>l_rev</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_rev </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>List reversion.</I></P>
<P>Returns reversion, from last item to first, of <i>L</i>, evaluated as list.<br>Syntax: [~] <i>L</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_copy">l_copy</a></B> | <B><a href="#_l_cat">l_cat</a></B> | <B><a href="#_l_rep">l_rep</a></B> ]</P>
<!-- ../src/E_List.cpp:1198 -->

<HR />
<a name="_l_sort_index"></a>
<P><font face=Arial size=+1 color=#808080><B>l_sort_index</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_sort_index </B> (<i>Comp</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Build sorted index.</I></P>
<P>Sort range <i>R</i>, using comparator <i>Comp</i> to compare pairs of indexes, belonging to <i>R</i>.<br>Returns list of indexes, ordered according to <i>Comp</i>.</P>
<P></P>
<!-- ../src/E_List.cpp:1396 -->

<HR />
<a name="_l_sort_mutator"></a>
<P><font face=Arial size=+1 color=#808080><B>l_sort_mutator</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>l_sort_mutator </B> (<i>Count</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Accessor</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>Comparator</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; ().</LI>
<P><I>Sorting in place.</I></P>
<P>Sort any set of <i>Count</i> mutables (with access provided by <i>Accessor</i>, and comparisons done by <i>Comparator</i>).</P>
<P></P>
<!-- ../src/E_List.cpp:1430 -->

<HR />
<a name="_l_split"></a>
<P><font face=Arial size=+1 color=#808080><B>l_split</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>l_split </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Split list at specified position.</I></P>
<P>Split list <i>L</i> in two parts at position <i>N</i> (modifying <i>L</i>).<br>For new value of <i>L</i>: <b>l_head</b>(L) [+] <b>l_tail</b>(L) [==] L; <b>l_len</b>(<b>l_head</b>(L)) == N+1.<br>Returns: new value of <i>L</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_push">l_push</a></B> | <B><a href="#_l_pop">l_pop</a></B> ]</P>
<!-- ../src/E_List.cpp:1249 -->

<HR />
<a name="_l_tail"></a>
<P><font face=Arial size=+1 color=#808080><B>l_tail</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>l_tail </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>List tail accessor.</I></P>
<P>Returns mutable reference to tail (all items except first) of list <i>L</i>.</P>
<P><I>See also: </I>[ <B><a href="#_l_head">l_head</a></B> | <B><a href="#_l_head_by">l_head_by</a></B> | <B><a href="#_l_tail_by">l_tail_by</a></B> ]</P>
<!-- ../src/E_List.cpp:1224 -->

<HR />
<a name="_l_tail_by"></a>
<P><font face=Arial size=+1 color=#808080><B>l_tail_by</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>l_tail_by </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>Tail of list, with offset.</I></P>
<P>Equivalent of <b>l_tail</b>(L) applied <i>N</i> times.<br>(Returns <i>L</i>, if <i>N</i> == 0; equivalent to <b>l_tail</b>(L), if <i>N</i> == 1.)</P>
<P><I>See also: </I>[ <B><a href="#_l_head">l_head</a></B> | <B><a href="#_l_tail">l_tail</a></B> | <B><a href="#_l_head_by">l_head_by</a></B> ]</P>
<!-- ../src/E_List.cpp:1238 -->

<HR />
<a name="_l_until"></a>
<P><font face=Arial size=+1 color=#808080><B>l_until</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_until </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search list forward, negatively testing predicate.</I></P>
<P>Scans list <i>L</i> (from first element to last), applying functor <i>Predicate</i> to each element, while result remains <b>false</b>.<br>Returns: index of first element, where <i>Predicate</i> ! <i>L</i>[index] becomes <b>true</b><br>(returns 0, if condition is <b>true</b> on first element; returns length of <i>L</i>, if condition is <b>false</b> for all elements).</P>
<P><I>See also: </I>[ <B><a href="#_l_while">l_while</a></B> | <B><a href="#_l_while_r">l_while_r</a></B> | <B><a href="#_l_until_r">l_until_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1337 -->

<HR />
<a name="_l_until_r"></a>
<P><font face=Arial size=+1 color=#808080><B>l_until_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_until_r </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search list backward, negatively testing predicate.</I></P>
<P>Scans list <i>L</i> (from last element to first), applying functor <i>Predicate</i> to each element, while result remains <b>false</b>.<br>Returns: index of last element, where <i>Predicate</i> ! <i>L</i>[index] remains <b>false</b><br>(returns length of <i>L</i>, if condition is <b>true</b> on last element; returns 0, if condition is <b>false</b> for all elements).</P>
<P><I>See also: </I>[ <B><a href="#_l_while">l_while</a></B> | <B><a href="#_l_until">l_until</a></B> | <B><a href="#_l_while_r">l_while_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1354 -->

<HR />
<a name="_l_while"></a>
<P><font face=Arial size=+1 color=#808080><B>l_while</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_while </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search list forward, positively testing predicate.</I></P>
<P>Scans list <i>L</i> (from first element to last), applying functor <i>Predicate</i> to each element, while result remains <b>true</b>.<br>Returns: index of first element, where <i>Predicate</i> ! <i>L</i>[index] becomes <b>false</b><br>(returns 0, if condition is <b>false</b> on first element; returns length of <i>L</i>, if condition is <b>true</b> for all elements).</P>
<P><I>See also: </I>[ <B><a href="#_l_until">l_until</a></B> | <B><a href="#_l_while_r">l_while_r</a></B> | <B><a href="#_l_until_r">l_until_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1330 -->

<HR />
<a name="_l_while_r"></a>
<P><font face=Arial size=+1 color=#808080><B>l_while_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Func">Func</a></b> ]</LI>
<LI type=disc><B>l_while_r </B> (<i>Predicate</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search list backward, positively testing predicate.</I></P>
<P>Scans list <i>L</i> (from last element to first), applying functor <i>Predicate</i> to each element, while result remains <b>true</b>.<br>Returns: index of last element, where <i>Predicate</i> ! <i>L</i>[index] remains <b>true</b><br>(returns length of <i>L</i>, if condition is <b>false</b> on last element; returns 0, if condition is <b>true</b> for all elements).</P>
<P><I>See also: </I>[ <B><a href="#_l_while">l_while</a></B> | <B><a href="#_l_until">l_until</a></B> | <B><a href="#_l_until_r">l_until_r</a></B> ]</P>
<!-- ../src/E_List.cpp:1347 -->

<HR />
<a name="_l_zip"></a>
<P><font face=Arial size=+1 color=#808080><B>l_zip</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>l_zip </B> (<i>L</i>: <b><a href="AWL_Types.htm#_List">List</a></b>, <i>M</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Zip lists.</I></P>
<P>Returns list of combined list pairs of elements from both <i>L</i> and <i>M</i>.</P>
<P></P>
<!-- ../src/E_List.cpp:1416 -->

<HR />
<a name="_le"></a>
<P><font face=Arial size=+1 color=#808080><B>le</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>le </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric "less than or equal" compare.</I></P>
<P>Arithmetic "less than/equal" test: true, if <i>A</i> <= <i>B</i>.<br>Syntax: <i>A</i> <= <i>B</i> or <i>A</i> ~> <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_lt">lt</a></B> | <B><a href="#_gt">gt</a></B> | <B><a href="#_ge">ge</a></B> | <B><a href="#_eq">eq</a></B> | <B><a href="#_ne">ne</a></B> ]</P>
<!-- ../src/E_Num.cpp:1103 -->

<HR />
<a name="_let"></a>
<P><font face=Arial size=+1 color=#808080><B>let</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>let </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>"Lazy" assignment.</I></P>
<P>Assigns expression <i>X</i> (without evaluation) to mutable <i>V</i>.<br>Returns: <i>V</i>.<br>Syntax: <i>V</i> := <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_set">set</a></B> | <B><a href="#_swap">swap</a></B> ]</P>
<!-- ../src/E_Mut.cpp:559 -->

<HR />
<a name="_local_time"></a>
<P><font face=Arial size=+1 color=#808080><B>local_time</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>local_time </B> ([<i>Time</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Split time to local time.</I></P>
<P>Convert <i>Time</i> in Epoch seconds (defaults to current time) to locat time components.<br>Result is: (<i>Year</i>, <i>Month</i>, <i>Day</i>, <i>Hour</i>, <i>Min</i>, <i>Sec</i>, <i>Weekday</i>, <i>Yearday</i>, <i>isDST</i>).</P>
<P><I>See also: </I>[ <B><a href="#_time">time</a></B> | <B><a href="#_utc_time">utc_time</a></B> ]</P>
<!-- ../src/E_System.cpp:725 -->

<HR />
<a name="_log"></a>
<P><font face=Arial size=+1 color=#808080><B>log</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>log </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric logarithm.</I></P>
<P>Natural (base <i>e</i>) logarithm of <i>X</i> (NAN, if <i>X</i> <= 0).</P>
<P><I>See also: </I>[ <B><a href="#_exp">exp</a></B> | <B><a href="#_exp_by">exp_by</a></B> | <B><a href="#_log_by">log_by</a></B> ]</P>
<!-- ../src/E_Num.cpp:850 -->

<HR />
<a name="_log_by"></a>
<P><font face=Arial size=+1 color=#808080><B>log_by</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>log_by </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Y</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric logarithm by base.</I></P>
<P>Logarithm of <i>Y</i> base <i>X</i>.<br>(Same as: <b>log</b>(<i>Y</i>) / <b>log</b>(<i>X</i>) ).</P>
<P><I>See also: </I>[ <B><a href="#_exp">exp</a></B> | <B><a href="#_log">log</a></B> | <B><a href="#_exp_by">exp_by</a></B> ]</P>
<!-- ../src/E_Num.cpp:1062 -->

<HR />
<a name="_lt"></a>
<P><font face=Arial size=+1 color=#808080><B>lt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>lt </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric "less than" compare.</I></P>
<P>Arithmetic "less than" test: true, if <i>A</i> < <i>B</i>.<br>Syntax: <i>A</i> < <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_le">le</a></B> | <B><a href="#_gt">gt</a></B> | <B><a href="#_ge">ge</a></B> | <B><a href="#_eq">eq</a></B> | <B><a href="#_ne">ne</a></B> ]</P>
<!-- ../src/E_Num.cpp:1097 -->

<HR /><a name="_77"></a>
<P><font size=+1 color=red>= <B>M</B> =</font></P>
<HR />
<a name="_max"></a>
<P><font face=Arial size=+1 color=#808080><B>max</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>max </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric maximum.</I></P>
<P>Arithmetically greater of arguments: <i>A</i> ?> <i>B</i>.<br>(Equals to: <i>A</i> > <i>B</i> ? <i>A</i> : <i>B</i>, but evaluates arguments only once) (<b>max</b>).<br>Syntax: <i>A</i> ?> <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_min">min</a></B> ]</P>
<!-- ../src/E_Num.cpp:1014 -->

<HR />
<a name="_max_int"></a>
<P><font face=Arial size=+1 color=#808080><B>max_int</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>max_int </B> () &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer maximum.</I></P>
<P>Returns highest integer value available.</P>
<P><I>See also: </I>[ <B><a href="#_min_int">min_int</a></B> ]</P>
<!-- ../src/E_Num.cpp:1279 -->

<HR />
<a name="_min"></a>
<P><font face=Arial size=+1 color=#808080><B>min</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>min </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric minimum.</I></P>
<P>Arithmetically lesser of arguments: <i>A</i> ?< <i>B</i>.<br>(Equals to: <i>A</i> < <i>B</i> ? <i>A</i> : <i>B</i>, but evaluates arguments only once) (<b>min</b>).<br>Syntax: <i>A</i> ?< <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_max">max</a></B> ]</P>
<!-- ../src/E_Num.cpp:1007 -->

<HR />
<a name="_min_int"></a>
<P><font face=Arial size=+1 color=#808080><B>min_int</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>min_int </B> () &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer minimum.</I></P>
<P>Returns lowest integer value available.</P>
<P><I>See also: </I>[ <B><a href="#_max_int">max_int</a></B> ]</P>
<!-- ../src/E_Num.cpp:1274 -->

<HR />
<a name="_mul"></a>
<P><font face=Arial size=+1 color=#808080><B>mul</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>mul </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric multiplication.</I></P>
<P>Arithmetic product of arguments <i>A</i> and <i>B</i>.<br>Syntax: <i>A</i> * <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_div">div</a></B> ]</P>
<!-- ../src/E_Num.cpp:956 -->

<HR /><a name="_78"></a>
<P><font size=+1 color=red>= <B>N</B> =</font></P>
<HR />
<a name="_n__base"></a>
<P><font face=Arial size=+1 color=#808080><B>n__base</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>n__base </B> (<i>B</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as value by base.</I></P>
<P>Interpret string <i>S</i> as base <i>B</i> encoded integer, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_n_hex">n_hex</a></B> | <B><a href="#_n_oct">n_oct</a></B> | <B><a href="#_n_bin">n_bin</a></B> | <B><a href="#_n_dec">n_dec</a></B> ]</P>
<!-- ../src/E_String.cpp:2745 -->

<HR />
<a name="_n_bin"></a>
<P><font face=Arial size=+1 color=#808080><B>n_bin</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>n_bin </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as binary value.</I></P>
<P>Interpret string <i>S</i> as binary integer, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_n_hex">n_hex</a></B> | <B><a href="#_n_oct">n_oct</a></B> | <B><a href="#_n_dec">n_dec</a></B> | <B><a href="#_n__base">n__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2740 -->

<HR />
<a name="_n_dec"></a>
<P><font face=Arial size=+1 color=#808080><B>n_dec</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>n_dec </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as decimal value.</I></P>
<P>Interpret string <i>S</i> as decimal integer, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_n_hex">n_hex</a></B> | <B><a href="#_n_oct">n_oct</a></B> | <B><a href="#_n_bin">n_bin</a></B> | <B><a href="#_n__base">n__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2730 -->

<HR />
<a name="_n_float"></a>
<P><font face=Arial size=+1 color=#808080><B>n_float</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>n_float </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>F</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as float value.</I></P>
<P>Interpret string <i>S</i> as float number, returning result.</P>
<P></P>
<!-- ../src/E_String.cpp:2757 -->

<HR />
<a name="_n_hex"></a>
<P><font face=Arial size=+1 color=#808080><B>n_hex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>n_hex </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as hexadecimal value.</I></P>
<P>Interpret string <i>S</i> as hexadecimal integer, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_n_oct">n_oct</a></B> | <B><a href="#_n_bin">n_bin</a></B> | <B><a href="#_n_dec">n_dec</a></B> | <B><a href="#_n__base">n__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2725 -->

<HR />
<a name="_n_oct"></a>
<P><font face=Arial size=+1 color=#808080><B>n_oct</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>n_oct </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Parse string as octal value.</I></P>
<P>Interpret string <i>S</i> as octal integer, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_n_hex">n_hex</a></B> | <B><a href="#_n_bin">n_bin</a></B> | <B><a href="#_n_dec">n_dec</a></B> | <B><a href="#_n__base">n__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2735 -->

<HR />
<a name="_nan"></a>
<P><font face=Arial size=+1 color=#808080><B>nan</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> ]</LI>
<LI type=disc><B>nan </B> () &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Not a number.</I></P>
<P>Returns numeric indefinite (not a number) value.</P>
<P><I>See also: </I>[ <B><a href="#_inf_pos">inf_pos</a></B> | <B><a href="#_inf_neg">inf_neg</a></B> ]</P>
<!-- ../src/E_Num.cpp:1299 -->

<HR />
<a name="_ne"></a>
<P><font face=Arial size=+1 color=#808080><B>ne</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>ne </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Numeric inequality.</I></P>
<P>Arithmetic inequality test: true, if <i>A</i> not equals to <i>B</i>.<br>Syntax: <i>A</i> ~= <i>B</i> or <i>A</i> <> <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_lt">lt</a></B> | <B><a href="#_le">le</a></B> | <B><a href="#_gt">gt</a></B> | <B><a href="#_ge">ge</a></B> | <B><a href="#_eq">eq</a></B> ]</P>
<!-- ../src/E_Num.cpp:1127 -->

<HR />
<a name="_neg"></a>
<P><font face=Arial size=+1 color=#808080><B>neg</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>neg </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric negation.</I></P>
<P>Arithmetic negation of numeric argument <i>A</i>.<br>Syntax: -<i>A</i>.</P>
<P><I>See also: </I>[ <B><a href="#_not">not</a></B> ]</P>
<!-- ../src/E_Num.cpp:785 -->

<HR />
<a name="_not"></a>
<P><font face=Arial size=+1 color=#808080><B>not</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>not </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise complement.</I></P>
<P>Bitwise complement of integer argument <i>I</i>.<br>Syntax: ~<i>I</i>.</P>
<P><I>See also: </I>[ <B><a href="#_neg">neg</a></B> ]</P>
<!-- ../src/E_Num.cpp:791 -->

<HR />
<a name="_num"></a>
<P><font face=Arial size=+1 color=#808080><B>num</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Coercion">Coercion</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>num </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Coerce scalar to number.</I></P>
<P>Explicit numeric coercion: from scalar <i>V</i> to integer or float value (according to default coercion rules).</P>
<P><I>See also: </I>[ <B><a href="#_int">int</a></B> | <B><a href="#_float">float</a></B> ]</P>
<!-- ../src/E_Num.cpp:1243 -->

<HR /><a name="_79"></a>
<P><font size=+1 color=red>= <B>O</B> =</font></P>
<HR />
<a name="_or"></a>
<P><font face=Arial size=+1 color=#808080><B>or</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>or </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise disjunction.</I></P>
<P>Bitwise OR of arguments <i>I</i> and <i>J</i>.<br>Syntax: <i>I</i> | <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_and">and</a></B> | <B><a href="#_xor">xor</a></B> ]</P>
<!-- ../src/E_Num.cpp:1079 -->

<HR />
<a name="_originator"></a>
<P><font face=Arial size=+1 color=#808080><B>originator</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>originator </B> (<i>Virtual</i>: <b><a href="AWL_Types.htm#_Virtual">Virtual</a></b>) &#8658; <b><a href="AWL_Types.htm#_Class">Class</a></b>.</LI>
<P><I>Originator of virtual method.</I></P>
<P>Returns originator class of virtual functor <i>Virtual</i>.</P>
<P><I>See also: </I>[ <B><a href="#_devirt">devirt</a></B> ]</P>
<!-- ../src/E_Object.cpp:418 -->

<HR />
<a name="_outside"></a>
<P><font face=Arial size=+1 color=#808080><B>outside</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> ]</LI>
<LI type=disc><B>outside </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Check for value exclusion from range.</I></P>
<P>True, if integer <i>Value</i> is outside range <i>R</i><br>(same as: <i>Value</i> < <i>R</i>[0] || <i>R</i>[1] <= <i>Value</i>).</P>
<P><I>See also: </I>[ <B><a href="#_inside">inside</a></B> ]</P>
<!-- ../src/E_Control.cpp:490 -->

<HR /><a name="_80"></a>
<P><font size=+1 color=red>= <B>P</B> =</font></P>
<HR />
<a name="_pi"></a>
<P><font face=Arial size=+1 color=#808080><B>pi</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>pi </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Multiply operand by \Pi.</I></P>
<P>Value of <i>X</i> multiplied by <i>Pi</i>.</P>
<P></P>
<!-- ../src/E_Num.cpp:860 -->

<HR /><a name="_82"></a>
<P><font size=+1 color=red>= <B>R</B> =</font></P>
<HR />
<a name="_r_count"></a>
<P><font face=Arial size=+1 color=#808080><B>r_count</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> ]</LI>
<LI type=disc><B>r_count </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Count elements in ring.</I></P>
<P>Count elements in <i>Ring</i>.</P>
<P></P>
<!-- ../src/E_Ring.cpp:671 -->

<HR />
<a name="_r_del"></a>
<P><font face=Arial size=+1 color=#808080><B>r_del</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>r_del </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Remove ring start element.</I></P>
<P>Remove start element of ring <i>Ring</i> (severing it from the rest of the ring).<br>Return element removed.</P>
<P></P>
<!-- ../src/E_Ring.cpp:639 -->

<HR />
<a name="_r_elem"></a>
<P><font face=Arial size=+1 color=#808080><B>r_elem</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Mutable">Mutable</a></b> ]</LI>
<LI type=disc><B>r_elem </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>.</LI>
<P><I>Ring element accessor.</I></P>
<P>Get access to element of <i>Ring</i> with relative <i>Offset</i>.</P>
<P></P>
<!-- ../src/E_Ring.cpp:647 -->

<HR />
<a name="_r_ins_after"></a>
<P><font face=Arial size=+1 color=#808080><B>r_ins_after</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>r_ins_after </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Val</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Insert element after start of ring.</I></P>
<P>Insert element <i>Val</i> after start of ring <i>Ring</i> (== at beginning).<br>Return ring.</P>
<P><I>See also: </I>[ <B><a href="#_r_ins_before">r_ins_before</a></B> ]</P>
<!-- ../src/E_Ring.cpp:630 -->

<HR />
<a name="_r_ins_before"></a>
<P><font face=Arial size=+1 color=#808080><B>r_ins_before</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>r_ins_before </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Val</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Insert element before start of ring.</I></P>
<P>Insert element <i>Val</i> before start of ring <i>Ring</i> (== at end).<br>Return ring.</P>
<P><I>See also: </I>[ <B><a href="#_r_ins_after">r_ins_after</a></B> ]</P>
<!-- ../src/E_Ring.cpp:624 -->

<HR />
<a name="_r_list"></a>
<P><font face=Arial size=+1 color=#808080><B>r_list</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>r_list </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Convert ring to open list (in direct order).</I></P>
<P>Return ring <i>Ring</i>, converted to list in direct order.</P>
<P><I>See also: </I>[ <B><a href="#_r_list_r">r_list_r</a></B> ]</P>
<!-- ../src/E_Ring.cpp:704 -->

<HR />
<a name="_r_list_r"></a>
<P><font face=Arial size=+1 color=#808080><B>r_list_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>r_list_r </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Convert ring to list (in reverse order).</I></P>
<P>Return ring <i>Ring</i>, converted to list in reverse order.</P>
<P><I>See also: </I>[ <B><a href="#_r_list">r_list</a></B> ]</P>
<!-- ../src/E_Ring.cpp:709 -->

<HR />
<a name="_r_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>r_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>r_loop </B> (<i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterate forward through ring.</I></P>
<P>For each element of <i>Ring</i> (moving forward), set <i>Var</i> to element content, and evaluate <i>Body</i>.<br>Return result of final evaluation of <i>Body</i>.</P>
<P><I>See also: </I>[ <B><a href="#_r_loop_r">r_loop_r</a></B> ]</P>
<!-- ../src/E_Ring.cpp:687 -->

<HR />
<a name="_r_loop_r"></a>
<P><font face=Arial size=+1 color=#808080><B>r_loop_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>r_loop_r </B> (<i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterate backward through ring.</I></P>
<P>For each element of <i>Ring</i> (moving backward), set <i>Var</i> to element content, and evaluate <i>Body</i>.<br>Return result of final evaluation of <i>Body</i>.</P>
<P><I>See also: </I>[ <B><a href="#_r_loop">r_loop</a></B> ]</P>
<!-- ../src/E_Ring.cpp:693 -->

<HR />
<a name="_r_reverse"></a>
<P><font face=Arial size=+1 color=#808080><B>r_reverse</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>r_reverse </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Reverse ring order.</I></P>
<P>Reverse elements order in <i>Ring</i>.</P>
<P></P>
<!-- ../src/E_Ring.cpp:678 -->

<HR />
<a name="_r_seek"></a>
<P><font face=Arial size=+1 color=#808080><B>r_seek</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> ]</LI>
<LI type=disc><B>r_seek </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Seek ring cyclically forward.</I></P>
<P>Seek ring <i>Ring</i> forward (cyclically) by <i>Offset</i> elements.<br>Note: when <i>Offset</i> < 0, equivalent to <b>r_seek_r</b> (<i>Ring</i>, -<i>Offset</i>).</P>
<P><I>See also: </I>[ <B><a href="#_r_seek_r">r_seek_r</a></B> ]</P>
<!-- ../src/E_Ring.cpp:656 -->

<HR />
<a name="_r_seek_r"></a>
<P><font face=Arial size=+1 color=#808080><B>r_seek_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> ]</LI>
<LI type=disc><B>r_seek_r </B> (<i>Ring</i>: <b><a href="AWL_Types.htm#_Ring">Ring</a></b>, <i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Seek ring cyclically backward.</I></P>
<P>Seek ring <i>Ring</i> backward (cyclically) by <i>Offset</i> elements.<br>Note: when <i>Offset</i> < 0, equivalent to <b>r_seek</b> (<i>Ring</i>, -<i>Offset</i>).</P>
<P><I>See also: </I>[ <B><a href="#_r_seek">r_seek</a></B> ]</P>
<!-- ../src/E_Ring.cpp:662 -->

<HR />
<a name="_rad"></a>
<P><font face=Arial size=+1 color=#808080><B>rad</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>rad </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>Y</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric polar radius.</I></P>
<P>Polar radius of cartesian point (<i>X</i>, <i>Y</i>).<br>(Same as <b>sqr</b>(<i>X</i>*<i>X</i> + <i>Y</i>*<i>Y</i>)).</P>
<P><I>See also: </I>[ <B><a href="#_ang">ang</a></B> ]</P>
<!-- ../src/E_Num.cpp:1160 -->

<HR />
<a name="_rand"></a>
<P><font face=Arial size=+1 color=#808080><B>rand</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>rand </B> ([<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Random numbers generator.</I></P>
<P>Returns next random number, belonging to the range 0..<i>N</i>.<br>If <i>N</i> is omitted, may return any integer value.</P>
<P><I>See also: </I>[ <B><a href="#_randomize">randomize</a></B> ]</P>
<!-- ../src/E_Num.cpp:1255 -->

<HR />
<a name="_randomize"></a>
<P><font face=Arial size=+1 color=#808080><B>randomize</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>randomize </B> ([<i>Seed</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Randomization.</I></P>
<P>Sets random numbers generator to <i>Seed</i> (affecting following values, returned by <b>rand</b>).<br>If <i>Seed</i> operand is omitted, chooses random seed for randomization.<br>Returns <i>Seed</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rand">rand</a></B> ]</P>
<!-- ../src/E_Num.cpp:1261 -->

<HR />
<a name="_range"></a>
<P><font face=Arial size=+1 color=#808080><B>range</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> | <b><a href="AWL_Categories.htm#_List">List</a></b> ]</LI>
<LI type=disc><B>range </B> (<i>From</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, [<i>By</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Range">Range</a></b>.</LI>
<P><I>Range by offset.</I></P>
<P>Return range <i>From</i>..<i>From</i>+<i>By</i>.<br>(If <i>By</i> omitted, 1 is assumed.)</P>
<P></P>
<!-- ../src/E_Control.cpp:499 -->

<HR />
<a name="_rdiv"></a>
<P><font face=Arial size=+1 color=#808080><B>rdiv</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>rdiv </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer ratio alternate.</I></P>
<P>Integer division of arguments.<br>(Same as <b>idiv</b> (<i>I</i>, <i>J</i>), but rounding negative result down).</P>
<P><I>See also: </I>[ <B><a href="#_idiv">idiv</a></B> | <B><a href="#_irem">irem</a></B> | <B><a href="#_rrem">rrem</a></B> ]</P>
<!-- ../src/E_Num.cpp:990 -->

<HR />
<a name="_reduce"></a>
<P><font face=Arial size=+1 color=#808080><B>reduce</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_List">List</a></b> | <b><a href="AWL_Categories.htm#_Meta">Meta</a></b> ]</LI>
<LI type=disc><B>reduce </B> (<i>Operation</i>: <b><a href="AWL_Types.htm#_Term">Term</a></b>) &#8658; <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>.</LI>
<P><I>Implements list reduction.</I></P>
<P>Performs reduction on binary term <i>Operation</i>.</P>
<P><I>See also: </I>[ <B><a href="#_comb">comb</a></B> ]</P>
<!-- ../src/E_Mut.cpp:587 -->

<HR />
<a name="_return"></a>
<P><font face=Arial size=+1 color=#808080><B>return</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Exception">Exception</a></b> ]</LI>
<LI type=disc><B>return </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Exception">Exception</a></b>.</LI>
<P><I>Return from functor.</I></P>
<P>Return from current functor (with return <i>Value</i>) to its caller.</P>
<P></P>
<!-- ../src/E_Xcpt.cpp:200 -->

<HR />
<a name="_reval"></a>
<P><font face=Arial size=+1 color=#808080><B>reval</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>reval </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Expression revaluation.</I></P>
<P>Evaluate result of evaluation of expression <i>X</i>.<br>Syntax: ^<i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_deval">deval</a></B> ]</P>
<!-- ../src/E_Mut.cpp:655 -->

<HR />
<a name="_ring"></a>
<P><font face=Arial size=+1 color=#808080><B>ring</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Ring">Ring</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>ring </B> (<i>Val</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Ring">Ring</a></b>.</LI>
<P><I>Create ring.</I></P>
<P>Create and return new ring, containing single element <i>Val</i>.</P>
<P></P>
<!-- ../src/E_Ring.cpp:614 -->

<HR />
<a name="_rrem"></a>
<P><font face=Arial size=+1 color=#808080><B>rrem</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>rrem </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Integer remainder alternate.</I></P>
<P>Integer remainder of arguments.<br>(Same as <b>irem</b> (<i>I</i>, <i>J</i>), but rounding negative result down).</P>
<P><I>See also: </I>[ <B><a href="#_idiv">idiv</a></B> | <B><a href="#_irem">irem</a></B> | <B><a href="#_rdiv">rdiv</a></B> ]</P>
<!-- ../src/E_Num.cpp:996 -->

<HR />
<a name="_rx_after_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_after_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_after_ex </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate sequence end (exclusive).</I></P>
<P>Construct pattern, matching end of characters sequence, for which application of <i>CPred</i> results in <b>false</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_before_in">rx_before_in</a></B> | <B><a href="#_rx_before_ex">rx_before_ex</a></B> | <B><a href="#_rx_after_in">rx_after_in</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2401 -->

<HR />
<a name="_rx_after_in"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_after_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_after_in </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate sequence end (inclusive).</I></P>
<P>Construct pattern, matching end of characters sequence, for which application of <i>CPred</i> results in <b>true</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_before_in">rx_before_in</a></B> | <B><a href="#_rx_before_ex">rx_before_ex</a></B> | <B><a href="#_rx_after_ex">rx_after_ex</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2396 -->

<HR />
<a name="_rx_alt"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_alt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_alt </B> (<i>First</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Second</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Alternation of patterns.</I></P>
<P>Construct pattern, matching either <i>First</i> or <i>Second</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_cat">rx_cat</a></B> | <B><a href="#_rx_rep">rx_rep</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2456 -->

<HR />
<a name="_rx_any"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_any</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_any </B> () &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Any character pattern.</I></P>
<P>Construct pattern, matching single arbitrary character.</P>
<P><I>See also: </I>[ <B><a href="#_rx_any_in">rx_any_in</a></B> | <B><a href="#_rx_any_ex">rx_any_ex</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2364 -->

<HR />
<a name="_rx_any_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_any_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_any_ex </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate check (exclusive).</I></P>
<P>Construct pattern, matching any character, for which application of <i>CPred</i> results in <b>false</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_any">rx_any</a></B> | <B><a href="#_rx_any_in">rx_any_in</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2376 -->

<HR />
<a name="_rx_any_in"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_any_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_any_in </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate check (inclusive).</I></P>
<P>Construct pattern, matching any character, for which application of <i>CPred</i> results in <b>true</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_any">rx_any</a></B> | <B><a href="#_rx_any_ex">rx_any_ex</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2371 -->

<HR />
<a name="_rx_at_end"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_at_end</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_at_end </B> (<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>End position anchor.</I></P>
<P>Construct pattern, matching at offset <i>Offset</i> relative to end.</P>
<P><I>See also: </I>[ <B><a href="#_rx_at_start">rx_at_start</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2418 -->

<HR />
<a name="_rx_at_start"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_at_start</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_at_start </B> (<i>Offset</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Start position anchor.</I></P>
<P>Construct pattern, matching at offset <i>Offset</i> relative to beginning.</P>
<P><I>See also: </I>[ <B><a href="#_rx_at_end">rx_at_end</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2413 -->

<HR />
<a name="_rx_before_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_before_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_before_ex </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate sequence start (exclusive).</I></P>
<P>Construct pattern, matching start of characters sequence, for which application of <i>CPred</i> results in <b>false</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_before_in">rx_before_in</a></B> | <B><a href="#_rx_after_in">rx_after_in</a></B> | <B><a href="#_rx_after_ex">rx_after_ex</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2391 -->

<HR />
<a name="_rx_before_in"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_before_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_before_in </B> (<i>CPred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Character predicate sequence start (inclusive).</I></P>
<P>Construct pattern, matching start of characters sequence, for which application of <i>CPred</i> results in <b>true</b>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_before_ex">rx_before_ex</a></B> | <B><a href="#_rx_after_in">rx_after_in</a></B> | <B><a href="#_rx_after_ex">rx_after_ex</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2386 -->

<HR />
<a name="_rx_cat"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_cat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_cat </B> (<i>Head</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Tail</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Concatenation of patterns.</I></P>
<P>Construct pattern, matching concatenation of <i>Head</i> and <i>Tail</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_alt">rx_alt</a></B> | <B><a href="#_rx_rep">rx_rep</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2463 -->

<HR />
<a name="_rx_char"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_char</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_char </B> (<i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Literal character pattern.</I></P>
<P>Construct pattern, matching literal character with code <i>Code</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_string">rx_string</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2348 -->

<HR />
<a name="_rx_fail"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_fail</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_fail </B> () &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Failure pattern.</I></P>
<P>Construct pattern, always failing to match anything.</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2481 -->

<HR />
<a name="_rx_findfirst"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_findfirst</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_findfirst </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Str</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Range">Range</a></b>.</LI>
<P><I>Search forward for pattern.</I></P>
<P>Find first pattern matching <i>Context</i> in string <i>Str</i>.<br>Returns offset range, where pattern is found (or <b>undef</b>, if no pattern found).</P>
<P><I>See also: </I>[ <B><a href="#_rx_match">rx_match</a></B> | <B><a href="#_rx_findlast">rx_findlast</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2542 -->

<HR />
<a name="_rx_findlast"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_findlast</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_findlast </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Str</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Range">Range</a></b>.</LI>
<P><I>Search backward for pattern.</I></P>
<P>Find last pattern matching <i>Context</i> in string <i>Str</i>.<br>Returns offset range, where pattern is found (or <b>undef</b>, if no pattern found).</P>
<P><I>See also: </I>[ <B><a href="#_rx_match">rx_match</a></B> | <B><a href="#_rx_findfirst">rx_findfirst</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2548 -->

<HR />
<a name="_rx_is_after"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_is_after</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_is_after </B> (<i>ContextAfter</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Look-after positive assertion anchor.</I></P>
<P>Construct pattern, matching empty string followed by <i>ContextAfter</i> (which is NOT included in match).</P>
<P><I>See also: </I>[ <B><a href="#_rx_is_before">rx_is_before</a></B> | <B><a href="#_rx_not_before">rx_not_before</a></B> | <B><a href="#_rx_not_after">rx_not_after</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2441 -->

<HR />
<a name="_rx_is_before"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_is_before</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_is_before </B> (<i>ContextBefore</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Look-before positive assertion anchor.</I></P>
<P>Construct pattern, matching empty string preceded by <i>ContextBefore</i> (which is NOT included in match).</P>
<P><I>See also: </I>[ <B><a href="#_rx_is_after">rx_is_after</a></B> | <B><a href="#_rx_not_before">rx_not_before</a></B> | <B><a href="#_rx_not_after">rx_not_after</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2428 -->

<HR />
<a name="_rx_length"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_length</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_length </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Range">Range</a></b>.</LI>
<P><I>Calculate length range of pattern.</I></P>
<P>Returns range of context lengths, which pattern <i>Context</i> may match.<br>(If context length is unlimited, Range[1] is undefined.)</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2524 -->

<HR />
<a name="_rx_locate"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_locate</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_locate </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Range</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>Direction</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Locate set of patterns in string.</I></P>
<P>Find subset of occurences of <i>Context</i> in <i>Source</i>.<br>Argument <i>Range</i> defines range of occurences, <i>Direction</i> defines order (from start/from end).</P>
<P><I>See also: </I>[ <B><a href="#_rx_split">rx_split</a></B> | <B><a href="#_rx_replace">rx_replace</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2567 -->

<HR />
<a name="_rx_match"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_match</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_match </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Str</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Pattern matching.</I></P>
<P>Match <i>Str</i> with pattern <i>Context</i>.<br>Return length of pattern matched (or -1, if match failed).</P>
<P><I>See also: </I>[ <B><a href="#_rx_findfirst">rx_findfirst</a></B> | <B><a href="#_rx_findlast">rx_findlast</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2534 -->

<HR />
<a name="_rx_not_after"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_not_after</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_not_after </B> (<i>ContextAfter</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Look-after negative assertion anchor.</I></P>
<P>Construct pattern, matching empty string NOT followed by <i>ContextAfter</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_is_before">rx_is_before</a></B> | <B><a href="#_rx_is_after">rx_is_after</a></B> | <B><a href="#_rx_not_before">rx_not_before</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2446 -->

<HR />
<a name="_rx_not_before"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_not_before</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_not_before </B> (<i>ContextBefore</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Look-before negative assertion anchor.</I></P>
<P>Construct pattern, matching empty string NOT preceded by <i>ContextBefore</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_is_before">rx_is_before</a></B> | <B><a href="#_rx_is_after">rx_is_after</a></B> | <B><a href="#_rx_not_after">rx_not_after</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2433 -->

<HR />
<a name="_rx_null"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_null</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_null </B> () &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Null pattern.</I></P>
<P>Construct pattern, matching empty string anywhere.</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2339 -->

<HR />
<a name="_rx_recall"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_recall</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_recall </B> (<i>RegNo</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Register recall pattern.</I></P>
<P>Construct pattern, matching context previously stored (by rx_store) in register <i>RegNo</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_store">rx_store</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2501 -->

<HR />
<a name="_rx_rep"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_rep</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_rep </B> (<i>Range</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>Greedy</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Repetition of pattern.</I></P>
<P>Construct pattern, matching <i>Body</i>, repeated minimum Range[0] and maximum Range[1] times.<br>If <i>Greedy</i> is <b>true</b>, attempts to find maximum number of repetitions (tries to find minimum otherwise).</P>
<P><I>See also: </I>[ <B><a href="#_rx_alt">rx_alt</a></B> | <B><a href="#_rx_cat">rx_cat</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2470 -->

<HR />
<a name="_rx_replace"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_replace</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_replace </B> (<i>Context</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Replacer</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Range</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>Direction</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Replace set of patterns in string.</I></P>
<P>Find subset of occurences of <i>Context</i> in <i>Source</i>, replace them with <i>Replacer</i>, and return result.<br>Argument <i>Range</i> defines range of occurences, <i>Direction</i> defines order (from start/end).</P>
<P><I>See also: </I>[ <B><a href="#_rx_locate">rx_locate</a></B> | <B><a href="#_rx_split">rx_split</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2575 -->

<HR />
<a name="_rx_split"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_split</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_split </B> (<i>Divider</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>, <i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Range</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>Direction</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Split string by pattern.</I></P>
<P>Split string <i>Source</i> (at places where pattern <i>Divider</i> is matched).<br>Argument <i>Range</i> defines range of occurences, <i>Direction</i> defines order (from start/from end).</P>
<P><I>See also: </I>[ <B><a href="#_rx_locate">rx_locate</a></B> | <B><a href="#_rx_replace">rx_replace</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2559 -->

<HR />
<a name="_rx_store"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_store</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_store </B> (<i>RegNo</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Register store pattern.</I></P>
<P>Construct pattern, matching <i>Body</i> (and storing successful match to register <i>RegNo</i>).</P>
<P><I>See also: </I>[ <B><a href="#_rx_recall">rx_recall</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2496 -->

<HR />
<a name="_rx_store_to"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_store_to</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_store_to </B> (<i>Var</i>: <b><a href="AWL_Types.htm#_Mut">Mut</a></b>, <i>RegNo</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Register store pattern (with storage mutable).</I></P>
<P>Construct pattern, matching <i>Body</i> (and storing successfull match to register <i>RegNo</i>).<br>On match success, match range is stored to <i>Var</i>.</P>
<P></P>
<!-- ../src/E_Pattern.cpp:2509 -->

<HR />
<a name="_rx_string"></a>
<P><font face=Arial size=+1 color=#808080><B>rx_string</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> | <b><a href="AWL_Categories.htm#_Pattern">Pattern</a></b> ]</LI>
<LI type=disc><B>rx_string </B> (<i>Text</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Pattern">Pattern</a></b>.</LI>
<P><I>Literal string pattern.</I></P>
<P>Construct pattern, matching literal string <i>Text</i>.</P>
<P><I>See also: </I>[ <B><a href="#_rx_char">rx_char</a></B> ]</P>
<!-- ../src/E_Pattern.cpp:2355 -->

<HR /><a name="_83"></a>
<P><font size=+1 color=red>= <B>S</B> =</font></P>
<HR />
<a name="_s__base"></a>
<P><font face=Arial size=+1 color=#808080><B>s__base</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s__base </B> (<i>B</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert signed integer to string by base.</I></P>
<P>Convert value <i>N</i> to binary string, base <i>B</i>, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_hex">s_hex</a></B> | <B><a href="#_s_oct">s_oct</a></B> | <B><a href="#_s_bin">s_bin</a></B> | <B><a href="#_s_dec">s_dec</a></B> ]</P>
<!-- ../src/E_String.cpp:2786 -->

<HR />
<a name="_s_bin"></a>
<P><font face=Arial size=+1 color=#808080><B>s_bin</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_bin </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert signed integer to binary string.</I></P>
<P>Convert value <i>N</i> to binary string, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_hex">s_hex</a></B> | <B><a href="#_s_oct">s_oct</a></B> | <B><a href="#_s_dec">s_dec</a></B> | <B><a href="#_s__base">s__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2781 -->

<HR />
<a name="_s_cat"></a>
<P><font face=Arial size=+1 color=#808080><B>s_cat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_cat </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String concatenation.</I></P>
<P>Returns strings <i>S</i> and <i>T</i> concatenated together.<br>Syntax: <i>S</i> +$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_len">s_len</a></B> | <B><a href="#_s_rep">s_rep</a></B> ]</P>
<!-- ../src/E_String.cpp:2327 -->

<HR />
<a name="_s_chars"></a>
<P><font face=Arial size=+1 color=#808080><B>s_chars</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_chars </B> (<i>Type</i>: <b><a href="AWL_Types.htm#_StringType">StringType</a></b>, <i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>,  ...) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Make string from character list.</I></P>
<P>Make and return string (of character <i>Type</i>) from list of characters with <i>Code</i> (s).</P>
<P></P>
<!-- ../src/E_String.cpp:2916 -->

<HR />
<a name="_s_cmp"></a>
<P><font face=Arial size=+1 color=#808080><B>s_cmp</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Compare">Compare</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_cmp </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Sign">Sign</a></b>.</LI>
<P><I>String signed comparison.</I></P>
<P>Returns -1, if <i>S</i> is alphabetically before <i>T</i>; 1, if <i>S</i> is alphabetically after <i>T</i>; 0 if <i>S</i> is equal to <i>T</i> (<i>S</i> and <i>T</i> evaluated once).<br>Syntax: <i>S</i> <?>$ <i>T</i>.</P>
<P></P>
<!-- ../src/E_String.cpp:2391 -->

<HR />
<a name="_s_common_head"></a>
<P><font face=Arial size=+1 color=#808080><B>s_common_head</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> ]</LI>
<LI type=disc><B>s_common_head </B> (<i>Str1</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Str2</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Common string head.</I></P>
<P>Find and return common beginning of strings <i>Str1</i> and <i>Str2</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_common_tail">s_common_tail</a></B> ]</P>
<!-- ../src/E_String.cpp:2838 -->

<HR />
<a name="_s_common_tail"></a>
<P><font face=Arial size=+1 color=#808080><B>s_common_tail</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> ]</LI>
<LI type=disc><B>s_common_tail </B> (<i>Str1</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Str2</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Common string tail.</I></P>
<P>Find and return common ending of strings <i>Str1</i> and <i>Str2</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_common_head">s_common_head</a></B> ]</P>
<!-- ../src/E_String.cpp:2843 -->

<HR />
<a name="_s_count_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>s_count_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_count_ex </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String count (exclusive).</I></P>
<P>Returns total # of all characters in <i>Source</i>, for which <i>Pred</i> evaluates to <b>false</b> (0, if none).</P>
<P><I>See also: </I>[ <B><a href="#_s_count_in">s_count_in</a></B> ]</P>
<!-- ../src/E_String.cpp:2630 -->

<HR />
<a name="_s_count_in"></a>
<P><font face=Arial size=+1 color=#808080><B>s_count_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_count_in </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String count (inclusive).</I></P>
<P>Returns total # of all characters in <i>Source</i>, for which <i>Pred</i> evaluates to <b>true</b> (0, if none).</P>
<P><I>See also: </I>[ <B><a href="#_s_count_ex">s_count_ex</a></B> ]</P>
<!-- ../src/E_String.cpp:2625 -->

<HR />
<a name="_s_create"></a>
<P><font face=Arial size=+1 color=#808080><B>s_create</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Constructor">Constructor</a></b> ]</LI>
<LI type=disc><B>s_create </B> (<i>Type</i>: <b><a href="AWL_Types.htm#_StringType">StringType</a></b>, <i>Length</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Mapper</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String constructor.</I></P>
<P>Returns new string (with type <i>Type</i> and length <i>Length</i>), created by applying functor <i>Mapper</i> to values in range 0 .. <i>Length</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_map">s_map</a></B> ]</P>
<!-- ../src/E_String.cpp:2536 -->

<HR />
<a name="_s_dec"></a>
<P><font face=Arial size=+1 color=#808080><B>s_dec</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_dec </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert signed integer to decimal string.</I></P>
<P>Convert value <i>N</i> to decimal string, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_hex">s_hex</a></B> | <B><a href="#_s_oct">s_oct</a></B> | <B><a href="#_s_bin">s_bin</a></B> | <B><a href="#_s__base">s__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2771 -->

<HR />
<a name="_s_decode"></a>
<P><font face=Arial size=+1 color=#808080><B>s_decode</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>s_decode </B> (<i>Decoder</i>: <b><a href="AWL_Types.htm#_Codec">Codec</a></b>, <i>Cooked</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Decode cooked string with codec.</I></P>
<P>Decode string <i>Cooked</i> (using codec <i>Decoder</i>), returning (raw) result.</P>
<P><I>See also: </I>[ <B><a href="#_s_encode">s_encode</a></B> ]</P>
<!-- ../src/E_String.cpp:2908 -->

<HR />
<a name="_s_efloat"></a>
<P><font face=Arial size=+1 color=#808080><B>s_efloat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>s_efloat </B> (<i>Val</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Capacity</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert float to string (E-format).</I></P>
<P>Convert value <i>Val</i> to string with <i>Capacity</i> significant digits, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_ffloat">s_ffloat</a></B> | <B><a href="#_s_gfloat">s_gfloat</a></B> ]</P>
<!-- ../src/E_String.cpp:2807 -->

<HR />
<a name="_s_empty"></a>
<P><font face=Arial size=+1 color=#808080><B>s_empty</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_empty </B> () &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Empty string literal.</I></P>
<P>Always returns empty string.</P>
<P></P>
<!-- ../src/E_String.cpp:2291 -->

<HR />
<a name="_s_encode"></a>
<P><font face=Arial size=+1 color=#808080><B>s_encode</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Codec">Codec</a></b> ]</LI>
<LI type=disc><B>s_encode </B> (<i>Encoder</i>: <b><a href="AWL_Types.htm#_Codec">Codec</a></b>, <i>Raw</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Encode raw string with codec.</I></P>
<P>Encode source string <i>Raw</i> (using codec <i>Encoder</i>), returning (cooked) result.</P>
<P><I>See also: </I>[ <B><a href="#_s_decode">s_decode</a></B> ]</P>
<!-- ../src/E_String.cpp:2903 -->

<HR />
<a name="_s_eq"></a>
<P><font face=Arial size=+1 color=#808080><B>s_eq</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_eq </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String equality.</I></P>
<P>String equality test: true, if <i>S</i> is identical to <i>T</i>.<br>Syntax: <i>S</i> ==$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_lt">s_lt</a></B> | <B><a href="#_s_le">s_le</a></B> | <B><a href="#_s_gt">s_gt</a></B> | <B><a href="#_s_ge">s_ge</a></B> | <B><a href="#_s_ne">s_ne</a></B> ]</P>
<!-- ../src/E_String.cpp:2370 -->

<HR />
<a name="_s_ffloat"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ffloat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>s_ffloat </B> (<i>Val</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Prec</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert float to string (F-format).</I></P>
<P>Convert value <i>Val</i> to string with precision <i>Prec</i>, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_efloat">s_efloat</a></B> | <B><a href="#_s_gfloat">s_gfloat</a></B> ]</P>
<!-- ../src/E_String.cpp:2802 -->

<HR />
<a name="_s_filter_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>s_filter_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_filter_ex </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String filter (exclusive).</I></P>
<P>Returns string, containing all characters in <i>Source</i>, for which <i>Pred</i> evaluates to <b>false</b> (or empty string, if <i>Pred</i> is always <b>true</b>).</P>
<P><I>See also: </I>[ <B><a href="#_s_filter_in">s_filter_in</a></B> ]</P>
<!-- ../src/E_String.cpp:2614 -->

<HR />
<a name="_s_filter_in"></a>
<P><font face=Arial size=+1 color=#808080><B>s_filter_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_filter_in </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String filter (inclusive).</I></P>
<P>Returns string, containing all characters in <i>Source</i>, for which <i>Pred</i> evaluates to <b>true</b> (or empty string, if <i>Pred</i> is always <b>false</b>).</P>
<P><I>See also: </I>[ <B><a href="#_s_filter_ex">s_filter_ex</a></B> ]</P>
<!-- ../src/E_String.cpp:2608 -->

<HR />
<a name="_s_findfirst"></a>
<P><font face=Arial size=+1 color=#808080><B>s_findfirst</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_findfirst </B> (<i>Src</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Ctx</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search string forward for context.</I></P>
<P>Searches forward string <i>Src</i>, looking for the first occurence of context <i>Ctx</i>.<br>Returns: offset of <i>Ctx</i> in <i>Src</i> (starting from 0), or -1, if <i>Ctx</i> was not found.<br>Syntax: <i>Src</i> >>$ <i>Ctx</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_findlast">s_findlast</a></B> ]</P>
<!-- ../src/E_String.cpp:2433 -->

<HR />
<a name="_s_findlast"></a>
<P><font face=Arial size=+1 color=#808080><B>s_findlast</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_findlast </B> (<i>Src</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Ctx</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Search string backward for context.</I></P>
<P>Searches backward string <i>Src</i>, looking for the last occurence of context <i>Ctx</i>.<br>Returns: offset of <i>Ctx</i> in <i>Src</i> (starting from 0), or -1, if <i>Ctx</i> was not found.<br>Syntax: <i>Src</i> <<$ <i>Ctx</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_findfirst">s_findfirst</a></B> ]</P>
<!-- ../src/E_String.cpp:2440 -->

<HR />
<a name="_s_ge"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ge</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_ge </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String "greater than or equal" compare.</I></P>
<P>String greater than/equal test: true, if <i>S</i> is alphabetically after or equal to <i>T</i>.<br>Syntax: <i>S</i> >=$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_lt">s_lt</a></B> | <B><a href="#_s_le">s_le</a></B> | <B><a href="#_s_gt">s_gt</a></B> | <B><a href="#_s_eq">s_eq</a></B> | <B><a href="#_s_ne">s_ne</a></B> ]</P>
<!-- ../src/E_String.cpp:2364 -->

<HR />
<a name="_s_gfloat"></a>
<P><font face=Arial size=+1 color=#808080><B>s_gfloat</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>s_gfloat </B> (<i>Val</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>, <i>Capacity</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert float to string (G-format).</I></P>
<P>Convert value <i>Val</i> to string with <i>Capacity</i> significant digits, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_ffloat">s_ffloat</a></B> | <B><a href="#_s_efloat">s_efloat</a></B> ]</P>
<!-- ../src/E_String.cpp:2812 -->

<HR />
<a name="_s_gt"></a>
<P><font face=Arial size=+1 color=#808080><B>s_gt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_gt </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String "greater than" compare.</I></P>
<P>String greater than test: true, if <i>S</i> is alphabetically after <i>T</i>.<br>Syntax: <i>S</i> >$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_lt">s_lt</a></B> | <B><a href="#_s_le">s_le</a></B> | <B><a href="#_s_ge">s_ge</a></B> | <B><a href="#_s_eq">s_eq</a></B> | <B><a href="#_s_ne">s_ne</a></B> ]</P>
<!-- ../src/E_String.cpp:2358 -->

<HR />
<a name="_s_hex"></a>
<P><font face=Arial size=+1 color=#808080><B>s_hex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_hex </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert signed integer to hexadecimal string.</I></P>
<P>Convert value <i>N</i> to hexadecimal string, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_oct">s_oct</a></B> | <B><a href="#_s_bin">s_bin</a></B> | <B><a href="#_s_dec">s_dec</a></B> | <B><a href="#_s__base">s__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2766 -->

<HR />
<a name="_s_icase"></a>
<P><font face=Arial size=+1 color=#808080><B>s_icase</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_icase </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Invert string case.</I></P>
<P>Return string <i>S</i>, with case inverted.</P>
<P><I>See also: </I>[ <B><a href="#_s_ucase">s_ucase</a></B> | <B><a href="#_s_lcase">s_lcase</a></B> ]</P>
<!-- ../src/E_String.cpp:2695 -->

<HR />
<a name="_s_icfirst"></a>
<P><font face=Arial size=+1 color=#808080><B>s_icfirst</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_icfirst </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Invert string case first character.</I></P>
<P>Return string <i>S</i>, with with only first character case inverted.</P>
<P><I>See also: </I>[ <B><a href="#_s_ucfirst">s_ucfirst</a></B> | <B><a href="#_s_lcfirst">s_lcfirst</a></B> ]</P>
<!-- ../src/E_String.cpp:2714 -->

<HR />
<a name="_s_join"></a>
<P><font face=Arial size=+1 color=#808080><B>s_join</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_join </B> (<i>Separator</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Items</i>: <b><a href="AWL_Types.htm#_List">List</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Join string list to string.</I></P>
<P>Returns result of concatenation of all items of <i>Items</i> (with strings <i>Separator</i> inserted between items).<br>Returns empty string, if <i>List</i> is empty.<br>Warning: list <i>Items</i> is expected to contain only strings (no implicit coercions).</P>
<P></P>
<!-- ../src/E_String.cpp:2545 -->

<HR />
<a name="_s_lcase"></a>
<P><font face=Arial size=+1 color=#808080><B>s_lcase</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_lcase </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Lowercase string.</I></P>
<P>Return string <i>S</i>, converted to lower case.</P>
<P><I>See also: </I>[ <B><a href="#_s_ucase">s_ucase</a></B> | <B><a href="#_s_icase">s_icase</a></B> ]</P>
<!-- ../src/E_String.cpp:2690 -->

<HR />
<a name="_s_lcfirst"></a>
<P><font face=Arial size=+1 color=#808080><B>s_lcfirst</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_lcfirst </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Lowercase string first character.</I></P>
<P>Return string <i>S</i>, with only first character converted to lower case.</P>
<P><I>See also: </I>[ <B><a href="#_s_ucfirst">s_ucfirst</a></B> | <B><a href="#_s_icfirst">s_icfirst</a></B> ]</P>
<!-- ../src/E_String.cpp:2709 -->

<HR />
<a name="_s_le"></a>
<P><font face=Arial size=+1 color=#808080><B>s_le</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_le </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String "less than or equal" compare.</I></P>
<P>String less than/equal test: true, if <i>S</i> is alphabetically before or equal to <i>T</i>.<br>Syntax: <i>S</i> <=$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_lt">s_lt</a></B> | <B><a href="#_s_gt">s_gt</a></B> | <B><a href="#_s_ge">s_ge</a></B> | <B><a href="#_s_eq">s_eq</a></B> | <B><a href="#_s_ne">s_ne</a></B> ]</P>
<!-- ../src/E_String.cpp:2352 -->

<HR />
<a name="_s_len"></a>
<P><font face=Arial size=+1 color=#808080><B>s_len</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_len </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get string length.</I></P>
<P>Returns length of string <i>S</i> (0, if <i>S</i> is empty).<br>Syntax: #$<i>S</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_cat">s_cat</a></B> | <B><a href="#_s_rep">s_rep</a></B> ]</P>
<!-- ../src/E_String.cpp:2319 -->

<HR />
<a name="_s_loop"></a>
<P><font face=Arial size=+1 color=#808080><B>s_loop</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>s_loop </B> (<i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>String direct iterator.</I></P>
<P>Evaluate <i>Body</i> for all characters in <i>Source</i> (from first to last), assigning current character code to <i>Var</i> on each iteration.</P>
<P><I>See also: </I>[ <B><a href="#_s_loop_r">s_loop_r</a></B> ]</P>
<!-- ../src/E_String.cpp:2657 -->

<HR />
<a name="_s_loop_r"></a>
<P><font face=Arial size=+1 color=#808080><B>s_loop_r</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> ]</LI>
<LI type=disc><B>s_loop_r </B> (<i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>String reverse iterator.</I></P>
<P>Evaluate <i>Body</i> for all characters in <i>Source</i> (from last to first), assigning current character code to <i>Var</i> on each iteration.</P>
<P><I>See also: </I>[ <B><a href="#_s_loop">s_loop</a></B> ]</P>
<!-- ../src/E_String.cpp:2663 -->

<HR />
<a name="_s_lt"></a>
<P><font face=Arial size=+1 color=#808080><B>s_lt</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_lt </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String "less than" compare.</I></P>
<P>String less than test: true, if <i>S</i> is alphabetically before <i>T</i>.<br>Syntax: <i>S</i> <$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_le">s_le</a></B> | <B><a href="#_s_gt">s_gt</a></B> | <B><a href="#_s_ge">s_ge</a></B> | <B><a href="#_s_eq">s_eq</a></B> | <B><a href="#_s_ne">s_ne</a></B> ]</P>
<!-- ../src/E_String.cpp:2346 -->

<HR />
<a name="_s_map"></a>
<P><font face=Arial size=+1 color=#808080><B>s_map</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_map </B> (<i>Mapper</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>, <i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String character translation.</I></P>
<P>Returns new string, created by applying functor <i>Mapper</i> to character codes in string <i>S</i>.<br>(<i>Mapper</i> is invoked as <i>Mapper</i> ! (OldCode: Int) => NewCode and expected to return integer.)</P>
<P><I>See also: </I>[ <B><a href="#_s_create">s_create</a></B> ]</P>
<!-- ../src/E_String.cpp:2528 -->

<HR />
<a name="_s_max"></a>
<P><font face=Arial size=+1 color=#808080><B>s_max</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_max </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String maximum.</I></P>
<P>Returns either <i>S</i> or <i>T</i>, which is last alphabetically.<br>Syntax: <i>S</i> ?>$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_min">s_min</a></B> ]</P>
<!-- ../src/E_String.cpp:2408 -->

<HR />
<a name="_s_min"></a>
<P><font face=Arial size=+1 color=#808080><B>s_min</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_min </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String minimum.</I></P>
<P>Returns either <i>S</i> or <i>T</i>, which is first alphabetically.<br>Syntax: <i>S</i> ?<$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_max">s_max</a></B> ]</P>
<!-- ../src/E_String.cpp:2402 -->

<HR />
<a name="_s_ne"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ne</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Predicate">Predicate</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_ne </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>T</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>String inequality.</I></P>
<P>String inequality test: true, if <i>S</i> is different from <i>T</i>.<br>Syntax: <i>S</i> <>$ <i>T</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_lt">s_lt</a></B> | <B><a href="#_s_le">s_le</a></B> | <B><a href="#_s_gt">s_gt</a></B> | <B><a href="#_s_ge">s_ge</a></B> | <B><a href="#_s_eq">s_eq</a></B> ]</P>
<!-- ../src/E_String.cpp:2376 -->

<HR />
<a name="_s_oct"></a>
<P><font face=Arial size=+1 color=#808080><B>s_oct</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_oct </B> (<i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert signed integer to octal string.</I></P>
<P>Convert value <i>N</i> to octal string, returning result.</P>
<P><I>See also: </I>[ <B><a href="#_s_hex">s_hex</a></B> | <B><a href="#_s_bin">s_bin</a></B> | <B><a href="#_s_dec">s_dec</a></B> | <B><a href="#_s__base">s__base</a></B> ]</P>
<!-- ../src/E_String.cpp:2776 -->

<HR />
<a name="_s_ord"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ord</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_ord </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, [<i>Index</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get character code.</I></P>
<P>Returns code of character in <i>String</i> with offset <i>Index</i> (defaults to 0).<br>Returns <b>undef</b>, if index out of range.</P>
<P></P>
<!-- ../src/E_String.cpp:2674 -->

<HR />
<a name="_s_patch"></a>
<P><font face=Arial size=+1 color=#808080><B>s_patch</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>s_patch </B> (<i>Str</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Where</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>Replacer</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Replace fragment in string mutable.</I></P>
<P>Replace fragment (at <i>Range</i>) in mutable string <i>Str</i> with string <i>Replacer</i> (returning result).</P>
<P><I>See also: </I>[ <B><a href="#_s_poke">s_poke</a></B> ]</P>
<!-- ../src/E_String.cpp:2828 -->

<HR />
<a name="_s_poke"></a>
<P><font face=Arial size=+1 color=#808080><B>s_poke</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> ]</LI>
<LI type=disc><B>s_poke </B> (<i>Str</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>Index</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>Code</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Replace character in string mutable.</I></P>
<P>Replace charcter (at <i>Index</i>) in mutable string <i>Str</i> with code <i>Code</i> (returning result).</P>
<P><I>See also: </I>[ <B><a href="#_s_patch">s_patch</a></B> ]</P>
<!-- ../src/E_String.cpp:2823 -->

<HR />
<a name="_s_range"></a>
<P><font face=Arial size=+1 color=#808080><B>s_range</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_range </B> (<i>Type</i>: <b><a href="AWL_Types.htm#_StringType">StringType</a></b>, <i>Direction</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, <i>FromChar</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>ToChar</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Create string from character range.</I></P>
<P>Result contains all characters from <i>FromChar</i> up to <i>ToChar</i>-1 (unless <i>Direction</i>), or all characters from <i>ToChar</i>-1 down to <i>FromChar</i> (if <i>Direction</i>).<br><i>Type</i> defines type of result.</P>
<P></P>
<!-- ../src/E_String.cpp:2556 -->

<HR />
<a name="_s_rep"></a>
<P><font face=Arial size=+1 color=#808080><B>s_rep</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_rep </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>N</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String replication.</I></P>
<P>Returns <i>S</i> replicated exactly <i>N</i> times.<br>(Returns <i>S</i>, if <i>N</i> == 1; or empty string, if <i>N</i> == 0.)<br>Syntax: <i>S</i> *$ <i>N</i>.</P>
<P><I>See also: </I>[ <B><a href="#_s_len">s_len</a></B> | <B><a href="#_s_cat">s_cat</a></B> ]</P>
<!-- ../src/E_String.cpp:2335 -->

<HR />
<a name="_s_retype"></a>
<P><font face=Arial size=+1 color=#808080><B>s_retype</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_retype </B> (<i>Type</i>: <b><a href="AWL_Types.htm#_StringType">StringType</a></b>, <i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Convert string to different type.</I></P>
<P>Convert string <i>S</i> to characters <i>Type</i><br>(8 bit chars / 16 bit chars / 32 bit chars).<br>Conversion is defined by active <b>codepage</b>.</P>
<P><I>See also: </I>[ <B><a href="#_s_type">s_type</a></B> ]</P>
<!-- ../src/E_String.cpp:2308 -->

<HR />
<a name="_s_rev"></a>
<P><font face=Arial size=+1 color=#808080><B>s_rev</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_rev </B> (<i>Str</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String reverse.</I></P>
<P>Returns reversion of string <i>Str</i>.</P>
<P></P>
<!-- ../src/E_String.cpp:2567 -->

<HR />
<a name="_s_rspan_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>s_rspan_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_rspan_ex </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String span backward (exclusive).</I></P>
<P>Scans string <i>Source</i> backward from end, while evaluation of <i>Pred</i> returns <b>false</b>.<br>Returns offset of last character, where <i>Pred</i> still evaluates to <b>false</b> (or 0, if never).</P>
<P><I>See also: </I>[ <B><a href="#_s_span_in">s_span_in</a></B> | <B><a href="#_s_span_ex">s_span_ex</a></B> | <B><a href="#_s_rspan_in">s_rspan_in</a></B> ]</P>
<!-- ../src/E_String.cpp:2597 -->

<HR />
<a name="_s_rspan_in"></a>
<P><font face=Arial size=+1 color=#808080><B>s_rspan_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_rspan_in </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String span backward (inclusive).</I></P>
<P>Scans string <i>Source</i> backward from end, while evaluation of <i>Pred</i> returns <b>true</b>.<br>Returns offset of last character, where <i>Pred</i> still evaluates to <b>true</b> (or 0, if never).</P>
<P><I>See also: </I>[ <B><a href="#_s_span_in">s_span_in</a></B> | <B><a href="#_s_span_ex">s_span_ex</a></B> | <B><a href="#_s_rspan_ex">s_rspan_ex</a></B> ]</P>
<!-- ../src/E_String.cpp:2591 -->

<HR />
<a name="_s_slice"></a>
<P><font face=Arial size=+1 color=#808080><B>s_slice</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_slice </B> (<i>R</i>: <b><a href="AWL_Types.htm#_Range">Range</a></b>, <i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>String slice.</I></P>
<P>Returns fragment of string <i>S</i> sliced by range <i>R</i>.<br>Range <i>R</i> defaults to entire string (0 .. #$<i>S</i>).<br>If <i>R</i> exceeds limits (either <i>R</i>[0] < 0 or <i>R</i>[1] > #$<i>S</i>), returned string is padded with spaces at begin and/or end.<br>Length of result is always <i>R</i>[1] - <i>R</i>[0].<br>Syntax: <i>S</i> $[<i>R</i>].</P>
<P></P>
<!-- ../src/E_String.cpp:2419 -->

<HR />
<a name="_s_span_ex"></a>
<P><font face=Arial size=+1 color=#808080><B>s_span_ex</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_span_ex </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String span forward (exclusive).</I></P>
<P>Scans string <i>Source</i> forward from start, while evaluation of <i>Pred</i> returns <b>false</b>.<br>Returns offset of first character, where <i>Pred</i> evaluates to <b>true</b> (or <i>Source</i> length, if never).</P>
<P><I>See also: </I>[ <B><a href="#_s_span_in">s_span_in</a></B> | <B><a href="#_s_rspan_in">s_rspan_in</a></B> | <B><a href="#_s_rspan_ex">s_rspan_ex</a></B> ]</P>
<!-- ../src/E_String.cpp:2582 -->

<HR />
<a name="_s_span_in"></a>
<P><font face=Arial size=+1 color=#808080><B>s_span_in</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_span_in </B> (<i>Source</i>: <b><a href="AWL_Types.htm#_String">String</a></b>, <i>Pred</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>String span forward (inclusive).</I></P>
<P>Scans string <i>Source</i> forward from start, while evaluation of <i>Pred</i> returns <b>true</b>.<br>Returns offset of first character, where <i>Pred</i> evaluates to <b>false</b> (or <i>Source</i> length, if never).</P>
<P><I>See also: </I>[ <B><a href="#_s_span_ex">s_span_ex</a></B> | <B><a href="#_s_rspan_in">s_rspan_in</a></B> | <B><a href="#_s_rspan_ex">s_rspan_ex</a></B> ]</P>
<!-- ../src/E_String.cpp:2576 -->

<HR />
<a name="_s_type"></a>
<P><font face=Arial size=+1 color=#808080><B>s_type</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>s_type </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_StringType">StringType</a></b>.</LI>
<P><I>Query string type.</I></P>
<P>Returns type of string <i>S</i><br>(8 bit chars / 16 bit chars / 32 bit chars).</P>
<P><I>See also: </I>[ <B><a href="#_s_retype">s_retype</a></B> ]</P>
<!-- ../src/E_String.cpp:2300 -->

<HR />
<a name="_s_ucase"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ucase</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_ucase </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Uppercase string.</I></P>
<P>Return string <i>S</i>, converted to upper case.</P>
<P><I>See also: </I>[ <B><a href="#_s_lcase">s_lcase</a></B> | <B><a href="#_s_icase">s_icase</a></B> ]</P>
<!-- ../src/E_String.cpp:2685 -->

<HR />
<a name="_s_ucfirst"></a>
<P><font face=Arial size=+1 color=#808080><B>s_ucfirst</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_String">String</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>s_ucfirst </B> (<i>S</i>: <b><a href="AWL_Types.htm#_String">String</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Uppercase string first character.</I></P>
<P>Return string <i>S</i>, with only first character converted to upper case.</P>
<P><I>See also: </I>[ <B><a href="#_s_lcfirst">s_lcfirst</a></B> | <B><a href="#_s_icfirst">s_icfirst</a></B> ]</P>
<!-- ../src/E_String.cpp:2704 -->

<HR />
<a name="_self"></a>
<P><font face=Arial size=+1 color=#808080><B>self</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>self </B> (<i>Class</i>: <b><a href="AWL_Types.htm#_Class">Class</a></b>) &#8658; <b><a href="AWL_Types.htm#_Object">Object</a></b>.</LI>
<P><I>Retrieve current class instance.</I></P>
<P>Evaluates <i>Class</i>, and returns its current instance.<br>(Returns <b>undef</b>, if <i>Class</i> is not class reference, or has no current instance.)</P>
<P><I>See also: </I>[ <B><a href="#_class_of">class_of</a></B> | <B><a href="#_super_of">super_of</a></B> ]</P>
<!-- ../src/E_Object.cpp:385 -->

<HR />
<a name="_set"></a>
<P><font face=Arial size=+1 color=#808080><B>set</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>set </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Eager assignment.</I></P>
<P>Assigns result of evaluation of expression <i>X</i> to mutable <i>V</i>.<br>Returns: assigned value.<br>Syntax: <i>V</i> = <i>X</i>.</P>
<P><I>See also: </I>[ <B><a href="#_let">let</a></B> | <B><a href="#_swap">swap</a></B> ]</P>
<!-- ../src/E_Mut.cpp:566 -->

<HR />
<a name="_sgn"></a>
<P><font face=Arial size=+1 color=#808080><B>sgn</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sgn </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Sign">Sign</a></b>.</LI>
<P><I>Numeric sign.</I></P>
<P>Arithmetic sign (-1, 0, 1) of numeric argument <i>A</i>.<br>(Equivalent to: (<i>A</i> > 0 ? 1 : <i>A</i> < 0 ? -1 : 0), but with <i>A</i> evaluated once).<br>Syntax: <?><i>A</i>.</P>
<P><I>See also: </I>[ <B><a href="#_abs">abs</a></B> ]</P>
<!-- ../src/E_Num.cpp:809 -->

<HR />
<a name="_shl"></a>
<P><font face=Arial size=+1 color=#808080><B>shl</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>shl </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise shift left.</I></P>
<P>Arithmetic shift: returns <i>I</i> shifted left by <i>J</i> bits.<br>Note: (<i>I</i> << -<i>J</i> == <i>I</i> >> <i>J</i>).<br>Syntax: <i>I</i> << <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_shr">shr</a></B> ]</P>
<!-- ../src/E_Num.cpp:1026 -->

<HR />
<a name="_shr"></a>
<P><font face=Arial size=+1 color=#808080><B>shr</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>shr </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise shift right.</I></P>
<P>Arithmetic shift: returns <i>I</i> shifted right by <i>J</i> bits.<br>Note: (<i>I</i> >> -<i>J</i> == <i>I</i> << <i>J</i>).<br>Syntax: <i>I</i> >> <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_shl">shl</a></B> ]</P>
<!-- ../src/E_Num.cpp:1033 -->

<HR />
<a name="_sin"></a>
<P><font face=Arial size=+1 color=#808080><B>sin</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sin </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric sine.</I></P>
<P>Sine of <i>X</i> (with argument in radians).</P>
<P><I>See also: </I>[ <B><a href="#_cos">cos</a></B> | <B><a href="#_tan">tan</a></B> | <B><a href="#_asin">asin</a></B> ]</P>
<!-- ../src/E_Num.cpp:869 -->

<HR />
<a name="_sinh"></a>
<P><font face=Arial size=+1 color=#808080><B>sinh</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sinh </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric hyperbolic sine.</I></P>
<P>Hyperbolic Sine of <i>X</i>.<br>(Equals to: (<b>exp</b>(<i>X</i>) - <b>exp</b>(-<i>X</i>)) / 2).</P>
<P><I>See also: </I>[ <B><a href="#_cosh">cosh</a></B> | <B><a href="#_tanh">tanh</a></B> ]</P>
<!-- ../src/E_Num.cpp:915 -->

<HR />
<a name="_sll"></a>
<P><font face=Arial size=+1 color=#808080><B>sll</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sll </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise logical shift left.</I></P>
<P>Logic shift: returns <i>I</i> shifted left by <i>J</i> bits.</P>
<P></P>
<!-- ../src/E_Num.cpp:1043 -->

<HR />
<a name="_slr"></a>
<P><font face=Arial size=+1 color=#808080><B>slr</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>slr </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise logical shift right.</I></P>
<P>Logic shift: returns <i>I</i> shifted right by <i>J</i> bits (no sign expansion).</P>
<P></P>
<!-- ../src/E_Num.cpp:1048 -->

<HR />
<a name="_sqr"></a>
<P><font face=Arial size=+1 color=#808080><B>sqr</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sqr </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric square root.</I></P>
<P>Square root of <i>X</i> (NAN, if <i>X</i> < 0).</P>
<P></P>
<!-- ../src/E_Num.cpp:836 -->

<HR />
<a name="_string"></a>
<P><font face=Arial size=+1 color=#808080><B>string</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Coercion">Coercion</a></b> | <b><a href="AWL_Categories.htm#_String">String</a></b> ]</LI>
<LI type=disc><B>string </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Scalar">Scalar</a></b>) &#8658; <b><a href="AWL_Types.htm#_String">String</a></b>.</LI>
<P><I>Coerce scalar to string.</I></P>
<P>Explicit string coercion: from scalar <i>V</i> to string value (according to default coercion rules).</P>
<P></P>
<!-- ../src/E_String.cpp:2452 -->

<HR />
<a name="_sub"></a>
<P><font face=Arial size=+1 color=#808080><B>sub</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>sub </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Num">Num</a></b>.</LI>
<P><I>Numeric subtraction.</I></P>
<P>Arithmetic difference of arguments <i>A</i> and <i>B</i>.<br>Syntax: <i>A</i> - <i>B</i>.</P>
<P><I>See also: </I>[ <B><a href="#_add">add</a></B> ]</P>
<!-- ../src/E_Num.cpp:945 -->

<HR />
<a name="_super_of"></a>
<P><font face=Arial size=+1 color=#808080><B>super_of</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> ]</LI>
<LI type=disc><B>super_of </B> (<i>Class</i>: <b><a href="AWL_Types.htm#_Class">Class</a></b>) &#8658; <b><a href="AWL_Types.htm#_Class">Class</a></b>.</LI>
<P><I>Retrieve superclass of class.</I></P>
<P>Returns class, from which <i>Class</i> is derived (or <b>undef</b>, if <i>Class</i> has no ancestors).</P>
<P><I>See also: </I>[ <B><a href="#_class_of">class_of</a></B> | <B><a href="#_self">self</a></B> ]</P>
<!-- ../src/E_Object.cpp:393 -->

<HR />
<a name="_swap"></a>
<P><font face=Arial size=+1 color=#808080><B>swap</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Mutator">Mutator</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>swap </B> (<i>V</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>, <i>W</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; ().</LI>
<P><I>Exchange values.</I></P>
<P>Exchanges values of mutables <i>V</i> and <i>W</i>.<br>Syntax: <i>V</i> :=: <i>W</i>.</P>
<P><I>See also: </I>[ <B><a href="#_let">let</a></B> | <B><a href="#_set">set</a></B> ]</P>
<!-- ../src/E_Mut.cpp:637 -->

<HR />
<a name="_switch"></a>
<P><font face=Arial size=+1 color=#808080><B>switch</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> ]</LI>
<LI type=disc><B>switch </B> (<i>Value</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, (<i>Case1</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>Action1</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>), (<i>Case2</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>Action2</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>), ... (<i>CaseN</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>ActionN</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>), [<i>Default</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Choose action by key.</I></P>
<P>For <i>Value</i> specified, select first (<i>Case</i>, <i>Action</i>) pair, where result of <i>Case</i> is identical to <i>Value</i>.<br>If all checks failed, select <i>Default</i> as <i>Action</i>.<br>(Returns result of evaluation of selected <i>Action</i>.)</P>
<P></P>
<!-- ../src/E_Hash.cpp:924 -->

<HR /><a name="_84"></a>
<P><font size=+1 color=red>= <B>T</B> =</font></P>
<HR />
<a name="_tan"></a>
<P><font face=Arial size=+1 color=#808080><B>tan</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>tan </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Trigonometric tangent.</I></P>
<P>Tangent of <i>X</i> (with argument in radians).</P>
<P><I>See also: </I>[ <B><a href="#_sin">sin</a></B> | <B><a href="#_cos">cos</a></B> | <B><a href="#_atan">atan</a></B> ]</P>
<!-- ../src/E_Num.cpp:879 -->

<HR />
<a name="_tanh"></a>
<P><font face=Arial size=+1 color=#808080><B>tanh</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>tanh </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Float">Float</a></b>) &#8658; <b><a href="AWL_Types.htm#_Float">Float</a></b>.</LI>
<P><I>Numeric hyperbolic tangent.</I></P>
<P>Hyperbolic Tangent of <i>X</i>.<br>(Equals to: <b>sinh</b>(<i>X</i>) / <b>cosh</b>(<i>X</i>), or (<b>exp</b>(<i>X</i>) - <b>exp</b>(-<i>X</i>)) / (<b>exp</b>(<i>X</i>) + <b>exp</b>(-<i>X</i>))).</P>
<P><I>See also: </I>[ <B><a href="#_sinh">sinh</a></B> | <B><a href="#_cosh">cosh</a></B> ]</P>
<!-- ../src/E_Num.cpp:927 -->

<HR />
<a name="_throw"></a>
<P><font face=Arial size=+1 color=#808080><B>throw</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Exception">Exception</a></b> ]</LI>
<LI type=disc><B>throw </B> (<i>Exception</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Exception">Exception</a></b>.</LI>
<P><I>Throw exception.</I></P>
<P>Throw any definite <i>Exception</i>, to be caught and processed somewhere in caller.</P>
<P><I>See also: </I>[ <B><a href="#_try">try</a></B> | <B><a href="#_try_catch">try_catch</a></B> ]</P>
<!-- ../src/E_Xcpt.cpp:192 -->

<HR />
<a name="_time"></a>
<P><font face=Arial size=+1 color=#808080><B>time</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>time </B> () &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Get system time.</I></P>
<P>Returns current system time (seconds since Epoch).</P>
<P><I>See also: </I>[ <B><a href="#_local_time">local_time</a></B> | <B><a href="#_utc_time">utc_time</a></B> ]</P>
<!-- ../src/E_System.cpp:718 -->

<HR />
<a name="_times"></a>
<P><font face=Arial size=+1 color=#808080><B>times</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>times </B> (<i>Count</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Fixed count iterator.</I></P>
<P>Evaluates <i>Body</i> precisely <i>Count</i> times (never, if <i>Count</i> <= 0).<br>Returns final value of <i>Body</i> (or <b>undef</b>, if <i>Body</i> never was evaluated).</P>
<P><I>See also: </I>[ <B><a href="#_for_inc">for_inc</a></B> | <B><a href="#_for_dec">for_dec</a></B> | <B><a href="#_ever">ever</a></B> ]</P>
<!-- ../src/E_Control.cpp:466 -->

<HR />
<a name="_true"></a>
<P><font face=Arial size=+1 color=#808080><B>true</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Nullary">Nullary</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> ]</LI>
<LI type=disc><B>true </B> () &#8658; <b><a href="AWL_Types.htm#_Bool">Bool</a></b>.</LI>
<P><I>Literal true value.</I></P>
<P>Returns <b>true</b> value (always 1).</P>
<P><I>See also: </I>[ <B><a href="#_false">false</a></B> ]</P>
<!-- ../src/E_Control.cpp:351 -->

<HR />
<a name="_try"></a>
<P><font face=Arial size=+1 color=#808080><B>try</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Exception">Exception</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>try </B> (<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Exception frame wrapper.</I></P>
<P>Evaluate <i>Body</i> in exception frame.<br>If exception was thrown, return thrown value.<br>Returns result of <i>Body</i>, if no exception occured.</P>
<P><I>See also: </I>[ <B><a href="#_try_catch">try_catch</a></B> | <B><a href="#_throw">throw</a></B> ]</P>
<!-- ../src/E_Xcpt.cpp:207 -->

<HR />
<a name="_try_catch"></a>
<P><font face=Arial size=+1 color=#808080><B>try_catch</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Exception">Exception</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>try </B> (<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>, <i>Var</i>: <b><a href="AWL_Types.htm#_Mutable">Mutable</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Exception frame wrapper.</I></P>
<P>Evaluate <i>Body</i> in exception frame.<br>If exception was thrown, assign thrown value to <i>Var</i>, and return <b>undef</b>.<br>Returns result of <i>Body</i>, if no exception occured.</P>
<P><I>See also: </I>[ <B><a href="#_try">try</a></B> | <B><a href="#_throw">throw</a></B> ]</P>
<!-- ../src/E_Xcpt.cpp:214 -->

<HR /><a name="_85"></a>
<P><font size=+1 color=red>= <B>U</B> =</font></P>
<HR />
<a name="_u_cmp"></a>
<P><font face=Arial size=+1 color=#808080><B>u_cmp</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Compare">Compare</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>u_cmp </B> (<i>A</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>, <i>B</i>: <b><a href="AWL_Types.htm#_Num">Num</a></b>) &#8658; <b><a href="AWL_Types.htm#_Sign">Sign</a></b>.</LI>
<P><I>Numeric unsigned comparison.</I></P>
<P>Arithmetic unsigned compare.</P>
<P><I>See also: </I>[ <B><a href="#_cmp">cmp</a></B> ]</P>
<!-- ../src/E_Num.cpp:1151 -->

<HR />
<a name="_unless"></a>
<P><font face=Arial size=+1 color=#808080><B>unless</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Ternary">Ternary</a></b> ]</LI>
<LI type=disc><B>unless </B> (<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Else</i>: <b><a href="AWL_Types.htm#_Any1">Any1</a></b> [, @<i>Then</i>: <b><a href="AWL_Types.htm#_Any2">Any2</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Any1">Any1</a></b> | <b><a href="AWL_Types.htm#_Any2">Any2</a></b>.</LI>
<P><I>Conditional negative test.</I></P>
<P>If boolean <i>Cond</i> is <b>false</b>, evaluates and returns <i>Else</i>; otherwise evaluates and returns <i>Then</i>.</P>
<P><I>See also: </I>[ <B><a href="#_if">if</a></B> ]</P>
<!-- ../src/E_Control.cpp:404 -->

<HR />
<a name="_until"></a>
<P><font face=Arial size=+1 color=#808080><B>until</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>until </B> (@<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterator with negative precondition.</I></P>
<P>While boolean <i>Cond</i> remains <b>false</b>, repeatedly evaluates <i>Body</i>.<br>Returns final value of <i>Body</i> (or <b>undef</b>, if <i>Body</i> never was evaluated).</P>
<P><I>See also: </I>[ <B><a href="#_while">while</a></B> | <B><a href="#_do_while">do_while</a></B> | <B><a href="#_do_until">do_until</a></B> ]</P>
<!-- ../src/E_Control.cpp:421 -->

<HR />
<a name="_utc_time"></a>
<P><font face=Arial size=+1 color=#808080><B>utc_time</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_OS">OS</a></b> ]</LI>
<LI type=disc><B>utc_time </B> ([<i>Time</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>]) &#8658; <b><a href="AWL_Types.htm#_List">List</a></b>.</LI>
<P><I>Split time to UTC time.</I></P>
<P>Convert <i>Time</i> in Epoch seconds (defaults to current time) to UTC time components.<br>Result is: (<i>Year</i>, <i>Month</i>, <i>Day</i>, <i>Hour</i>, <i>Min</i>, <i>Sec</i>, <i>Weekday</i>, <i>Yearday</i>, <i>isDST</i>).</P>
<P><I>See also: </I>[ <B><a href="#_time">time</a></B> | <B><a href="#_local_time">local_time</a></B> ]</P>
<!-- ../src/E_System.cpp:731 -->

<HR /><a name="_86"></a>
<P><font size=+1 color=red>= <B>V</B> =</font></P>
<HR />
<a name="_void"></a>
<P><font face=Arial size=+1 color=#808080><B>void</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Eval">Eval</a></b> | <b><a href="AWL_Categories.htm#_Unary">Unary</a></b> ]</LI>
<LI type=disc><B>void </B> (<i>X</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; ().</LI>
<P><I>Evaluate as void.</I></P>
<P>Void evaluation of expression <i>X</i> (ignore returned value).</P>
<P></P>
<!-- ../src/E_Mut.cpp:686 -->

<HR /><a name="_87"></a>
<P><font size=+1 color=red>= <B>W</B> =</font></P>
<HR />
<a name="_while"></a>
<P><font face=Arial size=+1 color=#808080><B>while</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Iterator">Iterator</a></b> | <b><a href="AWL_Categories.htm#_Conditional">Conditional</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> ]</LI>
<LI type=disc><B>while </B> (@<i>Cond</i>: <b><a href="AWL_Types.htm#_Bool">Bool</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Iterator with positive precondition.</I></P>
<P>While boolean <i>Cond</i> remains <b>true</b>, repeatedly evaluates <i>Body</i>.<br>Returns final value of <i>Body</i> (or <b>undef</b>, if <i>Body</i> never was evaluated).</P>
<P><I>See also: </I>[ <B><a href="#_until">until</a></B> | <B><a href="#_do_while">do_while</a></B> | <B><a href="#_do_until">do_until</a></B> ]</P>
<!-- ../src/E_Control.cpp:415 -->

<HR />
<a name="_with"></a>
<P><font face=Arial size=+1 color=#808080><B>with</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>with </B> (<i>Instance</i>: <b><a href="AWL_Types.htm#_Object">Object</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Class current instance wrapper.</I></P>
<P>Evaluates and returns <i>Body</i>, with object <i>Instance</i> temporarily defined as current instance of own class (and its ancestors).</P>
<P><I>See also: </I>[ <B><a href="#_without">without</a></B> ]</P>
<!-- ../src/E_Object.cpp:402 -->

<HR />
<a name="_with_input"></a>
<P><font face=Arial size=+1 color=#808080><B>with_input</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>with_input </B> (<i>Input</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Default input stream wrapper.</I></P>
<P>Evaluates <i>Body</i>, with input stream <i>Input</i> defined as default input.</P>
<P><I>See also: </I>[ <B><a href="#_with_output">with_output</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1863 -->

<HR />
<a name="_with_output"></a>
<P><font face=Arial size=+1 color=#808080><B>with_output</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Stream">Stream</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>with_output </B> (<i>Output</i>: <b><a href="AWL_Types.htm#_Stream">Stream</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Default output stream wrapper.</I></P>
<P>Evaluates <i>Body</i>, with output stream <i>Output</i> defined as default output.</P>
<P><I>See also: </I>[ <B><a href="#_with_input">with_input</a></B> ]</P>
<!-- ../src/E_Stream.cpp:1868 -->

<HR />
<a name="_without"></a>
<P><font face=Arial size=+1 color=#808080><B>without</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Object">Object</a></b> | <b><a href="AWL_Categories.htm#_Wrapper">Wrapper</a></b> ]</LI>
<LI type=disc><B>without </B> (<i>Class</i>: <b><a href="AWL_Types.htm#_Class">Class</a></b>, @<i>Body</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Class deinstantiation wrapper.</I></P>
<P>Evaluates and returns <i>Body</i>, with tempoparily undefined current instance of class <i>Class</i>.</P>
<P><I>See also: </I>[ <B><a href="#_with">with</a></B> ]</P>
<!-- ../src/E_Object.cpp:409 -->

<HR /><a name="_88"></a>
<P><font size=+1 color=red>= <B>X</B> =</font></P>
<HR />
<a name="_x_funcs"></a>
<P><font face=Arial size=+1 color=#808080><B>x_funcs</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>x_funcs </B> ([<i>Scope</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Show scope functors/classes.</I></P>
<P>Lists all functors/classes, defined in <i>Scope</i> (belonging to user functor or class; defaults to module global scope).<br>Returns total # of functors/classes in scope.</P>
<P></P>
<!-- ../src/Kernel.cpp:1724 -->

<HR />
<a name="_x_trace"></a>
<P><font face=Arial size=+1 color=#808080><B>x_trace</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>x_trace </B> (<i>Mode</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b> [, <i>Expr</i>: <b><a href="AWL_Types.htm#_Any">Any</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Any">Any</a></b>.</LI>
<P><I>Debug local/global trace mode.</I></P>
<P>If expression <i>Expr</i> is defined: evaluates it, and outputs expression and/or result in trace mode <i>Mode</i>.<br>If expr is omitted: sets module trace mode to <i>Mode</i>.</P>
<P></P>
<!-- ../src/Kernel.cpp:1710 -->

<HR />
<a name="_x_vars"></a>
<P><font face=Arial size=+1 color=#808080><B>x_vars</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Debug">Debug</a></b> ]</LI>
<LI type=disc><B>x_vars </B> ([<i>Scope</i>: <b><a href="AWL_Types.htm#_Func">Func</a></b>]) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Show scope variables.</I></P>
<P>Lists all variables, defined in <i>Scope</i> (belonging to user functor or class; defaults to module global scope).<br>Returns total # of variables in scope.</P>
<P></P>
<!-- ../src/Kernel.cpp:1718 -->

<HR />
<a name="_xor"></a>
<P><font face=Arial size=+1 color=#808080><B>xor</B></font></P>
<LI type=square>[ <b><a href="AWL_Categories.htm#_Scalar">Scalar</a></b> | <b><a href="AWL_Categories.htm#_Binary">Binary</a></b> | <b><a href="AWL_Categories.htm#_Numeric">Numeric</a></b> ]</LI>
<LI type=disc><B>xor </B> (<i>I</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>, <i>J</i>: <b><a href="AWL_Types.htm#_Int">Int</a></b>) &#8658; <b><a href="AWL_Types.htm#_Int">Int</a></b>.</LI>
<P><I>Bitwise exclusion.</I></P>
<P>Bitwise exclusive OR of arguments <i>I</i> and <i>J</i>.<br>Syntax: <i>I</i> ~ <i>J</i>.</P>
<P><I>See also: </I>[ <B><a href="#_and">and</a></B> | <B><a href="#_or">or</a></B> ]</P>
<!-- ../src/E_Num.cpp:1085 -->

<HR />
<P>Total functors: <B>386</B>.</P>
</BODY>
</HTML>