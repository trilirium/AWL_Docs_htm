<HTML>
<HEAD>
<TITLE>List of categories</TITLE>
</HEAD>
<BODY>
<CENTER>Version: <B>0.8.0</B>.</CENTER>
<CENTER>[ <A href=AWL_Functors.htm><B>Functors</B></A> | <A href=AWL_Categories.htm><B>Categories</B></A> | <A href=AWL_Types.htm><B>Metatypes</B></A> | <A href=AWL_Syntax.htm><B>Syntax</B></A> ]</CENTER>
<H2>List of categories
</H2>
<a name="_Array"></a>
<P><font face=Arial size=+1 color=#808080><B>Array</B></font></P>
<P><I>Array functors</I></P>
<P>Functors, operating on arrays.</P>
<P>[Total <B>16</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_copy">a_copy</a></B>: <I>Copy array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_delete">a_delete</a></B>: <I>Delete elements block from array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_dims">a_dims</a></B>: <I>Array dimensions.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_elem">a_elem</a></B>: <I>Array element accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_fill">a_fill</a></B>: <I>Fill array with value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_init_all">a_init_all</a></B>: <I>Array functional initializer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_insert">a_insert</a></B>: <I>Insert elements block into array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_load">a_load</a></B>: <I>Load array elements from list of values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_loop">a_loop</a></B>: <I>Array iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_rank">a_rank</a></B>: <I>Array rank.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_reshape">a_reshape</a></B>: <I>Reshape array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_save">a_save</a></B>: <I>Save array elements to list of values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_total">a_total</a></B>: <I>Total elements in array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_array">array</a></B>: <I>Array constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_array">expect_array</a></B>: <I>Expect array value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_array">is_array</a></B>: <I>Check for array value.</I></LI>
</UL>
<!-- ../src/E_Array.cpp:1308 -->

<HR />
<a name="_Binary"></a>
<P><font face=Arial size=+1 color=#808080><B>Binary</B></font></P>
<P><I>Binary functors</I></P>
<P>Functors, expecting two arguments.</P>
<P>[Total <B>46</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_add">add</a></B>: <I>Numeric addition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_and">and</a></B>: <I>Bitwise conjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ang">ang</a></B>: <I>Numeric polar angle.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_and">c_and</a></B>: <I>Conditional short-circuit "AND" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_or">c_or</a></B>: <I>Conditional short-circuit "OR" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_comb">comb</a></B>: <I>Implements combined assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_differ">differ</a></B>: <I>Test for difference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_div">div</a></B>: <I>Numeric division.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_until">do_until</a></B>: <I>Iterator with negative postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_while">do_while</a></B>: <I>Iterator with positive postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp_by">exp_by</a></B>: <I>Numeric rise to power.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ident">ident</a></B>: <I>Test for identity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_idiv">idiv</a></B>: <I>Integer ratio.</I></LI>
<LI><B><a href="AWL_Functors.htm#_irem">irem</a></B>: <I>Integer remainder.</I></LI>
<LI><B><a href="AWL_Functors.htm#_let">let</a></B>: <I>"Lazy" assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log_by">log_by</a></B>: <I>Numeric logarithm by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_max">max</a></B>: <I>Numeric maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_min">min</a></B>: <I>Numeric minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_mul">mul</a></B>: <I>Numeric multiplication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_float">n_float</a></B>: <I>Parse string as float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_or">or</a></B>: <I>Bitwise disjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rad">rad</a></B>: <I>Numeric polar radius.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rdiv">rdiv</a></B>: <I>Integer ratio alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rrem">rrem</a></B>: <I>Integer remainder alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cat">s_cat</a></B>: <I>String concatenation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_efloat">s_efloat</a></B>: <I>Convert float to string (E-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ffloat">s_ffloat</a></B>: <I>Convert float to string (F-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findfirst">s_findfirst</a></B>: <I>Search string forward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findlast">s_findlast</a></B>: <I>Search string backward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_gfloat">s_gfloat</a></B>: <I>Convert float to string (G-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_max">s_max</a></B>: <I>String maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_min">s_min</a></B>: <I>String minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rep">s_rep</a></B>: <I>String replication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_retype">s_retype</a></B>: <I>Convert string to different type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_slice">s_slice</a></B>: <I>String slice.</I></LI>
<LI><B><a href="AWL_Functors.htm#_set">set</a></B>: <I>Eager assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shl">shl</a></B>: <I>Bitwise shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shr">shr</a></B>: <I>Bitwise shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sll">sll</a></B>: <I>Bitwise logical shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_slr">slr</a></B>: <I>Bitwise logical shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sub">sub</a></B>: <I>Numeric subtraction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_swap">swap</a></B>: <I>Exchange values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_times">times</a></B>: <I>Fixed count iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_until">until</a></B>: <I>Iterator with negative precondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_while">while</a></B>: <I>Iterator with positive precondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_xor">xor</a></B>: <I>Bitwise exclusion.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1701 -->

<HR />
<a name="_Block"></a>
<P><font face=Arial size=+1 color=#808080><B>Block</B></font></P>
<P><I>Block functors</I></P>
<P>Functors, operating on blocks.</P>
<P>[Total <B>2</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_deblock">deblock</a></B>: <I>Deconstruct block to item list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_enblock">enblock</a></B>: <I>Construct block from item list.</I></LI>
</UL>
<!-- ../src/E_Func.cpp:612 -->

<HR />
<a name="_Character"></a>
<P><font face=Arial size=+1 color=#808080><B>Character</B></font></P>
<P><I>Character functors</I></P>
<P>Functors, operating on character codes.</P>
<P>[Total <B>7</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cc_alpha">cc_alpha</a></B>: <I>Check code for any letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_blank">cc_blank</a></B>: <I>Check code for blank character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_digit">cc_digit</a></B>: <I>Check code for decimal digit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_lower">cc_lower</a></B>: <I>Check code for lowercase letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_odigit">cc_odigit</a></B>: <I>Check code for octal digit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_upper">cc_upper</a></B>: <I>Check code for uppercase letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_xdigit">cc_xdigit</a></B>: <I>Check code for hex digit.</I></LI>
</UL>
<!-- ../src/E_String.cpp:2247 -->

<HR />
<a name="_Codec"></a>
<P><font face=Arial size=+1 color=#808080><B>Codec</B></font></P>
<P><I>Codec related functors</I></P>
<P>Input/output codec functors.</P>
<P>[Total <B>8</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_codec_SMBC">codec_SMBC</a></B>: <I>SMBC codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF16">codec_UTF16</a></B>: <I>UTF-16 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF32">codec_UTF32</a></B>: <I>UTF-32 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF8">codec_UTF8</a></B>: <I>UTF-8 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_codepage">codec_codepage</a></B>: <I>Code page codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_hexdump">codec_hexdump</a></B>: <I>Hexdump codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_decode">s_decode</a></B>: <I>Decode cooked string with codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_encode">s_encode</a></B>: <I>Encode raw string with codec.</I></LI>
</UL>
<!-- ../src/E_Stream.cpp:1656 -->

<HR />
<a name="_Coercion"></a>
<P><font face=Arial size=+1 color=#808080><B>Coercion</B></font></P>
<P><I>Coercion functors</I></P>
<P>Scalar coercion unary functors.</P>
<P>[Total <B>4</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_float">float</a></B>: <I>Coerce scalar to float.</I></LI>
<LI><B><a href="AWL_Functors.htm#_int">int</a></B>: <I>Coerce scalar to integer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_num">num</a></B>: <I>Coerce scalar to number.</I></LI>
<LI><B><a href="AWL_Functors.htm#_string">string</a></B>: <I>Coerce scalar to string.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1709 -->

<HR />
<a name="_Compare"></a>
<P><font face=Arial size=+1 color=#808080><B>Compare</B></font></P>
<P><I>Comparator functors</I></P>
<P>Functors, performing ordered compare (returning sign value).</P>
<P>[Total <B>3</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cmp">cmp</a></B>: <I>Numeric signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cmp">s_cmp</a></B>: <I>String signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_u_cmp">u_cmp</a></B>: <I>Numeric unsigned comparison.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1713 -->

<HR />
<a name="_Composer"></a>
<P><font face=Arial size=+1 color=#808080><B>Composer</B></font></P>
<P><I>Functional composers</I></P>
<P>Functors, constructing and returning functors.</P>
<P>[Total <B>7</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cc_excl">cc_excl</a></B>: <I>Charset predicate exclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_incl">cc_incl</a></B>: <I>Charset predicate inclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_closure">closure</a></B>: <I>Closure constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_and">f_and</a></B>: <I>Functional "AND" predicates composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_compose">f_compose</a></B>: <I>Functional composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_not">f_not</a></B>: <I>Functional "NOT" predicate composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_or">f_or</a></B>: <I>Functional "OR" predicates composition.</I></LI>
</UL>
<!-- ../src/E_Func.cpp:620 -->

<HR />
<a name="_Conditional"></a>
<P><font face=Arial size=+1 color=#808080><B>Conditional</B></font></P>
<P><I>Conditional functors</I></P>
<P>Functors with conditional evaluation of some argument(s).</P>
<P>[Total <B>18</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_assert">assert</a></B>: <I>Assertion check.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_and">c_and</a></B>: <I>Conditional short-circuit "AND" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_not">c_not</a></B>: <I>Conditional "NOT" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_or">c_or</a></B>: <I>Conditional short-circuit "OR" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_excl">cc_excl</a></B>: <I>Charset predicate exclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_incl">cc_incl</a></B>: <I>Charset predicate inclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_until">do_until</a></B>: <I>Iterator with negative postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_while">do_while</a></B>: <I>Iterator with positive postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_and">f_and</a></B>: <I>Functional "AND" predicates composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_not">f_not</a></B>: <I>Functional "NOT" predicate composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_or">f_or</a></B>: <I>Functional "OR" predicates composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_false">false</a></B>: <I>Literal false value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_if">if</a></B>: <I>Conditional positive test.</I></LI>
<LI><B><a href="AWL_Functors.htm#_switch">switch</a></B>: <I>Choose action by key.</I></LI>
<LI><B><a href="AWL_Functors.htm#_true">true</a></B>: <I>Literal true value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_unless">unless</a></B>: <I>Conditional negative test.</I></LI>
<LI><B><a href="AWL_Functors.htm#_until">until</a></B>: <I>Iterator with negative precondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_while">while</a></B>: <I>Iterator with positive precondition.</I></LI>
</UL>
<!-- ../src/E_Control.cpp:326 -->

<HR />
<a name="_Constructor"></a>
<P><font face=Arial size=+1 color=#808080><B>Constructor</B></font></P>
<P><I>Constructor functors</I></P>
<P>Functors, creating instances of complex types.</P>
<P>[Total <B>38</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_copy">a_copy</a></B>: <I>Copy array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_array">array</a></B>: <I>Array constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_SMBC">codec_SMBC</a></B>: <I>SMBC codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF16">codec_UTF16</a></B>: <I>UTF-16 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF32">codec_UTF32</a></B>: <I>UTF-32 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_UTF8">codec_UTF8</a></B>: <I>UTF-8 codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_codepage">codec_codepage</a></B>: <I>Code page codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_codec_hexdump">codec_hexdump</a></B>: <I>Hexdump codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_create">f_create</a></B>: <I>Open file as stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_open">f_open</a></B>: <I>Open file as stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_hash">hash</a></B>: <I>Hash constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list">r_list</a></B>: <I>Convert ring to open list (in direct order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list_r">r_list_r</a></B>: <I>Convert ring to list (in reverse order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_ring">ring</a></B>: <I>Create ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_after_ex">rx_after_ex</a></B>: <I>Character predicate sequence end (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_after_in">rx_after_in</a></B>: <I>Character predicate sequence end (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_alt">rx_alt</a></B>: <I>Alternation of patterns.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any">rx_any</a></B>: <I>Any character pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any_ex">rx_any_ex</a></B>: <I>Character predicate check (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any_in">rx_any_in</a></B>: <I>Character predicate check (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_at_end">rx_at_end</a></B>: <I>End position anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_at_start">rx_at_start</a></B>: <I>Start position anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_before_ex">rx_before_ex</a></B>: <I>Character predicate sequence start (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_before_in">rx_before_in</a></B>: <I>Character predicate sequence start (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_cat">rx_cat</a></B>: <I>Concatenation of patterns.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_char">rx_char</a></B>: <I>Literal character pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_fail">rx_fail</a></B>: <I>Failure pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_is_after">rx_is_after</a></B>: <I>Look-after positive assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_is_before">rx_is_before</a></B>: <I>Look-before positive assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_not_after">rx_not_after</a></B>: <I>Look-after negative assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_not_before">rx_not_before</a></B>: <I>Look-before negative assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_null">rx_null</a></B>: <I>Null pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_recall">rx_recall</a></B>: <I>Register recall pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_rep">rx_rep</a></B>: <I>Repetition of pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_store">rx_store</a></B>: <I>Register store pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_store_to">rx_store_to</a></B>: <I>Register store pattern (with storage mutable).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_string">rx_string</a></B>: <I>Literal string pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_create">s_create</a></B>: <I>String constructor.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1717 -->

<HR />
<a name="_Debug"></a>
<P><font face=Arial size=+1 color=#808080><B>Debug</B></font></P>
<P><I>Debugging functors</I></P>
<P>Functors for debugging/tracing.</P>
<P>[Total <B>6</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_eval_r">eval_r</a></B>: <I>R-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_v">eval_v</a></B>: <I>V-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_x">eval_x</a></B>: <I>X-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_x_funcs">x_funcs</a></B>: <I>Show scope functors/classes.</I></LI>
<LI><B><a href="AWL_Functors.htm#_x_trace">x_trace</a></B>: <I>Debug local/global trace mode.</I></LI>
<LI><B><a href="AWL_Functors.htm#_x_vars">x_vars</a></B>: <I>Show scope variables.</I></LI>
</UL>
<!-- ../src/Kernel.cpp:1700 -->

<HR />
<a name="_Decoder"></a>
<P><font face=Arial size=+1 color=#808080><B>Decoder</B></font></P>
<P><I>Decoding functors</I></P>
<P>Functors, converting strings to numeric values.</P>
<P>[Total <B>5</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_dc_b">dc_b</a></B>: <I>Decode unsigned byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_l">dc_l</a></B>: <I>Decode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sb">dc_sb</a></B>: <I>Decode signed byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sw">dc_sw</a></B>: <I>Decode signed word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_w">dc_w</a></B>: <I>Decode unsigned word.</I></LI>
</UL>
<!-- ../src/E_String.cpp:2255 -->

<HR />
<a name="_Destructor"></a>
<P><font face=Arial size=+1 color=#808080><B>Destructor</B></font></P>
<P><I>Destructor functors</I></P>
<P>Functors, destroying instances of complex types.</P>
<P>[Total <B>1</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_f_close">f_close</a></B>: <I>Close opened stream.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1721 -->

<HR />
<a name="_Encoder"></a>
<P><font face=Arial size=+1 color=#808080><B>Encoder</B></font></P>
<P><I>Encoding functors</I></P>
<P>Functors, converting numeric values to strings.</P>
<P>[Total <B>3</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_ec_b">ec_b</a></B>: <I>Encode byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_l">ec_l</a></B>: <I>Encode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_w">ec_w</a></B>: <I>Encode word.</I></LI>
</UL>
<!-- ../src/E_String.cpp:2251 -->

<HR />
<a name="_Eval"></a>
<P><font face=Arial size=+1 color=#808080><B>Eval</B></font></P>
<P><I>Evaluators</I></P>
<P>Functors for specific argument(s) evaluation.</P>
<P>[Total <B>6</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_deval">deval</a></B>: <I>Expression devaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_r">eval_r</a></B>: <I>R-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_v">eval_v</a></B>: <I>V-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_x">eval_x</a></B>: <I>X-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_reval">reval</a></B>: <I>Expression revaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_void">void</a></B>: <I>Evaluate as void.</I></LI>
</UL>
<!-- ../src/E_Mut.cpp:521 -->

<HR />
<a name="_Exception"></a>
<P><font face=Arial size=+1 color=#808080><B>Exception</B></font></P>
<P><I>Exceptions processing</I></P>
<P>Functors, responsible for raising and handling exceptions.</P>
<P>[Total <B>4</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_return">return</a></B>: <I>Return from functor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_throw">throw</a></B>: <I>Throw exception.</I></LI>
<LI><B><a href="AWL_Functors.htm#_try">try</a></B>: <I>Exception frame wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_try_catch">try_catch</a></B>: <I>Exception frame wrapper.</I></LI>
</UL>
<!-- ../src/E_Xcpt.cpp:178 -->

<HR />
<a name="_Func"></a>
<P><font face=Arial size=+1 color=#808080><B>Func</B></font></P>
<P><I>Functional operations</I></P>
<P>Functors, expecting functors as operand(s).</P>
<P>[Total <B>20</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_apply">apply</a></B>: <I>Apply functor to argument(s).</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_excl">cc_excl</a></B>: <I>Charset predicate exclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_incl">cc_incl</a></B>: <I>Charset predicate inclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_closure">closure</a></B>: <I>Closure constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_and">f_and</a></B>: <I>Functional "AND" predicates composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_compose">f_compose</a></B>: <I>Functional composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_ident">f_ident</a></B>: <I>Identity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_not">f_not</a></B>: <I>Functional "NOT" predicate composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_or">f_or</a></B>: <I>Functional "OR" predicates composition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_cmp">l_cmp</a></B>: <I>Compare lists of ordered elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_count_ex">l_count_ex</a></B>: <I>Count list items exclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_count_in">l_count_in</a></B>: <I>Count list items inclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_filter_ex">l_filter_ex</a></B>: <I>Filter list exclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_filter_in">l_filter_in</a></B>: <I>Filter list inclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_map">l_map</a></B>: <I>Functional list mapping.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_sort_index">l_sort_index</a></B>: <I>Build sorted index.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_until">l_until</a></B>: <I>Search list forward, negatively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_until_r">l_until_r</a></B>: <I>Search list backward, negatively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_while">l_while</a></B>: <I>Search list forward, positively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_while_r">l_while_r</a></B>: <I>Search list backward, positively testing predicate.</I></LI>
</UL>
<!-- ../src/E_Func.cpp:616 -->

<HR />
<a name="_Hash"></a>
<P><font face=Arial size=+1 color=#808080><B>Hash</B></font></P>
<P><I>Hash functors</I></P>
<P>Functors, operating on hashes.</P>
<P>[Total <B>16</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_expect_hash">expect_hash</a></B>: <I>Expect hash value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_clear">h_clear</a></B>: <I>Clear hash.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_count">h_count</a></B>: <I>Hash counter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_elem">h_elem</a></B>: <I>Hash value accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_exists">h_exists</a></B>: <I>Check key for presence in hash.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_inspect">h_inspect</a></B>: <I>Inspect hash internal allocation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_keys">h_keys</a></B>: <I>List of hash keys.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_load">h_load</a></B>: <I>Load hash with list of elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_lookup">h_lookup</a></B>: <I>Hash value lookup.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_loop">h_loop</a></B>: <I>Hash iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_rehash">h_rehash</a></B>: <I>Change hash capacity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_remove">h_remove</a></B>: <I>Hash value remove.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_save">h_save</a></B>: <I>List of hash elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_values">h_values</a></B>: <I>List of hash values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_hash">hash</a></B>: <I>Hash constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_hash">is_hash</a></B>: <I>Check for hash value.</I></LI>
</UL>
<!-- ../src/E_Hash.cpp:745 -->

<HR />
<a name="_Iterator"></a>
<P><font face=Arial size=+1 color=#808080><B>Iterator</B></font></P>
<P><I>Iterator functors</I></P>
<P>Functors with repeated evaluation of some argument(s).</P>
<P>[Total <B>17</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_loop">a_loop</a></B>: <I>Array iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dir_loop">dir_loop</a></B>: <I>Directory iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_until">do_until</a></B>: <I>Iterator with negative postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_do_while">do_while</a></B>: <I>Iterator with positive postcondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ever">ever</a></B>: <I>Iterate forever.</I></LI>
<LI><B><a href="AWL_Functors.htm#_for_dec">for_dec</a></B>: <I>Decremental range iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_for_inc">for_inc</a></B>: <I>Incremental range iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_loop">h_loop</a></B>: <I>Hash iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_loop">l_loop</a></B>: <I>Direct order list iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_loop_r">l_loop_r</a></B>: <I>Reverse order list iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_loop">r_loop</a></B>: <I>Iterate forward through ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_loop_r">r_loop_r</a></B>: <I>Iterate backward through ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_loop">s_loop</a></B>: <I>String direct iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_loop_r">s_loop_r</a></B>: <I>String reverse iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_times">times</a></B>: <I>Fixed count iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_until">until</a></B>: <I>Iterator with negative precondition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_while">while</a></B>: <I>Iterator with positive precondition.</I></LI>
</UL>
<!-- ../src/E_Control.cpp:330 -->

<HR />
<a name="_List"></a>
<P><font face=Arial size=+1 color=#808080><B>List</B></font></P>
<P><I>List functors</I></P>
<P>Functors, operating on lists.</P>
<P>[Total <B>44</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_load">a_load</a></B>: <I>Load array elements from list of values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_save">a_save</a></B>: <I>Save array elements to list of values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_list">expect_list</a></B>: <I>Expect list value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_keys">h_keys</a></B>: <I>List of hash keys.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_load">h_load</a></B>: <I>Load hash with list of elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_save">h_save</a></B>: <I>List of hash elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_values">h_values</a></B>: <I>List of hash values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_list">is_list</a></B>: <I>Check for list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_cat">l_cat</a></B>: <I>List concatenation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_cmp">l_cmp</a></B>: <I>Compare lists of ordered elements.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_copy">l_copy</a></B>: <I>List copying.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_count_ex">l_count_ex</a></B>: <I>Count list items exclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_count_in">l_count_in</a></B>: <I>Count list items inclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_filter_ex">l_filter_ex</a></B>: <I>Filter list exclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_filter_in">l_filter_in</a></B>: <I>Filter list inclusively.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_head">l_head</a></B>: <I>List head accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_head_by">l_head_by</a></B>: <I>Head of list, with offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_item">l_item</a></B>: <I>List element accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_len">l_len</a></B>: <I>Length of list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_loop">l_loop</a></B>: <I>Direct order list iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_loop_r">l_loop_r</a></B>: <I>Reverse order list iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_map">l_map</a></B>: <I>Functional list mapping.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_pop">l_pop</a></B>: <I>Pop elements from list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_push">l_push</a></B>: <I>Push elements to list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_range">l_range</a></B>: <I>Convert range to incremental list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_range_r">l_range_r</a></B>: <I>Convert range to decremental list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_ref">l_ref</a></B>: <I>List reference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_rep">l_rep</a></B>: <I>List replication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_resize">l_resize</a></B>: <I>Resize list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_rev">l_rev</a></B>: <I>List reversion.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_sort_index">l_sort_index</a></B>: <I>Build sorted index.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_sort_mutator">l_sort_mutator</a></B>: <I>Sorting in place.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_split">l_split</a></B>: <I>Split list at specified position.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_tail">l_tail</a></B>: <I>List tail accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_tail_by">l_tail_by</a></B>: <I>Tail of list, with offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_until">l_until</a></B>: <I>Search list forward, negatively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_until_r">l_until_r</a></B>: <I>Search list backward, negatively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_while">l_while</a></B>: <I>Search list forward, positively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_while_r">l_while_r</a></B>: <I>Search list backward, positively testing predicate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_zip">l_zip</a></B>: <I>Zip lists.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list">r_list</a></B>: <I>Convert ring to open list (in direct order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list_r">r_list_r</a></B>: <I>Convert ring to list (in reverse order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_range">range</a></B>: <I>Range by offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_reduce">reduce</a></B>: <I>Implements list reduction.</I></LI>
</UL>
<!-- ../src/E_List.cpp:1112 -->

<HR />
<a name="_Meta"></a>
<P><font face=Arial size=+1 color=#808080><B>Meta</B></font></P>
<P><I>Meta-operations</I></P>
<P>Implicit meta-operations (expecting terms as operands).</P>
<P>[Total <B>2</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_comb">comb</a></B>: <I>Implements combined assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_reduce">reduce</a></B>: <I>Implements list reduction.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1729 -->

<HR />
<a name="_Mutable"></a>
<P><font face=Arial size=+1 color=#808080><B>Mutable</B></font></P>
<P><I>Mutable functors</I></P>
<P>Functors, returning mutable result.</P>
<P>[Total <B>8</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_elem">a_elem</a></B>: <I>Array element accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_elem">h_elem</a></B>: <I>Hash value accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_head">l_head</a></B>: <I>List head accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_head_by">l_head_by</a></B>: <I>Head of list, with offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_item">l_item</a></B>: <I>List element accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_tail">l_tail</a></B>: <I>List tail accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_tail_by">l_tail_by</a></B>: <I>Tail of list, with offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_elem">r_elem</a></B>: <I>Ring element accessor.</I></LI>
</UL>
<!-- ../src/E_Mut.cpp:525 -->

<HR />
<a name="_Mutator"></a>
<P><font face=Arial size=+1 color=#808080><B>Mutator</B></font></P>
<P><I>Mutator functors</I></P>
<P>Functors, changing value(s) of operands.</P>
<P>[Total <B>28</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_a_delete">a_delete</a></B>: <I>Delete elements block from array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_fill">a_fill</a></B>: <I>Fill array with value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_init_all">a_init_all</a></B>: <I>Array functional initializer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_insert">a_insert</a></B>: <I>Insert elements block into array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_load">a_load</a></B>: <I>Load array elements from list of values.</I></LI>
<LI><B><a href="AWL_Functors.htm#_a_reshape">a_reshape</a></B>: <I>Reshape array.</I></LI>
<LI><B><a href="AWL_Functors.htm#_clr">clr</a></B>: <I>Clear mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_comb">comb</a></B>: <I>Implements combined assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec">dec</a></B>: <I>Pre-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec_p">dec_p</a></B>: <I>Post-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_get">f_get</a></B>: <I>Get line(s) from stream (as strings).</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_remove">h_remove</a></B>: <I>Hash value remove.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc">inc</a></B>: <I>Pre-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc_p">inc_p</a></B>: <I>Post-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_pop">l_pop</a></B>: <I>Pop elements from list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_push">l_push</a></B>: <I>Push elements to list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_resize">l_resize</a></B>: <I>Resize list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_sort_mutator">l_sort_mutator</a></B>: <I>Sorting in place.</I></LI>
<LI><B><a href="AWL_Functors.htm#_l_split">l_split</a></B>: <I>Split list at specified position.</I></LI>
<LI><B><a href="AWL_Functors.htm#_let">let</a></B>: <I>"Lazy" assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_del">r_del</a></B>: <I>Remove ring start element.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_ins_after">r_ins_after</a></B>: <I>Insert element after start of ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_ins_before">r_ins_before</a></B>: <I>Insert element before start of ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_reverse">r_reverse</a></B>: <I>Reverse ring order.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_patch">s_patch</a></B>: <I>Replace fragment in string mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_poke">s_poke</a></B>: <I>Replace character in string mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_set">set</a></B>: <I>Eager assignment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_swap">swap</a></B>: <I>Exchange values.</I></LI>
</UL>
<!-- ../src/E_Mut.cpp:529 -->

<HR />
<a name="_Nullary"></a>
<P><font face=Arial size=+1 color=#808080><B>Nullary</B></font></P>
<P><I>Nullary functors</I></P>
<P>Functors, expecting no arguments.</P>
<P>[Total <B>11</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_f_err">f_err</a></B>: <I>Standard error output.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_in">f_in</a></B>: <I>Standard input.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_out">f_out</a></B>: <I>Standard output.</I></LI>
<LI><B><a href="AWL_Functors.htm#_false">false</a></B>: <I>Literal false value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inf_neg">inf_neg</a></B>: <I>Negative infinity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inf_pos">inf_pos</a></B>: <I>Positive infinity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_max_int">max_int</a></B>: <I>Integer maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_min_int">min_int</a></B>: <I>Integer minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_nan">nan</a></B>: <I>Not a number.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_empty">s_empty</a></B>: <I>Empty string literal.</I></LI>
<LI><B><a href="AWL_Functors.htm#_true">true</a></B>: <I>Literal true value.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1693 -->

<HR />
<a name="_Numeric"></a>
<P><font face=Arial size=+1 color=#808080><B>Numeric</B></font></P>
<P><I>Numeric functors</I></P>
<P>Functors, operating on numeric values.</P>
<P>[Total <B>78</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_abs">abs</a></B>: <I>Numeric absolute value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_acos">acos</a></B>: <I>Trigonometric arccosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_add">add</a></B>: <I>Numeric addition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_and">and</a></B>: <I>Bitwise conjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ang">ang</a></B>: <I>Numeric polar angle.</I></LI>
<LI><B><a href="AWL_Functors.htm#_asin">asin</a></B>: <I>Trigonometric arcsine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_atan">atan</a></B>: <I>Trigonometric arctangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_count">bitclr_count</a></B>: <I>Count all clear bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_hi">bitclr_hi</a></B>: <I>Locate highest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_lo">bitclr_lo</a></B>: <I>Locate lowest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitrev">bitrev</a></B>: <I>Reverse bits order.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_count">bitset_count</a></B>: <I>Count all set bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_hi">bitset_hi</a></B>: <I>Locate highest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_lo">bitset_lo</a></B>: <I>Locate lowest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ceil">ceil</a></B>: <I>Numeric rounding up.</I></LI>
<LI><B><a href="AWL_Functors.htm#_clr">clr</a></B>: <I>Clear mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cmp">cmp</a></B>: <I>Numeric signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cos">cos</a></B>: <I>Trigonometric cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cosh">cosh</a></B>: <I>Numeric hyperbolic cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec">dec</a></B>: <I>Pre-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec_p">dec_p</a></B>: <I>Post-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_div">div</a></B>: <I>Numeric division.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eq">eq</a></B>: <I>Numeric equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp">exp</a></B>: <I>Numeric exponentiation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp_by">exp_by</a></B>: <I>Numeric rise to power.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_float">expect_float</a></B>: <I>Expect float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_int">expect_int</a></B>: <I>Expect integer value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_float">float</a></B>: <I>Coerce scalar to float.</I></LI>
<LI><B><a href="AWL_Functors.htm#_floor">floor</a></B>: <I>Numeric rounding down.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ge">ge</a></B>: <I>Numeric "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_gt">gt</a></B>: <I>Numeric "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_idiv">idiv</a></B>: <I>Integer ratio.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc">inc</a></B>: <I>Pre-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc_p">inc_p</a></B>: <I>Post-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inf_neg">inf_neg</a></B>: <I>Negative infinity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inf_pos">inf_pos</a></B>: <I>Positive infinity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inside">inside</a></B>: <I>Check for value inclusion in range.</I></LI>
<LI><B><a href="AWL_Functors.htm#_int">int</a></B>: <I>Coerce scalar to integer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_irem">irem</a></B>: <I>Integer remainder.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_float">is_float</a></B>: <I>Check for float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_int">is_int</a></B>: <I>Check for integer value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_num">is_num</a></B>: <I>Check for numeric value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_le">le</a></B>: <I>Numeric "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log">log</a></B>: <I>Numeric logarithm.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log_by">log_by</a></B>: <I>Numeric logarithm by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_lt">lt</a></B>: <I>Numeric "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_max">max</a></B>: <I>Numeric maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_max_int">max_int</a></B>: <I>Integer maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_min">min</a></B>: <I>Numeric minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_min_int">min_int</a></B>: <I>Integer minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_mul">mul</a></B>: <I>Numeric multiplication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_nan">nan</a></B>: <I>Not a number.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ne">ne</a></B>: <I>Numeric inequality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_neg">neg</a></B>: <I>Numeric negation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_not">not</a></B>: <I>Bitwise complement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_num">num</a></B>: <I>Coerce scalar to number.</I></LI>
<LI><B><a href="AWL_Functors.htm#_or">or</a></B>: <I>Bitwise disjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_outside">outside</a></B>: <I>Check for value exclusion from range.</I></LI>
<LI><B><a href="AWL_Functors.htm#_pi">pi</a></B>: <I>Multiply operand by \Pi.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rad">rad</a></B>: <I>Numeric polar radius.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rand">rand</a></B>: <I>Random numbers generator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_randomize">randomize</a></B>: <I>Randomization.</I></LI>
<LI><B><a href="AWL_Functors.htm#_range">range</a></B>: <I>Range by offset.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rdiv">rdiv</a></B>: <I>Integer ratio alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rrem">rrem</a></B>: <I>Integer remainder alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sgn">sgn</a></B>: <I>Numeric sign.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shl">shl</a></B>: <I>Bitwise shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shr">shr</a></B>: <I>Bitwise shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sin">sin</a></B>: <I>Trigonometric sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sinh">sinh</a></B>: <I>Numeric hyperbolic sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sll">sll</a></B>: <I>Bitwise logical shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_slr">slr</a></B>: <I>Bitwise logical shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sqr">sqr</a></B>: <I>Numeric square root.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sub">sub</a></B>: <I>Numeric subtraction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tan">tan</a></B>: <I>Trigonometric tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tanh">tanh</a></B>: <I>Numeric hyperbolic tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_u_cmp">u_cmp</a></B>: <I>Numeric unsigned comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_xor">xor</a></B>: <I>Bitwise exclusion.</I></LI>
</UL>
<!-- ../src/E_Num.cpp:719 -->

<HR />
<a name="_OS"></a>
<P><font face=Arial size=+1 color=#808080><B>OS</B></font></P>
<P><I>OS Interaction</I></P>
<P>OS Interaction.</P>
<P>[Total <B>14</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cons_time">cons_time</a></B>: <I>Construct time from list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dir_loop">dir_loop</a></B>: <I>Directory iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_access">f_access</a></B>: <I>Verify access to file.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_chdir">f_chdir</a></B>: <I>Change current directory.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_chmod">f_chmod</a></B>: <I>Change file access mode.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_mkdir">f_mkdir</a></B>: <I>Create new directory.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_remove">f_remove</a></B>: <I>Remove file permanently.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_rename">f_rename</a></B>: <I>Rename or move file.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_rmdir">f_rmdir</a></B>: <I>Remove old directory.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_stat">f_stat</a></B>: <I>Get file information.</I></LI>
<LI><B><a href="AWL_Functors.htm#_get_curdir">get_curdir</a></B>: <I>Get current directory.</I></LI>
<LI><B><a href="AWL_Functors.htm#_local_time">local_time</a></B>: <I>Split time to local time.</I></LI>
<LI><B><a href="AWL_Functors.htm#_time">time</a></B>: <I>Get system time.</I></LI>
<LI><B><a href="AWL_Functors.htm#_utc_time">utc_time</a></B>: <I>Split time to UTC time.</I></LI>
</UL>
<!-- ../src/E_System.cpp:629 -->

<HR />
<a name="_Object"></a>
<P><font face=Arial size=+1 color=#808080><B>Object</B></font></P>
<P><I>Object/class functors</I></P>
<P>Functors, operating on classes and/or class instances.</P>
<P>[Total <B>11</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_class_of">class_of</a></B>: <I>Retrieve class of object.</I></LI>
<LI><B><a href="AWL_Functors.htm#_devirt">devirt</a></B>: <I>Explicit devirtualization.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_object">expect_object</a></B>: <I>Expect object value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_class">is_class</a></B>: <I>Check for class reference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_object">is_object</a></B>: <I>Check for object value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_virtual">is_virtual</a></B>: <I>Check for virtual reference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_originator">originator</a></B>: <I>Originator of virtual method.</I></LI>
<LI><B><a href="AWL_Functors.htm#_self">self</a></B>: <I>Retrieve current class instance.</I></LI>
<LI><B><a href="AWL_Functors.htm#_super_of">super_of</a></B>: <I>Retrieve superclass of class.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with">with</a></B>: <I>Class current instance wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_without">without</a></B>: <I>Class deinstantiation wrapper.</I></LI>
</UL>
<!-- ../src/E_Object.cpp:323 -->

<HR />
<a name="_Pattern"></a>
<P><font face=Arial size=+1 color=#808080><B>Pattern</B></font></P>
<P><I>Pattern functors</I></P>
<P>Functors, operating on patterns.</P>
<P>[Total <B>32</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_expect_pattern">expect_pattern</a></B>: <I>Expect pattern value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_pattern">is_pattern</a></B>: <I>Check for pattern value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_after_ex">rx_after_ex</a></B>: <I>Character predicate sequence end (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_after_in">rx_after_in</a></B>: <I>Character predicate sequence end (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_alt">rx_alt</a></B>: <I>Alternation of patterns.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any">rx_any</a></B>: <I>Any character pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any_ex">rx_any_ex</a></B>: <I>Character predicate check (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_any_in">rx_any_in</a></B>: <I>Character predicate check (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_at_end">rx_at_end</a></B>: <I>End position anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_at_start">rx_at_start</a></B>: <I>Start position anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_before_ex">rx_before_ex</a></B>: <I>Character predicate sequence start (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_before_in">rx_before_in</a></B>: <I>Character predicate sequence start (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_cat">rx_cat</a></B>: <I>Concatenation of patterns.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_char">rx_char</a></B>: <I>Literal character pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_fail">rx_fail</a></B>: <I>Failure pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_findfirst">rx_findfirst</a></B>: <I>Search forward for pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_findlast">rx_findlast</a></B>: <I>Search backward for pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_is_after">rx_is_after</a></B>: <I>Look-after positive assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_is_before">rx_is_before</a></B>: <I>Look-before positive assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_length">rx_length</a></B>: <I>Calculate length range of pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_locate">rx_locate</a></B>: <I>Locate set of patterns in string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_match">rx_match</a></B>: <I>Pattern matching.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_not_after">rx_not_after</a></B>: <I>Look-after negative assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_not_before">rx_not_before</a></B>: <I>Look-before negative assertion anchor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_null">rx_null</a></B>: <I>Null pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_recall">rx_recall</a></B>: <I>Register recall pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_rep">rx_rep</a></B>: <I>Repetition of pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_replace">rx_replace</a></B>: <I>Replace set of patterns in string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_split">rx_split</a></B>: <I>Split string by pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_store">rx_store</a></B>: <I>Register store pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_store_to">rx_store_to</a></B>: <I>Register store pattern (with storage mutable).</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_string">rx_string</a></B>: <I>Literal string pattern.</I></LI>
</UL>
<!-- ../src/E_Pattern.cpp:2302 -->

<HR />
<a name="_Predicate"></a>
<P><font face=Arial size=+1 color=#808080><B>Predicate</B></font></P>
<P><I>Predicate functors</I></P>
<P>Functors, returning boolean values.</P>
<P>[Total <B>44</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cc_alpha">cc_alpha</a></B>: <I>Check code for any letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_blank">cc_blank</a></B>: <I>Check code for blank character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_digit">cc_digit</a></B>: <I>Check code for decimal digit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_lower">cc_lower</a></B>: <I>Check code for lowercase letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_odigit">cc_odigit</a></B>: <I>Check code for octal digit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_upper">cc_upper</a></B>: <I>Check code for uppercase letter.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_xdigit">cc_xdigit</a></B>: <I>Check code for hex digit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_differ">differ</a></B>: <I>Test for difference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eq">eq</a></B>: <I>Numeric equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_at_end">f_at_end</a></B>: <I>Check for end of stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_is_console">f_is_console</a></B>: <I>Check for console device.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ge">ge</a></B>: <I>Numeric "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_gt">gt</a></B>: <I>Numeric "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_h_exists">h_exists</a></B>: <I>Check key for presence in hash.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ident">ident</a></B>: <I>Test for identity.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inside">inside</a></B>: <I>Check for value inclusion in range.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_array">is_array</a></B>: <I>Check for array value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_block">is_block</a></B>: <I>Check for block.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_class">is_class</a></B>: <I>Check for class reference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_float">is_float</a></B>: <I>Check for float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_func">is_func</a></B>: <I>Check for functor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_hash">is_hash</a></B>: <I>Check for hash value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_int">is_int</a></B>: <I>Check for integer value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_list">is_list</a></B>: <I>Check for list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_mut">is_mut</a></B>: <I>Check mutability.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_num">is_num</a></B>: <I>Check for numeric value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_object">is_object</a></B>: <I>Check for object value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_pattern">is_pattern</a></B>: <I>Check for pattern value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_stream">is_stream</a></B>: <I>Check for stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_string">is_string</a></B>: <I>Check for string value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_term">is_term</a></B>: <I>Check for term.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_undef">is_undef</a></B>: <I>Check for undefined value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_var">is_var</a></B>: <I>Check for variable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_virtual">is_virtual</a></B>: <I>Check for virtual reference.</I></LI>
<LI><B><a href="AWL_Functors.htm#_le">le</a></B>: <I>Numeric "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_lt">lt</a></B>: <I>Numeric "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ne">ne</a></B>: <I>Numeric inequality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_outside">outside</a></B>: <I>Check for value exclusion from range.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_eq">s_eq</a></B>: <I>String equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ge">s_ge</a></B>: <I>String "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_gt">s_gt</a></B>: <I>String "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_le">s_le</a></B>: <I>String "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lt">s_lt</a></B>: <I>String "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ne">s_ne</a></B>: <I>String inequality.</I></LI>
</UL>
<!-- ../src/E_Control.cpp:322 -->

<HR />
<a name="_Ring"></a>
<P><font face=Arial size=+1 color=#808080><B>Ring</B></font></P>
<P><I>Ring operations</I></P>
<P>Functors, operating on rings.</P>
<P>[Total <B>13</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_r_count">r_count</a></B>: <I>Count elements in ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_del">r_del</a></B>: <I>Remove ring start element.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_elem">r_elem</a></B>: <I>Ring element accessor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_ins_after">r_ins_after</a></B>: <I>Insert element after start of ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_ins_before">r_ins_before</a></B>: <I>Insert element before start of ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list">r_list</a></B>: <I>Convert ring to open list (in direct order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_list_r">r_list_r</a></B>: <I>Convert ring to list (in reverse order).</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_loop">r_loop</a></B>: <I>Iterate forward through ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_loop_r">r_loop_r</a></B>: <I>Iterate backward through ring.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_reverse">r_reverse</a></B>: <I>Reverse ring order.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_seek">r_seek</a></B>: <I>Seek ring cyclically forward.</I></LI>
<LI><B><a href="AWL_Functors.htm#_r_seek_r">r_seek_r</a></B>: <I>Seek ring cyclically backward.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ring">ring</a></B>: <I>Create ring.</I></LI>
</UL>
<!-- ../src/E_Ring.cpp:595 -->

<HR />
<a name="_Scalar"></a>
<P><font face=Arial size=+1 color=#808080><B>Scalar</B></font></P>
<P><I>Scalar functors</I></P>
<P>Functors, operating on scalar values.</P>
<P>[Total <B>81</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_abs">abs</a></B>: <I>Numeric absolute value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_acos">acos</a></B>: <I>Trigonometric arccosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_add">add</a></B>: <I>Numeric addition.</I></LI>
<LI><B><a href="AWL_Functors.htm#_and">and</a></B>: <I>Bitwise conjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ang">ang</a></B>: <I>Numeric polar angle.</I></LI>
<LI><B><a href="AWL_Functors.htm#_asin">asin</a></B>: <I>Trigonometric arcsine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_atan">atan</a></B>: <I>Trigonometric arctangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_count">bitclr_count</a></B>: <I>Count all clear bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_hi">bitclr_hi</a></B>: <I>Locate highest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_lo">bitclr_lo</a></B>: <I>Locate lowest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitrev">bitrev</a></B>: <I>Reverse bits order.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_count">bitset_count</a></B>: <I>Count all set bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_hi">bitset_hi</a></B>: <I>Locate highest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_lo">bitset_lo</a></B>: <I>Locate lowest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ceil">ceil</a></B>: <I>Numeric rounding up.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cmp">cmp</a></B>: <I>Numeric signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cos">cos</a></B>: <I>Trigonometric cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cosh">cosh</a></B>: <I>Numeric hyperbolic cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_div">div</a></B>: <I>Numeric division.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eq">eq</a></B>: <I>Numeric equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp">exp</a></B>: <I>Numeric exponentiation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp_by">exp_by</a></B>: <I>Numeric rise to power.</I></LI>
<LI><B><a href="AWL_Functors.htm#_false">false</a></B>: <I>Literal false value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_float">float</a></B>: <I>Coerce scalar to float.</I></LI>
<LI><B><a href="AWL_Functors.htm#_floor">floor</a></B>: <I>Numeric rounding down.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ge">ge</a></B>: <I>Numeric "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_gt">gt</a></B>: <I>Numeric "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_idiv">idiv</a></B>: <I>Integer ratio.</I></LI>
<LI><B><a href="AWL_Functors.htm#_int">int</a></B>: <I>Coerce scalar to integer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_irem">irem</a></B>: <I>Integer remainder.</I></LI>
<LI><B><a href="AWL_Functors.htm#_le">le</a></B>: <I>Numeric "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log">log</a></B>: <I>Numeric logarithm.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log_by">log_by</a></B>: <I>Numeric logarithm by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_lt">lt</a></B>: <I>Numeric "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_max">max</a></B>: <I>Numeric maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_min">min</a></B>: <I>Numeric minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_mul">mul</a></B>: <I>Numeric multiplication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ne">ne</a></B>: <I>Numeric inequality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_neg">neg</a></B>: <I>Numeric negation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_not">not</a></B>: <I>Bitwise complement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_num">num</a></B>: <I>Coerce scalar to number.</I></LI>
<LI><B><a href="AWL_Functors.htm#_or">or</a></B>: <I>Bitwise disjunction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_pi">pi</a></B>: <I>Multiply operand by \Pi.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rad">rad</a></B>: <I>Numeric polar radius.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rdiv">rdiv</a></B>: <I>Integer ratio alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rrem">rrem</a></B>: <I>Integer remainder alternate.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cat">s_cat</a></B>: <I>String concatenation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cmp">s_cmp</a></B>: <I>String signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_common_head">s_common_head</a></B>: <I>Common string head.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_common_tail">s_common_tail</a></B>: <I>Common string tail.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_empty">s_empty</a></B>: <I>Empty string literal.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_eq">s_eq</a></B>: <I>String equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findfirst">s_findfirst</a></B>: <I>Search string forward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findlast">s_findlast</a></B>: <I>Search string backward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ge">s_ge</a></B>: <I>String "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_gt">s_gt</a></B>: <I>String "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_le">s_le</a></B>: <I>String "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_len">s_len</a></B>: <I>Get string length.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lt">s_lt</a></B>: <I>String "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_max">s_max</a></B>: <I>String maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_min">s_min</a></B>: <I>String minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ne">s_ne</a></B>: <I>String inequality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rep">s_rep</a></B>: <I>String replication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_retype">s_retype</a></B>: <I>Convert string to different type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_slice">s_slice</a></B>: <I>String slice.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_type">s_type</a></B>: <I>Query string type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sgn">sgn</a></B>: <I>Numeric sign.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shl">shl</a></B>: <I>Bitwise shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_shr">shr</a></B>: <I>Bitwise shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sin">sin</a></B>: <I>Trigonometric sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sinh">sinh</a></B>: <I>Numeric hyperbolic sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sll">sll</a></B>: <I>Bitwise logical shift left.</I></LI>
<LI><B><a href="AWL_Functors.htm#_slr">slr</a></B>: <I>Bitwise logical shift right.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sqr">sqr</a></B>: <I>Numeric square root.</I></LI>
<LI><B><a href="AWL_Functors.htm#_string">string</a></B>: <I>Coerce scalar to string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sub">sub</a></B>: <I>Numeric subtraction.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tan">tan</a></B>: <I>Trigonometric tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tanh">tanh</a></B>: <I>Numeric hyperbolic tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_true">true</a></B>: <I>Literal true value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_u_cmp">u_cmp</a></B>: <I>Numeric unsigned comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_xor">xor</a></B>: <I>Bitwise exclusion.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1689 -->

<HR />
<a name="_Stream"></a>
<P><font face=Arial size=+1 color=#808080><B>Stream</B></font></P>
<P><I>Stream functors</I></P>
<P>Stream input/output and other related functors.</P>
<P>[Total <B>26</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_f_at_end">f_at_end</a></B>: <I>Check for end of stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_attr">f_attr</a></B>: <I>Get stream info.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_bufmode">f_bufmode</a></B>: <I>Set stream buffer size.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_close">f_close</a></B>: <I>Close opened stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_create">f_create</a></B>: <I>Open file as stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_err">f_err</a></B>: <I>Standard error output.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_get">f_get</a></B>: <I>Get line(s) from stream (as strings).</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_get_length">f_get_length</a></B>: <I>Get stream file length.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_getc">f_getc</a></B>: <I>Get character from stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_getline">f_getline</a></B>: <I>Get line from stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_in">f_in</a></B>: <I>Standard input.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_is_console">f_is_console</a></B>: <I>Check for console device.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_open">f_open</a></B>: <I>Open file as stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_out">f_out</a></B>: <I>Standard output.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_put">f_put</a></B>: <I>Put value(s) to stream (as strings).</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_putc">f_putc</a></B>: <I>Put character to stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_putline">f_putline</a></B>: <I>Put string to stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_read">f_read</a></B>: <I>Read string from stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_seek">f_seek</a></B>: <I>Seek absolutely in stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_set_length">f_set_length</a></B>: <I>Set stream file length.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_skip">f_skip</a></B>: <I>Seek relatively in stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_sync">f_sync</a></B>: <I>Sync stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_f_tell">f_tell</a></B>: <I>Tell current position in stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_stream">is_stream</a></B>: <I>Check for stream.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with_input">with_input</a></B>: <I>Default input stream wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with_output">with_output</a></B>: <I>Default output stream wrapper.</I></LI>
</UL>
<!-- ../src/E_Stream.cpp:1652 -->

<HR />
<a name="_String"></a>
<P><font face=Arial size=+1 color=#808080><B>String</B></font></P>
<P><I>String functors</I></P>
<P>Functors, operating on string values.</P>
<P>[Total <B>80</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_cc_excl">cc_excl</a></B>: <I>Charset predicate exclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cc_incl">cc_incl</a></B>: <I>Charset predicate inclusive composer.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_b">dc_b</a></B>: <I>Decode unsigned byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_l">dc_l</a></B>: <I>Decode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sb">dc_sb</a></B>: <I>Decode signed byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sw">dc_sw</a></B>: <I>Decode signed word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_w">dc_w</a></B>: <I>Decode unsigned word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_b">ec_b</a></B>: <I>Encode byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_l">ec_l</a></B>: <I>Encode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_w">ec_w</a></B>: <I>Encode word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_string">expect_string</a></B>: <I>Expect string value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_is_string">is_string</a></B>: <I>Check for string value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n__base">n__base</a></B>: <I>Parse string as value by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_bin">n_bin</a></B>: <I>Parse string as binary value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_dec">n_dec</a></B>: <I>Parse string as decimal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_float">n_float</a></B>: <I>Parse string as float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_hex">n_hex</a></B>: <I>Parse string as hexadecimal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_oct">n_oct</a></B>: <I>Parse string as octal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_findfirst">rx_findfirst</a></B>: <I>Search forward for pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_findlast">rx_findlast</a></B>: <I>Search backward for pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_locate">rx_locate</a></B>: <I>Locate set of patterns in string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_match">rx_match</a></B>: <I>Pattern matching.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_replace">rx_replace</a></B>: <I>Replace set of patterns in string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rx_split">rx_split</a></B>: <I>Split string by pattern.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s__base">s__base</a></B>: <I>Convert signed integer to string by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_bin">s_bin</a></B>: <I>Convert signed integer to binary string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cat">s_cat</a></B>: <I>String concatenation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_chars">s_chars</a></B>: <I>Make string from character list.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_cmp">s_cmp</a></B>: <I>String signed comparison.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_common_head">s_common_head</a></B>: <I>Common string head.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_common_tail">s_common_tail</a></B>: <I>Common string tail.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_count_ex">s_count_ex</a></B>: <I>String count (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_count_in">s_count_in</a></B>: <I>String count (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_create">s_create</a></B>: <I>String constructor.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_dec">s_dec</a></B>: <I>Convert signed integer to decimal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_decode">s_decode</a></B>: <I>Decode cooked string with codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_efloat">s_efloat</a></B>: <I>Convert float to string (E-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_empty">s_empty</a></B>: <I>Empty string literal.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_encode">s_encode</a></B>: <I>Encode raw string with codec.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_eq">s_eq</a></B>: <I>String equality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ffloat">s_ffloat</a></B>: <I>Convert float to string (F-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_filter_ex">s_filter_ex</a></B>: <I>String filter (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_filter_in">s_filter_in</a></B>: <I>String filter (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findfirst">s_findfirst</a></B>: <I>Search string forward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_findlast">s_findlast</a></B>: <I>Search string backward for context.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ge">s_ge</a></B>: <I>String "greater than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_gfloat">s_gfloat</a></B>: <I>Convert float to string (G-format).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_gt">s_gt</a></B>: <I>String "greater than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_hex">s_hex</a></B>: <I>Convert signed integer to hexadecimal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_icase">s_icase</a></B>: <I>Invert string case.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_icfirst">s_icfirst</a></B>: <I>Invert string case first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_join">s_join</a></B>: <I>Join string list to string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lcase">s_lcase</a></B>: <I>Lowercase string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lcfirst">s_lcfirst</a></B>: <I>Lowercase string first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_le">s_le</a></B>: <I>String "less than or equal" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_len">s_len</a></B>: <I>Get string length.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_loop">s_loop</a></B>: <I>String direct iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_loop_r">s_loop_r</a></B>: <I>String reverse iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lt">s_lt</a></B>: <I>String "less than" compare.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_map">s_map</a></B>: <I>String character translation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_max">s_max</a></B>: <I>String maximum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_min">s_min</a></B>: <I>String minimum.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ne">s_ne</a></B>: <I>String inequality.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_oct">s_oct</a></B>: <I>Convert signed integer to octal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ord">s_ord</a></B>: <I>Get character code.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_patch">s_patch</a></B>: <I>Replace fragment in string mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_poke">s_poke</a></B>: <I>Replace character in string mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_range">s_range</a></B>: <I>Create string from character range.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rep">s_rep</a></B>: <I>String replication.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_retype">s_retype</a></B>: <I>Convert string to different type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rev">s_rev</a></B>: <I>String reverse.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rspan_ex">s_rspan_ex</a></B>: <I>String span backward (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rspan_in">s_rspan_in</a></B>: <I>String span backward (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_slice">s_slice</a></B>: <I>String slice.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_span_ex">s_span_ex</a></B>: <I>String span forward (exclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_span_in">s_span_in</a></B>: <I>String span forward (inclusive).</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_type">s_type</a></B>: <I>Query string type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ucase">s_ucase</a></B>: <I>Uppercase string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ucfirst">s_ucfirst</a></B>: <I>Uppercase string first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_string">string</a></B>: <I>Coerce scalar to string.</I></LI>
</UL>
<!-- ../src/E_String.cpp:2243 -->

<HR />
<a name="_System"></a>
<P><font face=Arial size=+1 color=#808080><B>System</B></font></P>
<P><I>System operations</I></P>
<P>Miscellaneous system functors.</P>
<P>[Total <B>4</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#__arguments">_arguments</a></B>: <I>Module arguments.</I></LI>
<LI><B><a href="AWL_Functors.htm#__environ">_environ</a></B>: <I>System environment.</I></LI>
<LI><B><a href="AWL_Functors.htm#__version">_version</a></B>: <I>Interpreter version.</I></LI>
<LI><B><a href="AWL_Functors.htm#_include">include</a></B>: <I>Include module.</I></LI>
</UL>
<!-- ../src/Kernel.cpp:1704 -->

<HR />
<a name="_Term"></a>
<P><font face=Arial size=+1 color=#808080><B>Term</B></font></P>
<P><I>Term functors</I></P>
<P>Functors, operating on terms.</P>
<P>[Total <B>2</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_determ">determ</a></B>: <I>Deconstruct term to functor and argument(s).</I></LI>
<LI><B><a href="AWL_Functors.htm#_enterm">enterm</a></B>: <I>Construct term from functor and argument(s).</I></LI>
</UL>
<!-- ../src/E_Func.cpp:608 -->

<HR />
<a name="_Ternary"></a>
<P><font face=Arial size=+1 color=#808080><B>Ternary</B></font></P>
<P><I>Ternary functors</I></P>
<P>Functors, expecting three arguments.</P>
<P>[Total <B>4</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_for_dec">for_dec</a></B>: <I>Decremental range iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_for_inc">for_inc</a></B>: <I>Incremental range iterator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_if">if</a></B>: <I>Conditional positive test.</I></LI>
<LI><B><a href="AWL_Functors.htm#_unless">unless</a></B>: <I>Conditional negative test.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1705 -->

<HR />
<a name="_Unary"></a>
<P><font face=Arial size=+1 color=#808080><B>Unary</B></font></P>
<P><I>Unary functors</I></P>
<P>Functors, expecting one argument.</P>
<P>[Total <B>71</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_abs">abs</a></B>: <I>Numeric absolute value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_acos">acos</a></B>: <I>Trigonometric arccosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_asin">asin</a></B>: <I>Trigonometric arcsine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_assert">assert</a></B>: <I>Assertion check.</I></LI>
<LI><B><a href="AWL_Functors.htm#_atan">atan</a></B>: <I>Trigonometric arctangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_count">bitclr_count</a></B>: <I>Count all clear bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_hi">bitclr_hi</a></B>: <I>Locate highest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitclr_lo">bitclr_lo</a></B>: <I>Locate lowest clear bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitrev">bitrev</a></B>: <I>Reverse bits order.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_count">bitset_count</a></B>: <I>Count all set bits.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_hi">bitset_hi</a></B>: <I>Locate highest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_bitset_lo">bitset_lo</a></B>: <I>Locate lowest set bit.</I></LI>
<LI><B><a href="AWL_Functors.htm#_c_not">c_not</a></B>: <I>Conditional "NOT" operation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ceil">ceil</a></B>: <I>Numeric rounding up.</I></LI>
<LI><B><a href="AWL_Functors.htm#_clr">clr</a></B>: <I>Clear mutable.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cos">cos</a></B>: <I>Trigonometric cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_cosh">cosh</a></B>: <I>Numeric hyperbolic cosine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_b">dc_b</a></B>: <I>Decode unsigned byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_l">dc_l</a></B>: <I>Decode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sb">dc_sb</a></B>: <I>Decode signed byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_sw">dc_sw</a></B>: <I>Decode signed word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dc_w">dc_w</a></B>: <I>Decode unsigned word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec">dec</a></B>: <I>Pre-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_dec_p">dec_p</a></B>: <I>Post-decrement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_deval">deval</a></B>: <I>Expression devaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_b">ec_b</a></B>: <I>Encode byte.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_l">ec_l</a></B>: <I>Encode long.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ec_w">ec_w</a></B>: <I>Encode word.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_r">eval_r</a></B>: <I>R-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_v">eval_v</a></B>: <I>V-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_eval_x">eval_x</a></B>: <I>X-evaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_ever">ever</a></B>: <I>Iterate forever.</I></LI>
<LI><B><a href="AWL_Functors.htm#_exp">exp</a></B>: <I>Numeric exponentiation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_floor">floor</a></B>: <I>Numeric rounding down.</I></LI>
<LI><B><a href="AWL_Functors.htm#_hcode">hcode</a></B>: <I>Hash code value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc">inc</a></B>: <I>Pre-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_inc_p">inc_p</a></B>: <I>Post-increment.</I></LI>
<LI><B><a href="AWL_Functors.htm#_log">log</a></B>: <I>Numeric logarithm.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n__base">n__base</a></B>: <I>Parse string as value by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_bin">n_bin</a></B>: <I>Parse string as binary value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_dec">n_dec</a></B>: <I>Parse string as decimal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_hex">n_hex</a></B>: <I>Parse string as hexadecimal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_n_oct">n_oct</a></B>: <I>Parse string as octal value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_neg">neg</a></B>: <I>Numeric negation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_not">not</a></B>: <I>Bitwise complement.</I></LI>
<LI><B><a href="AWL_Functors.htm#_pi">pi</a></B>: <I>Multiply operand by \Pi.</I></LI>
<LI><B><a href="AWL_Functors.htm#_rand">rand</a></B>: <I>Random numbers generator.</I></LI>
<LI><B><a href="AWL_Functors.htm#_randomize">randomize</a></B>: <I>Randomization.</I></LI>
<LI><B><a href="AWL_Functors.htm#_reval">reval</a></B>: <I>Expression revaluation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s__base">s__base</a></B>: <I>Convert signed integer to string by base.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_bin">s_bin</a></B>: <I>Convert signed integer to binary string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_dec">s_dec</a></B>: <I>Convert signed integer to decimal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_hex">s_hex</a></B>: <I>Convert signed integer to hexadecimal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_icase">s_icase</a></B>: <I>Invert string case.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_icfirst">s_icfirst</a></B>: <I>Invert string case first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lcase">s_lcase</a></B>: <I>Lowercase string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_lcfirst">s_lcfirst</a></B>: <I>Lowercase string first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_len">s_len</a></B>: <I>Get string length.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_map">s_map</a></B>: <I>String character translation.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_oct">s_oct</a></B>: <I>Convert signed integer to octal string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_rev">s_rev</a></B>: <I>String reverse.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_type">s_type</a></B>: <I>Query string type.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ucase">s_ucase</a></B>: <I>Uppercase string.</I></LI>
<LI><B><a href="AWL_Functors.htm#_s_ucfirst">s_ucfirst</a></B>: <I>Uppercase string first character.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sgn">sgn</a></B>: <I>Numeric sign.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sin">sin</a></B>: <I>Trigonometric sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sinh">sinh</a></B>: <I>Numeric hyperbolic sine.</I></LI>
<LI><B><a href="AWL_Functors.htm#_sqr">sqr</a></B>: <I>Numeric square root.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tan">tan</a></B>: <I>Trigonometric tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_tanh">tanh</a></B>: <I>Numeric hyperbolic tangent.</I></LI>
<LI><B><a href="AWL_Functors.htm#_void">void</a></B>: <I>Evaluate as void.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1697 -->

<HR />
<a name="_Wrapper"></a>
<P><font face=Arial size=+1 color=#808080><B>Wrapper</B></font></P>
<P><I>Wrapper functors</I></P>
<P>Functors, evaluating some argument(s) with additional prologue/epilogue.</P>
<P>[Total <B>14</B>]:</P>
<UL>
<LI><B><a href="AWL_Functors.htm#_expect_array">expect_array</a></B>: <I>Expect array value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_float">expect_float</a></B>: <I>Expect float value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_hash">expect_hash</a></B>: <I>Expect hash value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_int">expect_int</a></B>: <I>Expect integer value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_list">expect_list</a></B>: <I>Expect list value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_object">expect_object</a></B>: <I>Expect object value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_pattern">expect_pattern</a></B>: <I>Expect pattern value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_expect_string">expect_string</a></B>: <I>Expect string value.</I></LI>
<LI><B><a href="AWL_Functors.htm#_try">try</a></B>: <I>Exception frame wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_try_catch">try_catch</a></B>: <I>Exception frame wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with">with</a></B>: <I>Class current instance wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with_input">with_input</a></B>: <I>Default input stream wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_with_output">with_output</a></B>: <I>Default output stream wrapper.</I></LI>
<LI><B><a href="AWL_Functors.htm#_without">without</a></B>: <I>Class deinstantiation wrapper.</I></LI>
</UL>
<!-- ../src/Eval.cpp:1725 -->

<HR />
<P>Total categories: <B>38</B>.</P>
</BODY>
</HTML>