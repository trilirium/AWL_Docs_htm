<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1251">
	<TITLE>Another Web Language:a brief description</TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 4.1.4.2 (Windows)">
	<META NAME="AUTHOR" CONTENT="Гаев Д.Г.">
	<META NAME="CREATED" CONTENT="20070320;195900000000000">
	<META NAME="CHANGED" CONTENT="20150209;202545774000000">
	<META NAME="CLASSIFICATION" CONTENT="AWL">
	<META NAME="KEYWORDS" CONTENT="AWL, programming, functional, web">
	<META NAME="Info 1" CONTENT="">
	<META NAME="Info 2" CONTENT="">
	<META NAME="Info 3" CONTENT="">
	<META NAME="Info 4" CONTENT="">
	<META NAME="SDFOOTNOTE" CONTENT=";;;;P">
	<META NAME="SDENDNOTE" CONTENT="ARABIC">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 2cm }
		P { margin-bottom: 0.21cm; direction: ltr; color: #000000; widows: 2; orphans: 2 }
		P.western { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ru-RU }
		P.cjk { font-family: "Times New Roman", serif; font-size: 12pt }
		P.ctl { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ar-SA }
		H2 { margin-bottom: 0.11cm; direction: ltr; color: #000000; widows: 2; orphans: 2 }
		H2.western { font-family: "Arial", sans-serif; font-size: 14pt; so-language: ru-RU; font-style: italic }
		H2.cjk { font-family: "Times New Roman", serif; font-size: 14pt; font-style: italic }
		H2.ctl { font-family: "Arial", sans-serif; font-size: 14pt; so-language: ar-SA; font-style: italic }
		H3 { margin-bottom: 0.11cm; direction: ltr; color: #000000; widows: 2; orphans: 2 }
		H3.western { font-family: "Arial", sans-serif; font-size: 13pt; so-language: ru-RU }
		H3.cjk { font-family: "Times New Roman", serif; font-size: 13pt }
		H3.ctl { font-family: "Arial", sans-serif; font-size: 13pt; so-language: ar-SA }
		TD P { margin-bottom: 0cm; direction: ltr; color: #000000; widows: 2; orphans: 2 }
		TD P.western { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ru-RU }
		TD P.cjk { font-family: "Times New Roman", serif; font-size: 12pt }
		TD P.ctl { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ar-SA }
		P.ww-содержимое-таблицы111111111111111111111111-western { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ru-RU }
		P.ww-содержимое-таблицы111111111111111111111111-cjk { font-family: "Times New Roman", serif; font-size: 12pt }
		P.ww-содержимое-таблицы111111111111111111111111-ctl { font-family: "Times New Roman", serif; font-size: 12pt; so-language: ar-SA }
		A:link { so-language: zxx }
	-->
	</STYLE>
</HEAD>
<BODY LANG="ru-RU" TEXT="#000000" DIR="LTR">
<H2 CLASS="western" ALIGN=CENTER><FONT SIZE=5><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">AWL:</SPAN></SPAN></FONT><FONT SIZE=4 STYLE="font-size: 16pt"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><BR></SPAN></SPAN></FONT><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">a
brief description of the language</SPAN></SPAN></H2>
<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="margin-bottom: 0cm">
<I>(version: <B>January</B><B>'201</B><B>5</B>)</I></P>
<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; text-decoration: none">
<FONT FACE="Arial, sans-serif"><FONT SIZE=4><B>Core language</B></FONT></FONT></P>
<H3 LANG="en-US" CLASS="western"><FONT SIZE=3>Basic AWL features</FONT></H3>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN STYLE="font-style: normal"><B>AWL</B></SPAN><SPAN STYLE="font-style: normal">
is based on many popular languages, but borrows </SPAN><SPAN STYLE="font-style: normal">features
</SPAN><SPAN STYLE="font-style: normal">most</SPAN><SPAN STYLE="font-style: normal">ly</SPAN><SPAN STYLE="font-style: normal">
from LISP-like languages and Perl. Some features are </SPAN><SPAN STYLE="font-style: normal">inspired</SPAN><SPAN STYLE="font-style: normal">
by </SPAN><SPAN STYLE="font-style: normal">different languages,
</SPAN><SPAN STYLE="font-style: normal">notably</SPAN><SPAN STYLE="font-style: normal">
</SPAN><SPAN STYLE="font-style: normal">APL (multi-dimensional
arrays), </SPAN><SPAN STYLE="font-style: normal">SNOBOL</SPAN><SPAN STYLE="font-style: normal">
(</SPAN><SPAN STYLE="font-style: normal">&rdquo;</SPAN><SPAN STYLE="font-style: normal">pattern&rdquo;
</SPAN><SPAN STYLE="font-style: normal">data type</SPAN><SPAN STYLE="font-style: normal">
and pattern matching) </SPAN><SPAN STYLE="font-style: normal">and
</SPAN><SPAN STYLE="font-style: normal">several</SPAN><SPAN STYLE="font-style: normal">
functional languages</SPAN><SPAN STYLE="font-style: normal">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN STYLE="font-style: normal">A</SPAN><SPAN STYLE="font-style: normal">WL
features:</SPAN></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><FONT SIZE=3><I>Interpreted</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">AWL
is implemented as an </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>interpreter</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">which</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
is the only software </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">required</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
to </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">execute</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
AWL source code. </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">U</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">nlike
Perl, AWL </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">interpreter
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">can operate in
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>interactive</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
(calculator-like) mode.</SPAN></FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Functional</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">The
language core is </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>functional</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
Most of the language (including common </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">numeric,
string and list </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">operators
and statements) are implemented as the </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">built-in</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>functors</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">Almost a</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">ll
language constructs (including &ldquo;statements&rdquo;) </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">always
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">return some value
(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">which may be</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
void </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">value</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">).</SPAN></FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Procedural</I></FONT></P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<FONT SIZE=3>AWL allows &ldquo;procedural&rdquo; programming style,
providing standard imperative language constructs for branching and
looping. AWL is NOT &ldquo;pure&rdquo; functional language (like
<B>Haskell</B> or <B>Clean</B>) &ndash; it has mutable data and
&ldquo;mutator&rdquo; operations to change it. In many situations,
AWL provides reasonable choice between &ldquo;procedural&rdquo; and
&ldquo;pure-functional&rdquo; solution to some problem.</FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Weakly-typed</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">Although
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">all </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">values
in AWL are </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>typed</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
variables (</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">as well as</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
other </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>mutables</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)
are </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>typeless</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
Any variable can keep value of any type </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(and
not only value, but its type, can </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">be
changed </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">in runtime</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
There is no way to restrict </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">variable
type </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">domain</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>statically</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
(but </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">there are </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">methods</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">to do </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">it
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>dynamically</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">at</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
run-time).</SPAN></FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Object-oriented</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">Language
supports </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>objects</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">which are instances of
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">previously
declared</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>classes</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
Classes support </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">linear</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>inheritance</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
and can implement </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>polymorphism</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
via </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(re)definition of</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>virtual</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
class </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">methods</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">Classes
in AWL are NOT implemented, or emulated</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
via hashes/collections, like in many other languages &ndash; </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">they
are separate kind of data </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">items</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Homoiconic</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<FONT SIZE=3><SPAN LANG="en-US">Like in LISP, </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">all</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
AWL code </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">constructs</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
are, </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">in fact</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">,
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">special </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">kind
of data. </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">They</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
even may be constructed in run time. </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">Many
language features, like </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>lazy</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><I>
evaluation</I></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">, rely on
this.</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Non-injectable</I></FONT></P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<FONT SIZE=3>Although AWL contains some ways to evaluate string data
of source code &ndash; using them is recommended <I>only</I> as last
resort! Usually, language provides better way to do what you want.
Language is designed to make difficult any kind of injections, e.g.
(mis)interpreting any kind of string data as code.</FONT></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<FONT SIZE=3><I>Expandable</I></FONT></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<FONT SIZE=3><SPAN LANG="en-US">External modules, expanding language
functionality, </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">can be
loaded dynamically </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">and</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">are relatively easy to
program</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">)</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">.</SPAN></FONT></P>
<H3 CLASS="western"><FONT SIZE=3><FONT FACE="Arial, sans-serif"><SPAN LANG="en-US"><SPAN STYLE="text-decoration: none"><B>S</B></SPAN></SPAN></FONT><SPAN LANG="en-US">calar
types and </SPAN><SPAN LANG="en-US">scalar </SPAN><SPAN LANG="en-US">operations</SPAN></FONT></H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">AWL
has a variety of data types. The most simple and primitive (</SPAN><SPAN LANG="en-US"><I>scalar</I></SPAN><SPAN LANG="en-US">)
</SPAN><SPAN LANG="en-US">types</SPAN><SPAN LANG="en-US"> are </SPAN><SPAN LANG="en-US"><I>numbers</I></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><I>character strings</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">N</SPAN><SPAN LANG="en-US">umber type is
subdivided </SPAN><SPAN LANG="en-US">(internally) </SPAN><SPAN LANG="en-US">into
</SPAN><SPAN LANG="en-US"><I>integer</I></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><I>float</I></SPAN><SPAN LANG="en-US">
number subtypes. </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">The
conversion between them is </SPAN><SPAN LANG="en-US">usually</SPAN><SPAN LANG="en-US">
implici</SPAN><SPAN LANG="en-US">t &ndash; but, internally, </SPAN><SPAN LANG="en-US">there
is a </SPAN><SPAN LANG="en-US">clear </SPAN><SPAN LANG="en-US">distinction
between integer and float values</SPAN><SPAN LANG="en-US">.</SPAN><SPAN LANG="en-US">)</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">These
are </SPAN><SPAN LANG="en-US"><I>integer literals</I></SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">which are
</SPAN><SPAN LANG="en-US"><I>decimal</I></SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">by
default</SPAN><SPAN LANG="en-US">, </SPAN><SPAN LANG="en-US">but can
be </SPAN><SPAN LANG="en-US">encoded in </SPAN><SPAN LANG="en-US"><I>octal</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>hex</I></SPAN><SPAN LANG="en-US"> or
</SPAN><SPAN LANG="en-US"><I>binary</I></SPAN><SPAN LANG="en-US">):</SPAN></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	0			<I>(</I><I>decimal, by default</I><I>)</I></P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	1001</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	65535</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	\o176666		<I>(octal </I><I>literal</I><I>)</I></P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	\xFFFF		<I>(hexadecimal </I><I>literal</I><I>)</I></P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	\b011010100		<I>(binary </I><I>literal</I><I>)</I></P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
And here are <I>float literals</I>:</P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	0.0</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	123.321</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	3.14159</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	1.0101e-10</P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
And the basic <I>string literals</I>:</P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	'abcdefg'</P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	&ldquo;Hello, world!\n&rdquo;</P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">For
strings, s</SPAN><SPAN LANG="en-US">ingle and double quotes are
interchangeable. </SPAN><SPAN LANG="en-US">String in single quotes
can contain double quotes (and vice versa). </SPAN><SPAN LANG="en-US">C-
and Java-like escape sequences are </SPAN><SPAN LANG="en-US">allowed</SPAN><SPAN LANG="en-US">
in string literals.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Most
</SPAN><SPAN LANG="en-US">of </SPAN><SPAN LANG="en-US">num</SPAN><SPAN LANG="en-US">eric</SPAN><SPAN LANG="en-US">
operations </SPAN><SPAN LANG="en-US">are either unary or binary, and
</SPAN><SPAN LANG="en-US">have </SPAN><SPAN LANG="en-US">both</SPAN><SPAN LANG="en-US">
&ldquo;operational&rdquo;</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">and</SPAN><SPAN LANG="en-US">
&ldquo;functional&rdquo; </SPAN><SPAN LANG="en-US">syntax:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=148>
	<COL WIDTH=185>
	<COL WIDTH=284>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">-&nbsp;a</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>n</B></SPAN><B>eg</B>(a)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>negation of <B>a</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">+&nbsp;a</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>abs</B>(a)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>absolute value of
			<B>a</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">a</SPAN>&nbsp;+&nbsp;b</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>add</B>(a,
			b)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>a</B> plus <B>b</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">a<B>&nbsp;</B>-<B>&nbsp;</B>b</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>sub</B>(a,
			b)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>a</B> minus <B>b</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">a<B>&nbsp;</B>*<B>&nbsp;</B>b</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>mul</B>(a,
			b)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>a</B>
			multiplied by <B>b</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">a<B>&nbsp;</B>/<B>&nbsp;</B>b</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>div</B>(a,
			b)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>a</B> divided
			by <B>b</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">i</SPAN></SPAN><B>&nbsp;</B>%<B>&nbsp;</B><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">j</SPAN></SPAN></FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>idiv</B>(<SPAN LANG="en-US">i</SPAN>,
			<SPAN LANG="en-US">j</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>integer <SPAN LANG="en-US">division</SPAN>
			of <SPAN LANG="en-US"><B>i</B></SPAN> <SPAN LANG="en-US">by</SPAN>
			<SPAN LANG="en-US"><B>j</B></SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=148 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">i</SPAN></SPAN><B>&nbsp;</B>%%<B>&nbsp;</B><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">j</SPAN></SPAN></FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>irem</B>(<SPAN LANG="en-US">i</SPAN>,
			<SPAN LANG="en-US">j</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>integer remainder
			of <SPAN LANG="en-US"><B>i</B></SPAN> <SPAN LANG="en-US">by</SPAN>
			<SPAN LANG="en-US"><B>j</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">A</SPAN><SPAN LANG="en-US">lmost
a</SPAN><SPAN LANG="en-US">ll operations </SPAN><SPAN LANG="en-US">in
AWL </SPAN><SPAN LANG="en-US">do </SPAN><SPAN LANG="en-US">have
internal &ldquo;functional&rdquo; form, </SPAN><SPAN LANG="en-US">which
is</SPAN><SPAN LANG="en-US"> shown above. Even when a more
</SPAN><SPAN LANG="en-US">traditional</SPAN><SPAN LANG="en-US">
operator syntax is used, internally it is always translated into
</SPAN><SPAN LANG="en-US">functor</SPAN><SPAN LANG="en-US"> call. For
example, the (A&nbsp;+&nbsp;B)&nbsp;*&nbsp;(C&nbsp;-&nbsp;D) is just
a shortcut for </SPAN><SPAN LANG="en-US"><B>mul</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><B>add</B></SPAN><SPAN LANG="en-US">(A,&nbsp;B),
</SPAN><SPAN LANG="en-US"><B>sub</B></SPAN><SPAN LANG="en-US">(C,&nbsp;D)).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>Coercions</I></SPAN><SPAN LANG="en-US">
between integers and floats are applied implicitly. For </SPAN><SPAN LANG="en-US"><B>idiv</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>irem</B></SPAN><SPAN LANG="en-US">
operands are coerced to integer (even </SPAN><SPAN LANG="en-US">when</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">they are </SPAN><SPAN LANG="en-US">float);
</SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><B>div</B></SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">they are coerced to float (even when </SPAN><SPAN LANG="en-US">they</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">are </SPAN><SPAN LANG="en-US">integer).</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-US">or </SPAN><SPAN LANG="en-US">all
</SPAN><SPAN LANG="en-US">other operations</SPAN><SPAN LANG="en-US">
&ndash; </SPAN><SPAN LANG="en-US">result is float, if any of operands
is float (and integer otherwise).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Warning: there are no automatic coercion to float, if any integer
operations runs out of 32-bit integer range.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>Logic</I></SPAN><SPAN LANG="en-US"><I>al</I></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><I>shift</I></SPAN><SPAN LANG="en-US">
operations forc</SPAN><SPAN LANG="en-US">e</SPAN><SPAN LANG="en-US">
coercion of both operands to integer </SPAN><SPAN LANG="en-US">values,</SPAN><SPAN LANG="en-US">
as well:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=165>
	<COL WIDTH=188>
	<COL WIDTH=264>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">~&nbsp;p</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>not</B>(p)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>bitwise inversion
			of <B>p</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">p</SPAN>&nbsp;&amp;&nbsp;q</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>and</B>(p,
			q)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>bitwise AND of <B>p</B>
			and <B>q</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">p</SPAN>&nbsp;|&nbsp;q</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>or</B>(p,
			q)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>bitwise OR of <B>p</B>
			and <B>q</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">p</SPAN>&nbsp;~&nbsp;q</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>xor</B>(p,
			q)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>bitwise XOR of <B>p</B>
			and <B>q</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">v&nbsp;&lt;&lt;</SPAN>&nbsp;n</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>shl</B>(<SPAN LANG="en-US">v</SPAN>,
			n)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>shift <SPAN LANG="en-US"><B>v</B></SPAN>
			left <SPAN LANG="en-US">(</SPAN>by <B>n</B> bits<SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=165 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">v&nbsp;&gt;&gt;</SPAN>&nbsp;n</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>shr</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">v</SPAN><SPAN LANG="en-US">,</SPAN>
			n)</FONT></P>
		</TD>
		<TD WIDTH=264 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>shift <SPAN LANG="en-US"><B>v</B></SPAN>
			right <SPAN LANG="en-US">(</SPAN>by <B>n</B> bits<SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The shift operations are completely symmetric: (v &lt;&lt; n) is
always same as (v &gt;&gt; -&nbsp;n), and (v &gt;&gt; n) is same as
(v &lt;&lt; -&nbsp;n).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are a set of <I>comparison</I> operations for numeric values.
All of them perform integer compare, if both operands are integer,
and float otherwise. AWL has no separate &ldquo;boolean&rdquo; type:
as result of all compare operations (and other <I>predicates</I>),
return value is just 1 (if test succeeds) or 0 (if test fails).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=168>
	<COL WIDTH=200>
	<COL WIDTH=249>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">x</SPAN>&nbsp;&lt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>lt</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B> less
			than <B>y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;&gt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>gt</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B>
			greater than <B>y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;&lt;=&nbsp;y<BR>x&nbsp;~&gt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>le</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B> less
			than or equal to <B>y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;&gt;=&nbsp;y<BR>x&nbsp;~&lt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ge</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B>
			greater than or equal to <B>y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;==&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>eq</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B> equal
			to <B>y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;&lt;&gt;&nbsp;y<BR>x&nbsp;~=&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ne</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>is <B>x</B> not
			equal to <B>y</B>?</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
It's important to remember, what all listed compare operations must
be applied only to numbers! It's a mistake to compare any non-number
data with these operations, especially with &ldquo;==&rdquo; or &rdquo;&lt;&gt;&rdquo;.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Other
useful operations on </SPAN><SPAN LANG="en-US">numbers</SPAN><SPAN LANG="en-US">
are </SPAN><SPAN LANG="en-US"><I>maximum</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>minimum</I></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><I>compare</I></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=168>
	<COL WIDTH=200>
	<COL WIDTH=249>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;?&lt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>min</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>lesser of <SPAN LANG="en-US">both
			</SPAN><B>x</B> and <B>y</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;?&gt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>max</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>greater of <SPAN LANG="en-US">both
			</SPAN><B>x</B> and <B>y</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=168 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">x&nbsp;&lt;?&gt;&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=200 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>cmp</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=249 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>compare <B>x</B>
			and <B>y</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-US">inal
operation </SPAN><SPAN LANG="en-US"><B>cmp</B></SPAN><SPAN LANG="en-US">(x,y)
returns not &ldquo;boolean&rdquo; result, but </SPAN><SPAN LANG="en-US">integer</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
-1 (if </SPAN><SPAN LANG="en-US"><I>x</I></SPAN><SPAN LANG="en-US">&nbsp;&lt;&nbsp;</SPAN><SPAN LANG="en-US"><I>y</I></SPAN><SPAN LANG="en-US">),
1 (if </SPAN><SPAN LANG="en-US"><I>x</I></SPAN><SPAN LANG="en-US">&nbsp;&gt;&nbsp;</SPAN><SPAN LANG="en-US"><I>y</I></SPAN><SPAN LANG="en-US">)
or 0 (if </SPAN><SPAN LANG="en-US"><I>x</I></SPAN><SPAN LANG="en-US">&nbsp;==&nbsp;</SPAN><SPAN LANG="en-US"><I>y</I></SPAN><SPAN LANG="en-US">).
</SPAN><SPAN LANG="en-US">All compare operations for integers treat
them as signed values, but there is a special </SPAN><SPAN LANG="en-US"><B>u_cmp</B></SPAN><SPAN LANG="en-US">(x,y),
returning result of </SPAN><SPAN LANG="en-US"><I>unsigned</I></SPAN><SPAN LANG="en-US">
comparison.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Of course, there are a plenty of standard mathematical functions.
Most important ones:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=254>
	<COL WIDTH=371>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>floor</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Floor of <B>x</B>
			<SPAN LANG="en-US">(</SPAN>round down to integer<SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ceil</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Ceiling of <B>x</B>
			<SPAN LANG="en-US">(</SPAN>round up to integer<SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>sqr</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Square root of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>exp</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Exponent of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>log</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Natural logarithm
			of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>exp_by</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Raise <B>x</B> in
			power <B>y</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>log_by</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Logarithm of <B>y</B>
			base <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>sin</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Sine of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>cos</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Cosine of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>tan</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Tangent of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>asin</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Arcsine of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>acos</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Arccosine of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>atan</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Arctangent of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>sinh</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hyperbolic sine of
			<B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>cosh</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hyperbolic cosine
			of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>tanh</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hyperbolic tangent
			of <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>pi</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Value of <FONT FACE="Times New Roman, serif"><B>&pi;</B></FONT><FONT FACE="Times New Roman, serif">,
			</FONT>multiplied by <B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rad</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Polar radius of
			point (<B>x</B>, <B>y</B>)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ang</B>(x,
			y)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Polar angle of
			point (<B>x</B>, <B>y</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Most of math functors have no alternative &ldquo;operation&rdquo;
syntax. Both operation and results of them are float (coercion
applied to operands, if necessary). For trigonometric functors,
operands/results are in radians.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Some numeric functors are <I>nullary</I>, having no arguments at all:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=254>
	<COL WIDTH=371>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>min_int</B>()</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Minimum integer
			value <SPAN LANG="en-US">possible</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>max_int</B>()</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Maximum integer
			value <SPAN LANG="en-US">possible</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>inf_pos</B>()</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Positive infinity</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>inf_neg</B>()</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Negative infinity</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>nan</B>()</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER>&ldquo;<I>Not a
			number&rdquo; value</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Finall</SPAN><SPAN LANG="en-US">y,</SPAN><SPAN LANG="en-US">
although the numeric conversions are </SPAN><SPAN LANG="en-US">usually</SPAN><SPAN LANG="en-US">
implicit</SPAN><SPAN LANG="en-US">,</SPAN><SPAN LANG="en-US"> there
are explicit conversion operations as well.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=254>
	<COL WIDTH=371>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>int</B></SPAN>(<SPAN LANG="en-US">v</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Coerce number or
			string <B>v</B> to integer</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>float</B></SPAN>(<SPAN LANG="en-US">v</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Coerce number or
			string <B>v</B> to float</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=254 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>num</B></SPAN>(<SPAN LANG="en-US">v</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=371 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Coerce string <B>v</B>
			to integer or float</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
When float is coerced to integer, the fractional part is just thrown
away without rounding (and it it forced into integer values range).
When string is converted to number, the starting part of it, which
can be interpreted as numeric value, is parsed (0 is returned, if no
valid number can be parsed). For <B>num</B>, result can be either
integer or float, depending from which suits better.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>Strings</I></SPAN><SPAN LANG="en-US">
are character sequences of </SPAN><SPAN LANG="en-US">(almost)
</SPAN><SPAN LANG="en-US">unlimited </SPAN><SPAN LANG="en-US"><I>length</I></SPAN><SPAN LANG="en-US">.
String </SPAN><SPAN LANG="en-US">of length 0</SPAN><SPAN LANG="en-US">
is </SPAN><SPAN LANG="en-US"><I>empty</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">A</SPAN><SPAN LANG="en-US">nother </SPAN><SPAN LANG="en-US">important
</SPAN><SPAN LANG="en-US">attribute of string is </SPAN><SPAN LANG="en-US"><I>type</I></SPAN><SPAN LANG="en-US">,
which defines range of character </SPAN><SPAN LANG="en-US">codes</SPAN><SPAN LANG="en-US">
string can contain. </SPAN><SPAN LANG="en-US">Currently</SPAN><SPAN LANG="en-US">,
there are 3 </SPAN><SPAN LANG="en-US">string </SPAN><SPAN LANG="en-US">types
supported:</SPAN></P>
<UL>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">string
	</SPAN><SPAN LANG="en-US"><I><SPAN STYLE="font-weight: normal">type&nbsp;0</SPAN></I></SPAN><SPAN LANG="en-US">:
	8-bit characters </SPAN><SPAN LANG="en-US">allowed</SPAN><SPAN LANG="en-US">
	&ndash; </SPAN><SPAN LANG="en-US">only for basic ASCII </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">and,
	</SPAN><SPAN LANG="en-US">probably</SPAN><SPAN LANG="en-US">,
	Latin-1);</SPAN></P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">string
	</SPAN><SPAN LANG="en-US"><I><SPAN STYLE="font-weight: normal">type&nbsp;1</SPAN></I></SPAN><SPAN LANG="en-US">:
	16-bit characters </SPAN><SPAN LANG="en-US">allowed</SPAN><SPAN LANG="en-US">
	&ndash; </SPAN><SPAN LANG="en-US">for Unicode BMP;</SPAN></P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">string
	</SPAN><SPAN LANG="en-US"><I><SPAN STYLE="font-weight: normal">type&nbsp;2</SPAN></I></SPAN><SPAN LANG="en-US">:
	32-bit characters </SPAN><SPAN LANG="en-US">allowed</SPAN><SPAN LANG="en-US">
	&ndash; </SPAN><SPAN LANG="en-US">for all Unicode characters
	</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">including
	reserved</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US"> and
	more.</SPAN></P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
However, this is just a suggested use. Actually, language does not
limit possible string usage. Strings can serve as containers for
almost any kind of data (including raw octet sequences, raster
graphics, audio samples and more). Besides allowed character range,
there is no restriction for characters contained in string (even NUL
character is perfectly valid, too). Interpretation of string content
is (mostly) left to programmer.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
String literals are of type 0 by default. (To contain 16-bit
characters, string literal must be preceded by &ldquo;\u&rdquo;
prefix.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
As for numeric scalars, there is a rich set of built-in operations
(functors)  for strings. And most of them, too, can be written in
both &ldquo;operational&rdquo; and &ldquo;functional&rdquo; form.
Names for string functors usually start with &ldquo;<B>s_</B>&rdquo;,
string operation symbols include suffix &ldquo;$&rdquo;.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=128>
	<COL WIDTH=179>
	<COL WIDTH=310>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_type</B>(s)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>type of string <B>s</B>
			(0, 1, 2)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">#$&nbsp;s</FONT></P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_len</B>(s)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>length of string <B>s</B>
			(in characters)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s&nbsp;+$&nbsp;t</FONT></P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_cat</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>concatenation of
			strings <B>s</B> and <B>t</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s&nbsp;*$&nbsp;n</FONT></P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_rep</B>(s,
			n)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>replication of
			string <B>s</B> (total <B>n</B> times)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">~$&nbsp;s</FONT></P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_rev</B>(s)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>reverse of string
			<B>s</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=128 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=179 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_retype</B>(T,
			s)</FONT></P>
		</TD>
		<TD WIDTH=310 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>string <B>s</B>,
			converted to type <B>T</B> (0, 1, 2)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
String scalars (exactly as numeric scalars) are <I>immutable</I>: no
string operation can change its argument(s). All listed operation
return new string value (which usually stored somewhere for later
use).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Some string operations access string content: either individual
characters or entire substrings:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=150>
	<COL WIDTH=202>
	<COL WIDTH=265>
	<TR VALIGN=TOP>
		<TD WIDTH=150 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=202 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_ord</B>(s,
			i)</FONT></P>
		</TD>
		<TD WIDTH=265 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">C</SPAN>haracter
			code <SPAN LANG="en-US">from </SPAN><SPAN LANG="en-US"><B>s</B></SPAN><SPAN LANG="en-US">
			</SPAN>at <SPAN LANG="en-US">offset</SPAN> <B>i</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=150 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">s</SPAN>&nbsp;$[from..to]</FONT></P>
		</TD>
		<TD WIDTH=202 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_slice</B>(from..to,
			s)</FONT></P>
		</TD>
		<TD WIDTH=265 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">F</SPAN>ragment
			of <SPAN LANG="en-US">string </SPAN><B>s</B><BR>(between <SPAN LANG="en-US">offset
			</SPAN><B>from</B> and <B>to</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
First operation (<B>s_ord</B>) returns <I>code of character</I>
(which is integer value, not string!) from string <I>s</I> at
position <I>i</I>. Characters are indexed from 0, so valid <I>positive</I>
values of i are from 0 to (including) <B>s_len</B>(s)&nbsp;&ndash;&nbsp;1.
If <I>i</I> is <I>negative</I>, it returns character in <I>s</I><SPAN STYLE="font-style: normal">
from the end</SPAN>: <B>s_ord</B>(s, -1) returns code of last
character in <I>s </I>and <B>s_ord</B>(s, -&nbsp;<B>s_len</B>(s))
returns code of first character. (Obviously, last one is the same as
<B>s_ord</B>(s, 0) or, most easy, just <B>s_ord</B>(s).)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">Second operation returns </SPAN><SPAN LANG="en-US"><I>string
slice</I></SPAN><SPAN LANG="en-US"> of </SPAN><I>s</I><SPAN LANG="en-US">,
</SPAN>as <SPAN LANG="en-US">defined by index</SPAN><SPAN STYLE="font-style: normal">
range </SPAN><SPAN LANG="en-US"><I>from..to</I></SPAN><SPAN LANG="en-US">.
</SPAN>This r<SPAN LANG="en-US">ange notation is just a syntax
shortcut for 2-element list: </SPAN><SPAN LANG="en-US"><I>from..to</I></SPAN><SPAN LANG="en-US">
</SPAN>means<SPAN LANG="en-US"> </SPAN>exactly<SPAN LANG="en-US"> the
same as </SPAN><SPAN LANG="en-US"><I>(from, to)</I></SPAN><SPAN LANG="en-US">.
String slice include characters starting at </SPAN>offset<SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>from</I></SPAN><SPAN LANG="en-US">
(inclusive), and ending (</SPAN>ex<SPAN LANG="en-US">clu</SPAN>sive<SPAN LANG="en-US">!)
at </SPAN>offset<SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><I>to</I></SPAN><SPAN LANG="en-US">.
</SPAN>S<SPAN LANG="en-US">o, slice length </SPAN>equals to<SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>to&nbsp;-&nbsp;from</I></SPAN><SPAN LANG="en-US">
(</SPAN>and <SPAN LANG="en-US">slice is empty, if </SPAN><SPAN LANG="en-US"><I>to&nbsp;&lt;=&nbsp;from</I></SPAN><SPAN LANG="en-US">).
Any of range </SPAN>borders<SPAN LANG="en-US"> (</SPAN>and <SPAN LANG="en-US">even
both) can be omitted: 0 is assumed for </SPAN><SPAN LANG="en-US"><I>from</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><B>s_len</B></SPAN><SPAN LANG="en-US">(s)
is assumed for </SPAN><I>to</I><SPAN LANG="en-US">. So (for example):</SPAN></P>
<UL>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<SPAN LANG="en-US">s&nbsp;$[1&nbsp;..]</SPAN> &ndash; <SPAN LANG="en-US">returns
	string </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">
	with </SPAN><SPAN LANG="en-US"><I>first</I></SPAN><SPAN LANG="en-US">
	char</SPAN>acter<SPAN LANG="en-US"> removed;</SPAN></P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<SPAN LANG="en-US">s&nbsp;$[..&nbsp;</SPAN><SPAN LANG="en-US"><B>s_len</B></SPAN><SPAN LANG="en-US">(s)-1]</SPAN>
	&ndash; <SPAN LANG="en-US">returns string </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">
	with </SPAN><SPAN LANG="en-US"><I>last</I></SPAN><SPAN LANG="en-US">
	char</SPAN>acter<SPAN LANG="en-US"> removed;</SPAN></P>
	<LI><P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
	<SPAN LANG="en-US">s&nbsp;$[1&nbsp;..&nbsp;</SPAN><SPAN LANG="en-US"><B>s_len</B></SPAN><SPAN LANG="en-US">(s)-1]</SPAN>
	&ndash; <SPAN LANG="en-US">returns string </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">
	with </SPAN><SPAN LANG="en-US"><I>first and last</I></SPAN><SPAN LANG="en-US">
	char</SPAN>acters<SPAN LANG="en-US"> removed.</SPAN></P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
When <I>from</I> is less than 0, and/or <I><SPAN STYLE="font-weight: normal">to</SPAN></I>
is greater than <B>s_len</B>(s) &ndash; result is padded with blank
characters, at beginning and/or at end.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Exactly a<SPAN LANG="en-US">s numbers, strings are </SPAN><SPAN LANG="en-US"><I>ordered</I></SPAN><I>
lexicographically</I><SPAN LANG="en-US"> </SPAN>(= in <SPAN STYLE="font-weight: normal">dictionary
order</SPAN><SPAN LANG="en-US">). By default, characters ordering is
defined by their codes, but this may </SPAN>change, if some<SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>collation mode</I></SPAN><SPAN LANG="en-US">
(not detailed here) </SPAN>is in effect<SPAN LANG="en-US">. Set of
string compare operations is </SPAN>quite <SPAN LANG="en-US">similar
to num</SPAN>eric<SPAN LANG="en-US"> ones:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=154>
	<COL WIDTH=163>
	<COL WIDTH=300>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&lt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_lt</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> precedes
			<B>t</B> <SPAN LANG="en-US">in dictionary</SPAN>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&gt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_gt</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> follows <B>t</B>
			<SPAN LANG="en-US">in dictionary</SPAN>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&lt;=$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t<BR>s<FONT FACE="Courier New, monospace">&nbsp;</FONT>~&gt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_le</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> precedes
			<SPAN LANG="en-US">(</SPAN>or equal<SPAN LANG="en-US">s</SPAN> to<SPAN LANG="en-US">)</SPAN>
			<B>t</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&gt;=$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t<BR>s<FONT FACE="Courier New, monospace">&nbsp;</FONT>~&lt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_ge</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> follows
			<SPAN LANG="en-US">(</SPAN>or equal<SPAN LANG="en-US">s</SPAN> to<SPAN LANG="en-US">)</SPAN>
			<B>t</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>==$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_eq</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> <SPAN LANG="en-US">is
			</SPAN>equal to <B>t</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=154 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>~=$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t<BR>s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&lt;&gt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_ne</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=300 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>s</B> <SPAN LANG="en-US">is
			</SPAN>not equal to <B>t</B>?</I></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">All
listed </SPAN><SPAN LANG="en-US">compare </SPAN><SPAN LANG="en-US">operations
are </SPAN><SPAN LANG="en-US"><I>predicates</I></SPAN><SPAN LANG="en-US">
(returning 1 for </SPAN><SPAN LANG="en-US"><I>true</I></SPAN><SPAN LANG="en-US">,
and 0 for </SPAN><SPAN LANG="en-US"><I>false</I></SPAN><SPAN LANG="en-US">).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Even
</SPAN><SPAN LANG="en-US"><I>maximum</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>minimum</I></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><I>compare</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
operations are available for strings</SPAN></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=146>
	<COL WIDTH=190>
	<COL WIDTH=281>
	<TR VALIGN=TOP>
		<TD WIDTH=146 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>?&lt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=190 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_min</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=281 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER>&ldquo;<I>lesser&rdquo;
			of strings <B>s</B> and <B>t</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=146 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>?&gt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=190 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_max</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=281 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER>&ldquo;<I>greater&rdquo;
			of strings <B>s</B> and <B>t</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=146 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">s<FONT FACE="Courier New, monospace">&nbsp;</FONT>&lt;?&gt;$<FONT FACE="Courier New, monospace">&nbsp;</FONT>t</FONT></P>
		</TD>
		<TD WIDTH=190 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_cmp</B>(s,
			t)</FONT></P>
		</TD>
		<TD WIDTH=281 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>string compare <B>s</B>
			and <B>t</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-US">inal
operation </SPAN><SPAN LANG="en-US"><B>s_</B></SPAN><SPAN LANG="en-US"><B>cmp</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">t</SPAN><SPAN LANG="en-US">) </SPAN><SPAN LANG="en-US">is
string equivalent of numeric </SPAN><SPAN LANG="en-US"><B>cmp</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>u_cmp</B></SPAN><SPAN LANG="en-US">.
It </SPAN><SPAN LANG="en-US">returns not &ldquo;boolean&rdquo;
result, but </SPAN><SPAN LANG="en-US">relative </SPAN><SPAN LANG="en-US">dictionary
</SPAN><SPAN LANG="en-US">order</SPAN><SPAN LANG="en-US">ing</SPAN><SPAN LANG="en-US">
of </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US"> and
</SPAN><SPAN LANG="en-US"><I>t</I></SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
-1 (if </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">&nbsp;&lt;</SPAN><SPAN LANG="en-US">$</SPAN><SPAN LANG="en-US">&nbsp;</SPAN><SPAN LANG="en-US"><I>t</I></SPAN><SPAN LANG="en-US">),
1 (if </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">&nbsp;&gt;</SPAN><SPAN LANG="en-US">$</SPAN><SPAN LANG="en-US">&nbsp;</SPAN><SPAN LANG="en-US"><I>t</I></SPAN><SPAN LANG="en-US">)
or 0 (if </SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">&nbsp;==</SPAN><SPAN LANG="en-US">$</SPAN><SPAN LANG="en-US">&nbsp;</SPAN><SPAN LANG="en-US"><I>t</I></SPAN><SPAN LANG="en-US">).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are operations to search for substring in string:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=129>
	<COL WIDTH=211>
	<COL WIDTH=277>
	<TR VALIGN=TOP>
		<TD WIDTH=129 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">s</SPAN>&nbsp;&lt;&lt;$&nbsp;ss</FONT></P>
		</TD>
		<TD WIDTH=211 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_findlast</B>(s,
			ss)</FONT></P>
		</TD>
		<TD WIDTH=277 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>locate last
			occurrence of <B>ss</B> in <B>s</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=129 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">s</SPAN>&nbsp;&gt;&gt;$&nbsp;ss</FONT></P>
		</TD>
		<TD WIDTH=211 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_findfirst</B>(s,
			ss)</FONT></P>
		</TD>
		<TD WIDTH=277 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>locate first
			occurrence of <B>ss</B> in <B>s</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
They try to find either first (= from the beginning) or last (= from
the end) occurrence of substring <I>ss</I> in string <I>s</I>. (As
with all compare operations, active collation rules may have effect.)
Return value is offset of <I>ss</I><SPAN STYLE="font-style: normal">
</SPAN><SPAN STYLE="font-style: normal">in </SPAN><I>s</I> (or -1, if
<I>ss</I> is not found in <I>s</I>).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are functors for quick finding common initial and final
fragment of two string operands:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=308>
	<COL WIDTH=317>
	<TR VALIGN=TOP>
		<TD WIDTH=308 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>common_head</B></SPAN>(s,
			<SPAN LANG="en-US">t</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=317 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">find
			common prefix</SPAN> of <B>s</B> <SPAN LANG="en-US">and</SPAN> <SPAN LANG="en-US"><B>t</B></SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=308 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>common_tail</B></SPAN>(s,
			<SPAN LANG="en-US">t</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=317 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">find
			common</SPAN> <SPAN LANG="en-US">suffix </SPAN>of <B>s</B> <SPAN LANG="en-US">and</SPAN>
			<SPAN LANG="en-US"><B>t</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
First operation returns longest common &ldquo;prefix&rdquo; part of
its operands, second &ndash; longest common &ldquo;suffix&rdquo;
part. Result is empty string, if <I>s</I> and <I>t</I> have no common
prefix and/or suffix.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there are case conversion operations:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=292>
	<COL WIDTH=333>
	<TR VALIGN=TOP>
		<TD WIDTH=292 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>ucase</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=333 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">c</SPAN><SPAN LANG="en-US">onvert
			</SPAN><SPAN LANG="en-US">entire</SPAN><SPAN LANG="en-US"> string</SPAN>
			<B>s</B> <SPAN LANG="en-US">to upper case</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=292 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>lcase</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=333 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">convert </SPAN><SPAN LANG="en-US">entire</SPAN><SPAN LANG="en-US">
			string </SPAN><SPAN LANG="en-US"><B>s</B></SPAN><SPAN LANG="en-US">
			to lower case</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=292 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><B>i</B><SPAN LANG="en-US"><B>case</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=333 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">invert case of </SPAN><SPAN LANG="en-US">entire</SPAN><SPAN LANG="en-US">
			string </SPAN><SPAN LANG="en-US"><B>s</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
These operations return result, applying required case conversion to
all characters of the operand string. The operations listed below
affect only <I>first</I> character:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=266>
	<COL WIDTH=359>
	<TR VALIGN=TOP>
		<TD WIDTH=266 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>ucfirst</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=359 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">convert
			</SPAN><SPAN LANG="en-US">only </SPAN><SPAN LANG="en-US">first
			character of string</SPAN> <B>s</B> <SPAN LANG="en-US">to upper
			case</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=266 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><SPAN LANG="en-US"><B>lcfirst</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=359 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">convert </SPAN><SPAN LANG="en-US">only </SPAN><SPAN LANG="en-US">first
			character of string </SPAN><SPAN LANG="en-US"><B>s</B></SPAN><SPAN LANG="en-US">
			to </SPAN><SPAN LANG="en-US">low</SPAN><SPAN LANG="en-US">er case</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=266 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_</B><B>i</B><SPAN LANG="en-US"><B>cfirst</B></SPAN>(s)</FONT></P>
		</TD>
		<TD WIDTH=359 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">invert case of first character of string </SPAN><SPAN LANG="en-US"><B>s</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The implicit coercions can be applied to strings. When any numeric
scalar is used where string is required &ndash; it is converted to
string automatically. (So, all scalar values are <I>mutually
coercible</I>.) Its important to note, what (almost) all of AWL
functors are <I>strictly-typed</I> (although variables are not)!
Scalar functors normally know, which type of operand(s) to expect,
and they force coercion to required type, if it is possible. (The
type of return is usually quite predictable, too.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There is explicit coercion to string:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=217>
	<COL WIDTH=408>
	<TR VALIGN=TOP>
		<TD WIDTH=217 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>string</B>(v)</FONT></P>
		</TD>
		<TD WIDTH=408 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>coerce scalar
			(usually numeric) <SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN>to string</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
All numbers in string form are represented as <I>decimal</I> values.
When conversion to/from other numeric base is needed, the following
functors can be used.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Converting <I>i</I><I>ntegers</I> to <I>strings</I>:</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=244>
	<COL WIDTH=381>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_hex</B>(num)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert integer
			<SPAN LANG="en-US"><B>num</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			hexadecimal string</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_oct</B>(num)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert integer
			<SPAN LANG="en-US"><B>num</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			octal string</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_dec</B>(num)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert integer
			<SPAN LANG="en-US"><B>num</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			decimal string</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_bin</B>(num)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert integer
			<SPAN LANG="en-US"><B>num</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			binary string</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>s_base</B>(N,
			num)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert integer
			<SPAN LANG="en-US"><B>num</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			string (<SPAN LANG="en-US">by </SPAN>base <B>N</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Converting <I>strings</I> to <I>integers</I>:</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=244>
	<COL WIDTH=381>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>n_hex</B>(str)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert
			hexadecimal string <SPAN LANG="en-US"><B>str</B></SPAN><SPAN LANG="en-US">
			</SPAN>to integer</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>n_oct</B>(str)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert octal
			string <SPAN LANG="en-US"><B>str</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			integer</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>n_dec</B>(str)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert decimal
			string <SPAN LANG="en-US"><B>str</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			integer</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>n_bin</B>(str)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert binary
			string <SPAN LANG="en-US"><B>str</B></SPAN><SPAN LANG="en-US"> </SPAN>to
			integer</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=244 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>n_base</B>(N,
			str)</FONT></P>
		</TD>
		<TD WIDTH=381 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>convert string <SPAN LANG="en-US"><B>str</B></SPAN><SPAN LANG="en-US">
			</SPAN>to integer (<SPAN LANG="en-US">by </SPAN>base <B>N</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Possible conversion base (<I>N</I>) can vary from 2 to 36. When
<I>N</I>&nbsp;&gt;&nbsp;10, the latin letters A..Z (either upper- or
lowercase) are used for digits from 10 to <I>N</I>-10-1.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there are predicate functors to check for all scalar data
types:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=217>
	<COL WIDTH=408>
	<TR VALIGN=TOP>
		<TD WIDTH=217 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_int</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=408 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> <SPAN LANG="en-US">integer</SPAN>
			<SPAN LANG="en-US">value?</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=217 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_float</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=408 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> <SPAN LANG="en-US">float</SPAN>
			<SPAN LANG="en-US">value?</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=217 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_num</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=408 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> <SPAN LANG="en-US">numeric</SPAN>
			<SPAN LANG="en-US">value (</SPAN><SPAN LANG="en-US">either </SPAN><SPAN LANG="en-US">integer
			or float)?</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=217 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><B>string</B>(v)</FONT></P>
		</TD>
		<TD WIDTH=408 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> string <SPAN LANG="en-US">value?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
(As all predicates, these ones return 1 on successful test, and 0 on
failure.)</P>
<H3 CLASS="western"><SPAN LANG="en-US">Variables and </SPAN>mutators</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Like
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">almost</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">
any programming language in existence, AWL has </SPAN><SPAN LANG="en-US"><I>variables</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">As o</SPAN><SPAN LANG="en-US">pposite</SPAN><SPAN LANG="en-US">
to </SPAN><SPAN LANG="en-US">(always </SPAN><SPAN LANG="en-US"><I>immutable</I></SPAN><SPAN LANG="en-US">)
</SPAN><SPAN LANG="en-US">scalar values, variables are </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US"><I>
&ndash; </I></SPAN><SPAN LANG="en-US">their value can change during
program execution. </SPAN><SPAN LANG="en-US">And v</SPAN><SPAN LANG="en-US">ariables
are </SPAN><SPAN LANG="en-US"><I>typeless</I></SPAN><SPAN LANG="en-US">:
</SPAN><SPAN LANG="en-US">not only contained value, but its type, </SPAN><SPAN LANG="en-US">may
</SPAN><SPAN LANG="en-US">be </SPAN><SPAN LANG="en-US">change</SPAN><SPAN LANG="en-US">d</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">as well</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Depending
from their scope </SPAN><SPAN LANG="en-US">and life range</SPAN><SPAN LANG="en-US">
&ndash; </SPAN><SPAN LANG="en-US">there are different kinds of
variables. The modul</SPAN><SPAN LANG="en-US">ar</SPAN><SPAN LANG="en-US">
(session) </SPAN><SPAN LANG="en-US"><I>global</I></SPAN><SPAN LANG="en-US">
variables </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">by
default</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US"> do not
require explicit declaration</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">t</SPAN><SPAN LANG="en-US">hey start </SPAN><SPAN LANG="en-US">to
</SPAN><SPAN LANG="en-US">exist, as they are first referenced </SPAN><SPAN LANG="en-US">in
source code</SPAN><SPAN LANG="en-US">. By default, they have no
value</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US"> the
absence of value, or </SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>undef</B></SPAN></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">or () </SPAN><SPAN LANG="en-US">is </SPAN><SPAN LANG="en-US">a
</SPAN><SPAN LANG="en-US">special kind of value in AWL.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">To
change variables, special </SPAN><SPAN LANG="en-US">kind of </SPAN><SPAN LANG="en-US">functor</SPAN><SPAN LANG="en-US">s
(</SPAN><SPAN LANG="en-US"><I>mutators</I></SPAN><SPAN LANG="en-US">)
are needed. Probably, most important </SPAN><SPAN LANG="en-US">type
</SPAN><SPAN LANG="en-US">of mutator operations </SPAN><SPAN LANG="en-US">are</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>assignment</I></SPAN><SPAN LANG="en-US"><I>s</I></SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=150>
	<COL WIDTH=160>
	<COL WIDTH=307>
	<TR VALIGN=TOP>
		<TD WIDTH=150 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">v</SPAN>&nbsp;=&nbsp;w</FONT></P>
		</TD>
		<TD WIDTH=160 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>set</B>(v,
			w)</FONT></P>
		</TD>
		<TD WIDTH=307 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>assign <SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">result</SPAN>
			of<SPAN LANG="en-US">)</SPAN> <B>w</B> to <B>v</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=150 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">v&nbsp;:=&nbsp;w</FONT></P>
		</TD>
		<TD WIDTH=160 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>let</B>(v,
			w)</FONT></P>
		</TD>
		<TD WIDTH=307 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>assign <B>w</B> to
			<B>v</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">When
</SPAN><SPAN LANG="en-US"><B>set</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">&nbsp;</SPAN></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>w</I></SPAN><SPAN LANG="en-US">) is
evaluated&nbsp;&ndash; it evaluates </SPAN><SPAN LANG="en-US"><I>w</I></SPAN><SPAN LANG="en-US">,
and assigns result to </SPAN><SPAN LANG="en-US">any </SPAN><SPAN LANG="en-US">mutable
</SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">. </SPAN><SPAN LANG="en-US">This
is called </SPAN><SPAN LANG="en-US"><I>eager</I></SPAN><SPAN LANG="en-US">
assignment. An</SPAN><SPAN LANG="en-US"> alternate form of assignment
</SPAN><SPAN LANG="en-US">is</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><B>let</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">&nbsp;</SPAN></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>w</I></SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>lazy assignment</I></SPAN><SPAN LANG="en-US">,
which </SPAN><SPAN LANG="en-US"><I>does not evaluate</I></SPAN><SPAN LANG="en-US">
second operand. </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">It
will be explained later, as we discuss </SPAN><SPAN LANG="en-US"><I>lazy
evaluations</I></SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">in
detail.</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US"> The
value assigned is </SPAN><SPAN LANG="en-US">always </SPAN><SPAN LANG="en-US">returned
as result </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">and </SPAN><SPAN LANG="en-US">it
</SPAN><SPAN LANG="en-US">may be used in following evaluations</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.
For example:</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">a = b = c = 2*d;</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">assigns
value of </SPAN><SPAN LANG="en-US"><I>d</I></SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">multiplied by 2 </SPAN><SPAN LANG="en-US">to
variables </SPAN><SPAN LANG="en-US"><I>a</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>b</I></SPAN><SPAN LANG="en-US"> and </SPAN><SPAN LANG="en-US"><I>c</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">Or:</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">c = (a = 10 + x) * (b = 20 + y);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">The
</SPAN><SPAN LANG="en-US"><I>increment</I></SPAN><SPAN LANG="en-US">/</SPAN><SPAN LANG="en-US"><I>decrement</I></SPAN><SPAN LANG="en-US">
mutator </SPAN><SPAN LANG="en-US">operation</SPAN><SPAN LANG="en-US">s
can be applied only to mutables with numeric values:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=114>
	<COL WIDTH=159>
	<COL WIDTH=344>
	<TR VALIGN=TOP>
		<TD WIDTH=114 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">++&nbsp;x</FONT></P>
		</TD>
		<TD WIDTH=159 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>inc</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=344 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">P</SPAN>re-increment
			<B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=114 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">x</SPAN>&nbsp;++</FONT></P>
		</TD>
		<TD WIDTH=159 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>inc_p</B>(x)</FONT></P>
		</TD>
		<TD WIDTH=344 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">P</SPAN>ost-increment
			<B>x</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=114 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">--</SPAN>&nbsp;y</FONT></P>
		</TD>
		<TD WIDTH=159 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>dec</B>(y)</FONT></P>
		</TD>
		<TD WIDTH=344 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">P</SPAN>re-decrement
			<B>y</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=114 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">y</SPAN>&nbsp;--</FONT></P>
		</TD>
		<TD WIDTH=159 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>dec_p</B>(y)</FONT></P>
		</TD>
		<TD WIDTH=344 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">P</SPAN>ost-decrement
			<B>y</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=114 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=159 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>clr</B>(z)</FONT></P>
		</TD>
		<TD WIDTH=344 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">C</SPAN>lear
			<B>z</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">All
increments&nbsp;&ndash; add 1 to its operand </SPAN><SPAN LANG="en-US">and</SPAN><SPAN LANG="en-US">
all decrements&nbsp;&ndash; subtract 1 from its operand. Value or
operand can be integer, float or </SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-US">
(in which case it is </SPAN><SPAN LANG="en-US">treated as</SPAN><SPAN LANG="en-US">
0), but </SPAN><SPAN LANG="en-US">it </SPAN><SPAN LANG="en-US">cannot
be string. The </SPAN><SPAN LANG="en-US">prefix and postfix forms
have </SPAN><SPAN LANG="en-US">the </SPAN><SPAN LANG="en-US">same
side effect, </SPAN><SPAN LANG="en-US">and </SPAN><SPAN LANG="en-US">they
differ</SPAN><SPAN LANG="en-US"> only in the returned value: prefix
operations return value </SPAN><SPAN LANG="en-US"><I>after</I></SPAN><SPAN LANG="en-US">
operation, postfix operation return value </SPAN><SPAN LANG="en-US"><I>before</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">Final </SPAN><SPAN LANG="en-US">listed
</SPAN><SPAN LANG="en-US">operation (</SPAN><SPAN LANG="en-US"><B>clr</B></SPAN><SPAN LANG="en-US">)
just assigns </SPAN><SPAN LANG="en-US">0</SPAN><SPAN LANG="en-US"> to
its operand </SPAN><SPAN LANG="en-US">(if operand </SPAN><SPAN LANG="en-US">already
</SPAN><SPAN LANG="en-US">contains float value, 0.0 is assigned
</SPAN><SPAN LANG="en-US">instead</SPAN><SPAN LANG="en-US">).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Most scalar unary and binary operations can be <I>combined with</I><SPAN STYLE="font-style: normal">
assignments. </SPAN><SPAN STYLE="font-style: normal">There is a
special shortcut syntax (internally implemented with special built-in
</SPAN><SPAN STYLE="font-style: normal"><B>comb</B></SPAN><SPAN STYLE="font-style: normal">).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=163>
	<COL WIDTH=219>
	<COL WIDTH=235>
	<TR VALIGN=TOP>
		<TD WIDTH=163 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">v
			= <B>bin_op&nbsp;</B>:&nbsp;w</FONT></P>
		</TD>
		<TD WIDTH=219 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>comb</B><SPAN STYLE="font-weight: normal">(</SPAN><B>bin_</B><SPAN LANG="en-US"><B>func</B></SPAN>(v,
			w))</FONT></P>
		</TD>
		<TD WIDTH=235 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>same as: </I><SPAN STYLE="font-style: normal">v
			</SPAN><I>= </I><SPAN STYLE="font-style: normal">v </SPAN><SPAN STYLE="font-style: normal"><B>bin_op</B></SPAN><SPAN STYLE="font-style: normal">
			w</SPAN></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">v
			=: <B>un_op</B></FONT></P>
		</TD>
		<TD WIDTH=219 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>comb</B><SPAN STYLE="font-weight: normal">(</SPAN><B>un_</B><SPAN LANG="en-US"><B>func</B></SPAN><SPAN STYLE="font-weight: normal">(v))</SPAN></FONT></P>
		</TD>
		<TD WIDTH=235 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>same as: </I><SPAN STYLE="font-style: normal">v
			</SPAN><I>= </I><SPAN STYLE="font-style: normal"><B>un_op</B></SPAN><SPAN STYLE="font-style: normal">
			v</SPAN></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
They evaluate first mutable operand (<I>v</I>) only once (this may be
important, when it is not just a variable).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Binary operations<SPAN LANG="ru-RU">,</SPAN> permitted as <B>bin_o</B><B>p</B>,
are:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">+ - * / % %% ?&lt; ?&gt; &lt;&lt;
&gt;&gt; &amp; | ~ +$ *$ ?&lt;$ ?&gt;$</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Unary operations, permitted as <B>un_op</B>, are:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">+ - ~ <SPAN LANG="en-US">~$</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For example:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">a&nbsp;=+:&nbsp;10.5;		<SPAN LANG="en-US">(</SPAN><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Add
10.5 to </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">variable
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>a</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">)<BR></SPAN></FONT>a&nbsp;=<SPAN LANG="en-US">|:</SPAN>&nbsp;\xF0F0;		<SPAN LANG="en-US">(</SPAN><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Bitwise
OR </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">variable
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>a</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
with hex F0F0</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">)<BR></SPAN></FONT><SPAN LANG="en-US">s&nbsp;</SPAN>=<SPAN LANG="en-US">+$:&nbsp;</SPAN>&quot;.&quot;;		<FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">(Concatenate</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
value of </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">variable
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>s</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
with &ldquo;.&rdquo;</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">)<BR></SPAN></FONT>r
=:-;			<SPAN LANG="en-US">(</SPAN><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Numeric
negation of </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">variable
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>r</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">)<BR></SPAN></FONT>z
=:~;			<FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">(</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Bit</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">wise</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
inversion of </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>z</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">)</SPAN></FONT></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Internally, these implemented exactly as:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">comb (add (a, 10.5));<BR>comb (or
(a, \xF0F0));<BR>comb (s_cat (s, &quot;.&quot;));<BR>comb (neg
(r));<BR>comb (not (z));</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Only <I>scalar</I> operations can be combined (using <B>comb</B>)
with assignments. All required coercions (numbers to strings, strings
to numbers) can be applied to operands, when needed.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, another useful mutator operation is <I>swapping</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=143>
	<COL WIDTH=171>
	<COL WIDTH=303>
	<TR VALIGN=TOP>
		<TD WIDTH=143 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">v</SPAN>&nbsp;:=:&nbsp;w</FONT></P>
		</TD>
		<TD WIDTH=171 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>swap</B><SPAN STYLE="font-weight: normal">(</SPAN>v,
			w)</FONT></P>
		</TD>
		<TD WIDTH=303 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Exchange values of
			<B>v</B> and <B>w</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Values of mutables <I>v</I> and <I>w</I> are just exchanged (and no
other evaluations are done).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Trying to change something non-mutable&nbsp;&ndash; results in
run-time error. There is a way to check explicitly, is expression
mutable or not:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=282>
	<COL WIDTH=343>
	<TR VALIGN=TOP>
		<TD WIDTH=282 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><SPAN LANG="en-US"><B>mut</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=343 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> m<SPAN LANG="en-US">utable</SPAN><SPAN LANG="en-US">?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This is true, if <I>v</I> evaluates to anything mutable (and false
otherwise).</P>
<H3 LANG="en-US" CLASS="western">Conditions and iterators</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">S</SPAN><SPAN LANG="en-US">calar
functors </SPAN><SPAN LANG="en-US"><I>unconditionally</I></SPAN><SPAN LANG="en-US">
evaluate their arguments. </SPAN><SPAN LANG="en-US">For other
functors, </SPAN><SPAN LANG="en-US">this is </SPAN><SPAN LANG="en-US"><I>not</I></SPAN><SPAN LANG="en-US">
always the case.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">The
principal feature of language semantics is </SPAN><SPAN LANG="en-US"><I>optional
</I></SPAN><SPAN LANG="en-US">(or </SPAN><SPAN LANG="en-US"><I>lazy</I></SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US"><I>
evaluation</I></SPAN><SPAN LANG="en-US"> of arguments for many
built-in functors. There are functors, evaluating their argument
optionally (</SPAN><SPAN LANG="en-US"><I>conditionals</I></SPAN><SPAN LANG="en-US">),
which are used to </SPAN><SPAN LANG="en-US">implement </SPAN><SPAN LANG="en-US">decision</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">logic</SPAN><SPAN LANG="en-US">. </SPAN><SPAN LANG="en-US">Also,
t</SPAN><SPAN LANG="en-US">here are functors, evaluating some
arguments </SPAN><SPAN LANG="en-US">many</SPAN><SPAN LANG="en-US">
times (</SPAN><SPAN LANG="en-US"><I>iterators</I></SPAN><SPAN LANG="en-US">),
which are used to implement loop</SPAN><SPAN LANG="en-US">ing </SPAN><SPAN LANG="en-US">logic</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Before
discussing conditionals, it's important to </SPAN><SPAN LANG="en-US">note</SPAN><SPAN LANG="en-US">,
what AWL has no distinct </SPAN><SPAN LANG="en-US"><I>boolean type</I></SPAN><SPAN LANG="en-US">,
but values of other (</SPAN><SPAN LANG="en-US">usually</SPAN><SPAN LANG="en-US">
scalar) types effectively serve as boolean. </SPAN><SPAN LANG="en-US">But
w</SPAN><SPAN LANG="en-US">hen some functor </SPAN><SPAN LANG="en-US"><I>expects</I></SPAN><SPAN LANG="en-US">
boolean operand&nbsp;&ndash; it normally means, what </SPAN><SPAN LANG="en-US">numeric
</SPAN><SPAN LANG="en-US">zero values (0 or 0.0), empty string (&ldquo;&rdquo;)
or undefined value () is considered </SPAN><SPAN LANG="en-US"><B>false</B></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">but</SPAN><SPAN LANG="en-US"> anything
</SPAN><SPAN LANG="en-US">different</SPAN><SPAN LANG="en-US"> is
</SPAN><SPAN LANG="en-US"><B>true</B></SPAN><SPAN LANG="en-US">. When
built-in functor </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>predicate</I></SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>returns</I></SPAN><SPAN LANG="en-US">
boolean, the results are </SPAN><SPAN LANG="en-US">usually </SPAN><SPAN LANG="en-US">more
restricted: 0 for </SPAN><SPAN LANG="en-US"><B>false</B></SPAN><SPAN LANG="en-US">,
and 1 for </SPAN><SPAN LANG="en-US"><B>true</B></SPAN><SPAN LANG="en-US">.
(</SPAN><SPAN LANG="en-US">A</SPAN><SPAN LANG="en-US">ll comparison
operations on numbers and strings do </SPAN><SPAN LANG="en-US">work
this way</SPAN><SPAN LANG="en-US">).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The simplest form of conditionals are <I>lazy</I> (or <I>short-circuit</I>)
binary logical operations:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=121>
	<COL WIDTH=167>
	<COL WIDTH=329>
	<TR VALIGN=TOP>
		<TD WIDTH=121 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;&amp;&amp;&nbsp;Q</FONT></P>
		</TD>
		<TD WIDTH=167 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>c_and</B><SPAN STYLE="font-weight: normal">(P</SPAN>,
			@Q)</FONT></P>
		</TD>
		<TD WIDTH=329 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Conditional AND:
			if <B>P</B>, then <B>Q</B>, else 0</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;||&nbsp;Q</FONT></P>
		</TD>
		<TD WIDTH=167 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>c_or</B><SPAN STYLE="font-weight: normal">(P</SPAN>,
			@Q)</FONT></P>
		</TD>
		<TD WIDTH=329 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Conditional OR: if
			<B>P</B>, then 1, else <B>Q</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">~~&nbsp;P</FONT></P>
		</TD>
		<TD WIDTH=167 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>c_not</B>(P)</FONT></P>
		</TD>
		<TD WIDTH=329 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Conditional <SPAN LANG="en-US">NOT</SPAN>:
			if <B>P</B>, then <SPAN LANG="en-US">0</SPAN>, else <SPAN LANG="en-US">1</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
First two functors (<B>c_and</B>, <B>c_or</B>) <I>always</I> evaluate
first operand (<I><SPAN STYLE="font-weight: normal">P</SPAN></I>),
but evaluation of second (<I>Q</I>) is optional. (Here, and later, we
are using prefix &ldquo;@&rdquo; to indicate demand-evaluation of
prefixed functor operand. This in NOT part of syntax!) Second operand
is evaluated (and returned), only if first operand evaluates to <B>true</B>
(for <B>c_and</B>) or to <B>false</B> (for <B>c_or</B>). Otherwise,
second operand is <I>not</I> evaluated, and returned value is 0 (for
<B>c_and</B>) and 1 (for <B>c_or</B>). Final functor (<B>c_not</B>)
implements simple logical negation: result is <B>false</B>, if
operand evaluates to <B>true</B>, and vice versa.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For more complex decisions, <I>ternary</I> logical operators are
available:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=125>
	<COL WIDTH=177>
	<COL WIDTH=315>
	<TR VALIGN=TOP>
		<TD WIDTH=125 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;?&nbsp;A&nbsp;:&nbsp;B</FONT></P>
		</TD>
		<TD WIDTH=177 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>if</B><SPAN STYLE="font-weight: normal">(P</SPAN>,
			@A, @B)</FONT></P>
		</TD>
		<TD WIDTH=315 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Positive
			conditional <SPAN LANG="en-US">branch</SPAN><SPAN LANG="en-US">ing</SPAN>:<BR>if
			<B>P</B>, then <B>A</B>, else <B>B</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=125 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;~?&nbsp;A&nbsp;:&nbsp;B</FONT></P>
		</TD>
		<TD WIDTH=177 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>unless</B><SPAN STYLE="font-weight: normal">(P</SPAN>,
			@A, @B)</FONT></P>
		</TD>
		<TD WIDTH=315 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Negative
			conditional <SPAN LANG="en-US">branch</SPAN><SPAN LANG="en-US">ing</SPAN>:<BR>if
			<B>P</B>, then <SPAN LANG="en-US"><B>B</B></SPAN>, else <SPAN LANG="en-US"><B>A</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
These operations always evaluate first operand (<I>P</I>), but
evaluation of second (<I>A</I>) and third (<I>B</I>) is optional (and
only one of these two is evaluated, depending from result of <I>P</I>).
The difference between <B>if</B> and <B>unless</B> is only in
polarity of condition <I>P</I>. Both functors return value, which is
result of the argument (<I>A</I> or <I>B</I>) evaluated. Note, what
third argument can be completely omitted: in this case, it is assumed
to be (). (In operator form, operand <I>B</I> can be <SPAN STYLE="font-style: normal">completely
empty.</SPAN><SPAN STYLE="font-style: normal">)</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
To repeat some action many times (while some condition remains either
<B>true</B> or <B>false</B>) <I>conditional iterators</I> are used.
Actually, these may be either <I>pre-conditional</I> or
<I>post-conditional</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=121>
	<COL WIDTH=163>
	<COL WIDTH=333>
	<TR VALIGN=TOP>
		<TD WIDTH=121 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;??&nbsp;R</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>while</B><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">@</SPAN></SPAN><SPAN STYLE="font-weight: normal">P</SPAN>,
			@R)</FONT></P>
		</TD>
		<TD WIDTH=333 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Positive
			(pre)conditional loop:<BR>while <B>P</B> is true, <SPAN LANG="en-US">repeat</SPAN>
			<B>R</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=121 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">P&nbsp;~??&nbsp;R</FONT></P>
		</TD>
		<TD WIDTH=163 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>until</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">@</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">P</SPAN></SPAN><SPAN LANG="en-US">,</SPAN>
			@R)</FONT></P>
		</TD>
		<TD WIDTH=333 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Negative
			(pre)conditional loop:<BR>while <B>P</B> is false, <SPAN LANG="en-US">repeat</SPAN>
			<B>R</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For these functors, the loop body (<I>R</I>) may be evaluated many
times (or, probably, never). Evaluation continues, while value of
condition <I>P</I> remains <B>true</B> (for <B>while</B>) and <B>false</B>
(for <B>until</B>) (So, <B>while</B> and <B>until</B> differ only by
condition polarity.) These iterators are <I>pre-conditional</I>: if
check of <I>P</I> fails <I>immediately</I>, <I>R</I> is never
evaluated.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
However, <I>post-conditional</I> iterators check <I>P</I> only <I>after</I>
evaluation of <I>R</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=103>
	<COL WIDTH=173>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=103 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">??&nbsp;(R)&nbsp;P</FONT></P>
		</TD>
		<TD WIDTH=173 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>do_while</B><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">@</SPAN></SPAN><SPAN STYLE="font-weight: normal">P</SPAN>,
			@R)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Positive
			(post)conditional loop:<BR><SPAN LANG="en-US">repeat</SPAN> <B>R</B>,
			while <B>P</B> is true</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=103 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">~??&nbsp;(R)&nbsp;P</FONT></P>
		</TD>
		<TD WIDTH=173 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>do_until</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">@</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">P</SPAN></SPAN><SPAN LANG="en-US">,</SPAN>
			@R)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Negative
			(post)conditional loop:<BR><SPAN LANG="en-US">repeat</SPAN> <B>R</B>,
			while <B>P</B> is false</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">For
</SPAN><SPAN LANG="en-US"><B>do_while</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>do_until</B></SPAN><SPAN LANG="en-US">
loop body </SPAN><SPAN LANG="en-US"><I>R</I></SPAN><SPAN LANG="en-US">
is always evaluated </SPAN><SPAN LANG="en-US">at least </SPAN><SPAN LANG="en-US">once.
</SPAN><SPAN LANG="en-US">Note, what </SPAN><SPAN LANG="en-US">all
</SPAN><SPAN LANG="en-US">these iterators return a value too, which
is result of </SPAN><SPAN LANG="en-US"><I>final</I></SPAN><SPAN LANG="en-US">
evaluation of </SPAN><SPAN LANG="en-US"><I>R </I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(or
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>undef</B></SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
if </SPAN></SPAN><SPAN LANG="en-US"><I>R</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
never was evaluated)</SPAN></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>Arithmetic
iterators</I></SPAN><SPAN LANG="en-US"> are used to implement loops
with index variable </SPAN><SPAN LANG="en-US">changing through</SPAN><SPAN LANG="en-US">
some range </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">in
either incremental or decremental order</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=185>
	<COL WIDTH=197>
	<COL WIDTH=235>
	<TR VALIGN=TOP>
		<TD WIDTH=185 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
			<FONT FACE="Courier New, monospace">??&nbsp;<SPAN LANG="en-US">V&nbsp;=&nbsp;</SPAN><SPAN LANG="ru-RU">(</SPAN><SPAN LANG="en-US">R</SPAN><SPAN LANG="ru-RU">)</SPAN><SPAN LANG="en-US">++&nbsp;:&nbsp;Loop</SPAN></FONT></P>
		</TD>
		<TD WIDTH=197 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>for_inc</B><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">V</SPAN></SPAN>,
			R, @Loop)</FONT></P>
		</TD>
		<TD WIDTH=235 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Incremental <SPAN LANG="en-US">range
			</SPAN>iterator:<BR>for <SPAN LANG="en-US"><B>V</B></SPAN><SPAN LANG="en-US">&nbsp;=
			</SPAN><SPAN LANG="en-US">(</SPAN>all values in <B>Range</B><SPAN LANG="en-US">)<BR></SPAN>do
			<B>Loop </B>(in ascending order)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
			<FONT FACE="Courier New, monospace">??&nbsp;<SPAN LANG="en-US">V&nbsp;=&nbsp;</SPAN><SPAN LANG="ru-RU">(</SPAN><SPAN LANG="en-US">R</SPAN><SPAN LANG="ru-RU">)</SPAN><SPAN LANG="en-US">--&nbsp;:&nbsp;Loop</SPAN></FONT></P>
		</TD>
		<TD WIDTH=197 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>for_dec</B><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">V</SPAN></SPAN><SPAN STYLE="font-weight: normal">,
			R, @Loop</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=235 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Decremental <SPAN LANG="en-US">range
			</SPAN>iterator:<BR>for <SPAN LANG="en-US"><B>V</B></SPAN><SPAN LANG="en-US">&nbsp;=
			</SPAN><SPAN LANG="en-US">(</SPAN>all values in <B>Range</B><SPAN LANG="en-US">)<BR></SPAN>do
			<B>Loop </B>(in descending order)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
			<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace">??&nbsp;</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">N</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">
			: Loop</SPAN></FONT></FONT></P>
		</TD>
		<TD WIDTH=197 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>times</B><SPAN STYLE="font-weight: normal">(N,
			@Loop</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=235 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Do <B>Loop</B>
			exactly <B>N</B> times</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Here,
</SPAN><SPAN LANG="en-US"><I>var</I></SPAN><SPAN LANG="en-US"> is </SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">any
</SPAN></SPAN><SPAN LANG="en-US"><I>variable</I></SPAN><SPAN LANG="en-US">
(in fact, it can be any </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US">,
although variables normally suffice), which </SPAN><SPAN LANG="en-US">is
used</SPAN><SPAN LANG="en-US"> as </SPAN><SPAN LANG="en-US"><I>loop
index variable</I></SPAN><SPAN LANG="en-US">. Operand </SPAN><SPAN LANG="en-US"><I>Range</I></SPAN><SPAN LANG="en-US">
provides range of values, for which loop must be evaluated. Usually,
</SPAN><SPAN LANG="en-US"><I>Range</I></SPAN><SPAN LANG="en-US"> is
two-element list (</SPAN><SPAN LANG="en-US"><I>Low, High</I></SPAN><SPAN LANG="en-US">)
(shortcut syntax </SPAN><SPAN LANG="en-US"><I>Low</I></SPAN><SPAN LANG="en-US">..</SPAN><SPAN LANG="en-US"><I>High</I></SPAN><SPAN LANG="en-US">
is preferred), for which </SPAN><SPAN LANG="en-US"><I>Low</I></SPAN><SPAN LANG="en-US">
is </SPAN><SPAN LANG="en-US"><I>lower</I></SPAN><SPAN LANG="en-US">
limit (</SPAN><SPAN LANG="en-US"><I>inclusive</I></SPAN><SPAN LANG="en-US">),
and </SPAN><SPAN LANG="en-US"><I>High</I></SPAN><SPAN LANG="en-US">
is </SPAN><SPAN LANG="en-US"><I>upper</I></SPAN><SPAN LANG="en-US">
limit (</SPAN><SPAN LANG="en-US"><I>exclusive</I></SPAN><SPAN LANG="en-US">).
In other words, range includes all integer values, for which
</SPAN><SPAN LANG="en-US"><I>Low&nbsp;</I></SPAN><SPAN LANG="en-US">&lt;=&nbsp;value&nbsp;&lt;&nbsp;</SPAN><SPAN LANG="en-US"><I>High</I></SPAN><SPAN LANG="en-US">.
If </SPAN><SPAN LANG="en-US"><I>Low&nbsp;&gt;=&nbsp;High</I></SPAN><SPAN LANG="en-US">,
range is considered </SPAN><SPAN LANG="en-US"><I>empty</I></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-US">and </SPAN><SPAN LANG="en-US">in this
case, loop body is never evaluated). If there is only one integer (</SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US">)
specified for range, it is </SPAN><SPAN LANG="en-US">treated</SPAN><SPAN LANG="en-US">
as </SPAN><SPAN LANG="en-US"><I>0..N</I></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Evaluation
</SPAN><SPAN LANG="en-US">of both </SPAN><SPAN LANG="en-US"><B>for</B></SPAN><SPAN LANG="en-US">
iterators is simple: for any integer value in </SPAN><SPAN LANG="en-US"><I>Range</I></SPAN><SPAN LANG="en-US">,
in </SPAN><SPAN LANG="en-US"><I>ascending</I></SPAN><SPAN LANG="en-US">
order (</SPAN><SPAN LANG="en-US"><B>for_inc</B></SPAN><SPAN LANG="en-US">)
or </SPAN><SPAN LANG="en-US"><I>descending</I></SPAN><SPAN LANG="en-US">
order (</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>for_dec</B></SPAN></SPAN><SPAN LANG="en-US">),
this value is assigned to loop variable (</SPAN><SPAN LANG="en-US"><I>var</I></SPAN><SPAN LANG="en-US">),
then loop body (</SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">)
is evaluated. </SPAN><SPAN LANG="en-US">For example&nbsp;&ndash;
evaluation of </SPAN><SPAN LANG="en-US"><B>for_inc</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">,
10..16, </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">)
means evaluation of </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">
for </SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">&nbsp;=&nbsp;10,
11, 12, 13, 14, 15. A</SPAN><SPAN LANG="en-US">lso,</SPAN><SPAN LANG="en-US">
evaluation of </SPAN><SPAN LANG="en-US"><B>for_dec</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>v</I></SPAN><SPAN LANG="en-US">,
-5..5, </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">)&nbsp;&ndash;
evaluates </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">
for </SPAN><SPAN LANG="en-US"><I>v&nbsp;</I></SPAN><SPAN LANG="en-US">=&nbsp;4,
3, 2, 1, 0, -1, -2, -3, -4, -5. The value returned by iterator is the
last result of </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">.
If range is empty, </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">
is never evaluated, and return value is ().</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">B</SPAN><SPAN LANG="en-US">y
the way, there are </SPAN><SPAN LANG="en-US">also </SPAN><SPAN LANG="en-US">predicated
to check quickly, is some value inside range, or outside it:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=263>
	<COL WIDTH=362>
	<TR VALIGN=TOP>
		<TD WIDTH=263 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>inside</B></SPAN>(v<SPAN LANG="en-US">alue,
			Low..High</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=362 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US"><B>alue</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> inside range
			<B>Low</B></I><SPAN STYLE="font-style: normal"><B>&nbsp;</B></SPAN><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">..</SPAN></SPAN><I>&nbsp;<B>High</B><SPAN LANG="en-US"><BR></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><B>Low&nbsp;</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">&lt;=&nbsp;</SPAN></SPAN><I><SPAN LANG="en-US"><B>value</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
			&amp;&amp; </SPAN></SPAN><I><SPAN LANG="en-US"><B>value&nbsp;</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">&lt;&nbsp;</SPAN></SPAN><I><SPAN LANG="en-US"><B>High</B></SPAN><SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=263 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>outside</B></SPAN>(v<SPAN LANG="en-US">alue,
			Low..High</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=362 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US"><B>alue</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> <SPAN LANG="en-US">out</SPAN>side
			range <B>Low&nbsp;</B>..&nbsp;<B>High</B><SPAN LANG="en-US"><BR></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><B>value&nbsp;</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>&lt;&nbsp;</B></SPAN></SPAN><I><SPAN LANG="en-US"><B>Low</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
			|| </SPAN></SPAN><I><SPAN LANG="en-US"><B>High</B></SPAN></I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>&nbsp;</B></SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>&lt;</B></SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>=</B></SPAN></SPAN><I><SPAN LANG="en-US"><B>
			value</B></SPAN><SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
(These work only on integer values!)</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">The
final iterator (</SPAN><SPAN LANG="en-US"><B>times</B></SPAN><SPAN LANG="en-US">)
just evaluate</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
its body (</SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">)
</SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US"> times
(</SPAN><SPAN LANG="en-US">with no </SPAN><SPAN LANG="en-US">explicit
</SPAN><SPAN LANG="en-US">&ldquo;loop variable&rdquo;</SPAN><SPAN LANG="en-US">).
</SPAN><SPAN LANG="en-US">It never evaluates </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">,
if </SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US">&nbsp;&lt;=&nbsp;0.</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">As a</SPAN><SPAN LANG="en-US">ll iterators,
</SPAN><SPAN LANG="en-US">it</SPAN><SPAN LANG="en-US"> return</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
final value of </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">
(or (), if </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">
never was evaluated).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there is a way to iterate <I>forever</I>:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=259>
	<COL WIDTH=366>
	<TR VALIGN=TOP>
		<TD WIDTH=259 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ever</B><SPAN STYLE="font-weight: normal">(</SPAN>@Loop)</FONT></P>
		</TD>
		<TD WIDTH=366 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Repeat <B>Loop</B>
			forever</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">There
is no explicit exit </SPAN><SPAN LANG="en-US">condition</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"> the </SPAN><SPAN LANG="en-US"><B>ever</B></SPAN><SPAN LANG="en-US">
loop. It </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">like</SPAN><SPAN LANG="en-US">
all other iterators) </SPAN><SPAN LANG="en-US">can only be
interrupt</SPAN><SPAN LANG="en-US">ed</SPAN><SPAN LANG="en-US"> by
</SPAN><SPAN LANG="en-US"><I>throwing exception</I></SPAN><SPAN LANG="en-US">
somewhere inside </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">
(and, probably, catching it somewhere outside). Generally, </SPAN><SPAN LANG="en-US"><I>exceptions</I></SPAN><SPAN LANG="en-US">
(discussed in detail later) are the only way to interrupt </SPAN><SPAN LANG="en-US">&ldquo;</SPAN><SPAN LANG="en-US">normal&rdquo;
sequence of evaluation&nbsp;&ndash; for example, to leave loop
prematurely.</SPAN></P>
<H3 LANG="en-US" CLASS="western">Blocks</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Frequently,
</SPAN><SPAN LANG="en-US">both </SPAN><SPAN LANG="en-US">conditions
and loops require</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
a </SPAN></SPAN><SPAN LANG="en-US"><I>sequence of expressions</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-US">to be evaluated </SPAN><SPAN LANG="en-US">in
some order</SPAN><SPAN LANG="en-US">. Simplest way to achieve this is
to use the </SPAN><SPAN LANG="en-US"><I>block expressions</I></SPAN><SPAN LANG="en-US">
(or simply </SPAN><SPAN LANG="en-US"><I>blocks</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">):</SPAN></SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">{ expr1; expr2; &hellip; exprN }</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">This
evaluates all expressions in sequence (from </SPAN><SPAN LANG="en-US"><I>expr1</I></SPAN><SPAN LANG="en-US">
to </SPAN><SPAN LANG="en-US"><I>exprN</I></SPAN><SPAN LANG="en-US">),
and returns value of </SPAN><SPAN LANG="en-US"><I>exprN</I></SPAN><SPAN LANG="en-US">.
Note, what (unlike </SPAN><SPAN LANG="en-US">in </SPAN><SPAN LANG="en-US">C,
C++ or Java) semicolon is always treated as </SPAN><SPAN LANG="en-US"><I>separator</I></SPAN><SPAN LANG="en-US">
in AWL. </SPAN><SPAN LANG="en-US">So, i</SPAN><SPAN LANG="en-US">f
semicolon </SPAN><SPAN LANG="en-US"><I>follows</I></SPAN><SPAN LANG="en-US">
last element of the block, this means the last element of block (and,
so, the return value) is </SPAN><SPAN LANG="en-US">empty</SPAN><SPAN LANG="en-US">.
It is frequently intentionally used to discard return value of the
block, and make () returned instead.</SPAN></P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">{ expr1; expr2; &hellip; exprN; }</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Here,
the </SPAN><SPAN LANG="en-US">side </SPAN><SPAN LANG="en-US">effect
is exactly the same, as above&nbsp;&ndash; but return value of block
is </SPAN><SPAN LANG="en-US">guarantied to be</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US"><I>Warning</I></SPAN><SPAN LANG="en-US">:
</SPAN><SPAN LANG="en-US">do </SPAN><SPAN LANG="en-US">NOT place ';'
after the final element of the block, which return value </SPAN><SPAN LANG="en-US"><I>is
needed</I></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Languages, like C++ or Java do have a special comma operator, to
sequence some actions inside expression. AWL does not have one,
because doesn't need it. Remember, blocks are expressions, and quite
sufficient in this case: you can use { <I>A</I>; <I>B</I> } to
evaluate <I>A</I> before evaluating and using <I>B</I>.</P>
<H3 LANG="en-GB" CLASS="western">Lists, and <SPAN LANG="en-US">list
</SPAN>operations</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Definitely,
t</SPAN><SPAN LANG="en-US">he most important structural data type </SPAN><SPAN LANG="en-US">of
</SPAN><SPAN LANG="en-US">the </SPAN><SPAN LANG="en-US">language </SPAN><SPAN LANG="en-US">is
</SPAN><SPAN LANG="en-US"><I>list</I></SPAN><SPAN LANG="en-US">.
Lists can be of arbitrary length, </SPAN><SPAN LANG="en-US">and</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">lists</SPAN><SPAN LANG="en-US"> are
</SPAN><SPAN LANG="en-US"><I>heterogenic</I></SPAN><SPAN LANG="en-US">:
</SPAN><SPAN LANG="en-US">they </SPAN><SPAN LANG="en-US">can contain
elements of any type </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">including
other lists, with </SPAN><SPAN LANG="en-US">almost </SPAN><SPAN LANG="en-US">unlimited
nesting depth</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are several ways to create lists. The easiest one is using the
<I>round brackets</I>, where list elements must be separated by
commas:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">(1,
2, &ldquo;aaabb&rdquo;, 22.13, &ldquo;cccc&rdquo;</SPAN></FONT>)<BR>((11,
&lsquo;aa&rsquo;), (22, &lsquo;bb&rsquo;), &lsquo;cc&rsquo;)</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
When (like in these cases) all list elements are literals&nbsp;&ndash;
a more compact syntax can be used, with square brackets and blank
spaces for delimiters:</P>
<P LANG="zxx" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">[1
2 &ldquo;aaabb&rdquo; 22.13 &ldquo;cccc&rdquo;]</SPAN></FONT><SPAN LANG="en-US"><BR>[[11
&lsquo;aa&rsquo;] [22 &lsquo;bb&rsquo;] &lsquo;cc&rsquo;]</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
These lists are completely equivalent to above. Actually, not only
literals, but anything with &ldquo;closed syntax&rdquo; can be
included in this list (and lists in both forms are closed-syntax
expressions).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Finally,
there is a </SPAN><SPAN LANG="en-US">special</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>list composer</I></SPAN><SPAN LANG="en-US">
syntax:</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>Head&nbsp;</I><SPAN STYLE="font-style: normal">::&nbsp;</SPAN><I>Tail</I></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">This
</SPAN><SPAN LANG="en-US">creates a list with first element, defined
by </SPAN><SPAN LANG="en-US">expression</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>Head</I></SPAN><SPAN LANG="en-US">, and
all the following element</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">
defined by </SPAN><SPAN LANG="en-US">expression</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>Tail</I></SPAN><SPAN LANG="en-US">.
Actually, this is the way </SPAN><SPAN LANG="en-US"><I>all</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
lists </SPAN></SPAN><SPAN LANG="en-US">are </SPAN><SPAN LANG="en-US">stored</SPAN><SPAN LANG="en-US">
internally. </SPAN><SPAN LANG="en-US">No matter, how they are defined
in source code &ndash; internally, t</SPAN><SPAN LANG="en-US">hey all
are made of </SPAN><SPAN LANG="en-US"><I>list nodes</I></SPAN><SPAN LANG="en-US">
(called &ldquo;cons cells&rdquo; in languages like LISP or Scheme).
</SPAN><SPAN LANG="en-US">For example, a</SPAN><SPAN LANG="en-US">
&ldquo;flat&rdquo; </SPAN><SPAN LANG="en-US">linear </SPAN><SPAN LANG="en-US">list
of </SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US">
elements require</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US">-1 list
nodes to </SPAN><SPAN LANG="en-US">join</SPAN><SPAN LANG="en-US">
them together.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
All &ldquo;bracketed&rdquo; forms of the lists are kind of shortcuts
for list constructors. For example, lists (1, 2, 3, 4, 5) and [1 2 3
4 5]&nbsp;&ndash; are just more compact forms for:</P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">1::2::3::4::5</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">However
</SPAN><SPAN LANG="en-US">(because of</SPAN><SPAN LANG="en-US"> the
way lists are constructed from </SPAN><SPAN LANG="en-US">their </SPAN><SPAN LANG="en-US">nodes</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">
this is not </SPAN><SPAN LANG="en-US">quite </SPAN><SPAN LANG="en-US">easy
to include list as the </SPAN><SPAN LANG="en-US"><I>final element</I></SPAN><SPAN LANG="en-US">
of the </SPAN><SPAN LANG="en-US">other </SPAN><SPAN LANG="en-US">list,
because it just merges itself automatically with the rest of the
list. For example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">(1, (2, (3, (4, 5))))</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
results in absolutely the same list as:</P>
<P LANG="en-GB" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">(1, 2, 3, 4, 5)</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
because all <I>final</I> list elements are <SPAN LANG="en-US">implicitly
</SPAN>merged. However, when it is <I>absolutely needed</I> to have a
list as a final element of other list&nbsp;<SPAN LANG="en-GB">&ndash;
</SPAN>there is a special <SPAN LANG="en-US">method of doing it</SPAN>:</P>
<P LANG="en-GB" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">(1, 2, (3, 4, 5), )</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">This
way, we can define list, with </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">nested</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
list (3, 4, 5) as its </SPAN><SPAN LANG="en-GB"><I>last</I></SPAN><SPAN LANG="en-GB">
element. Technically, the final element of this list is </SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-GB">
()&nbsp;&ndash; </SPAN><SPAN LANG="en-US">which </SPAN><SPAN LANG="en-GB">prevent</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-GB">
(3, 4, 5) from merging with the rest of the list. But </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">by
convention</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB"> most
of the list operations (</SPAN><SPAN LANG="en-US">which are </SPAN><SPAN LANG="en-GB">detailed
below) do not treat </SPAN><SPAN LANG="en-GB"><I>final</I></SPAN><SPAN LANG="en-GB">
() as a </SPAN><SPAN LANG="en-GB"><I>real</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
list element</SPAN></SPAN><SPAN LANG="en-GB">, and silently ignore
it. Such </SPAN><SPAN LANG="en-US">kind</SPAN><SPAN LANG="en-GB"> of
lists is called </SPAN><SPAN LANG="en-GB"><I>open lists</I></SPAN><SPAN LANG="en-GB">
(as opposite to more common </SPAN><SPAN LANG="en-GB"><I>closed</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
ones</SPAN></SPAN><SPAN LANG="en-GB">).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">To
make &ldquo;square bracket&rdquo; open list, a </SPAN><SPAN LANG="en-US">some</SPAN><SPAN LANG="en-GB">
special syntax is required:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[1 2 [3 4 5] :]</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Warning: without terminating colon, this list will be completely
equivalent to [1 2 3 4 5].</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, if you really want <SPAN LANG="en-US">to </SPAN>make open
list using list composer <SPAN LANG="en-US">syntax</SPAN>, you can
try the following:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">1::2::(3::4::5)::()</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
although it <SPAN LANG="en-US">looks</SPAN> <SPAN LANG="en-US">a bit</SPAN>
too verbose.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Actually, the &ldquo;open&rdquo; and &ldquo;closed&rdquo; lists are
different only in handling of their last element &ndash; all elements
<I>before</I> it can be either lists or non-lists, regardless of list
form.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Empty
</SPAN><SPAN LANG="en-US">pair of brackets</SPAN><SPAN LANG="en-US">
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">()</SPAN></SPAN></FONT><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">or [] </SPAN><SPAN LANG="en-US">represent
</SPAN><SPAN LANG="en-US"><I>absence of value</I></SPAN><SPAN LANG="en-US">
(sometimes </SPAN><SPAN LANG="en-US">called</SPAN><SPAN LANG="en-US">
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>undef</B></SPAN></SPAN></FONT><SPAN LANG="en-US">).
Lists, containing just a single element, are </SPAN><SPAN LANG="en-US">usually
</SPAN><SPAN LANG="en-US">identical to this element.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">As</SPAN><SPAN LANG="en-US">
a</SPAN><SPAN LANG="en-US">ll variables, </SPAN><SPAN LANG="en-US">list</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
are </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">Language provides</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">set of </SPAN><SPAN LANG="en-US">functors,
evaluating to mutable result (</SPAN><SPAN LANG="en-US"><I>accessors</I></SPAN><SPAN LANG="en-US">),
which can be used anywhere mutable is expected. </SPAN><SPAN LANG="en-US">The
perfect example is </SPAN><SPAN LANG="en-US"><B>l_item</B></SPAN><SPAN LANG="en-US">
functor: </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>l_item</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(n,&nbsp;L)</SPAN></SPAN></FONT><SPAN LANG="en-US">
(or just </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">L[n]</SPAN></SPAN></FONT><SPAN LANG="en-US">)
provides access to </SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US">-th
element of list </SPAN><SPAN LANG="en-US"><I>L</I></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-US">element </SPAN><SPAN LANG="en-US">indexing
always starts </SPAN><SPAN LANG="en-US">from</SPAN><SPAN LANG="en-US">
0).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=162>
	<COL WIDTH=161>
	<COL WIDTH=294>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">L&nbsp;[i]</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_item</B><SPAN STYLE="font-weight: normal">(i,
			L</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Access
			to e</SPAN>lement of list <B>L</B> with index <B>i</B><BR>(starting
			from 0)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Because
result of evaluation is </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US">,
this operation can be used to change individual elements of the list</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">L</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">[n]&nbsp;=&nbsp;10</SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="ru-RU">;</SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><BR>++&nbsp;L[n]</SPAN></SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Note,
what list index </SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US">
can be negative: in this case, the elements are counted </SPAN><SPAN LANG="en-US"><I>from
the end</I></SPAN><SPAN LANG="en-US"> of the list</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
-1 stands for last element, -2 for element </SPAN><SPAN LANG="en-US">before</SPAN><SPAN LANG="en-US">
last, etc.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Other
examples </SPAN><SPAN LANG="en-US">of </SPAN><SPAN LANG="en-US">list
</SPAN><SPAN LANG="en-US">accessors </SPAN><SPAN LANG="en-US">are
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>l_head</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(</SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><I>L</I></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">)</SPAN></SPAN></FONT><SPAN LANG="en-US">
and </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>l_tail</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(</SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><I>L</I></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">)</SPAN></SPAN></FONT><SPAN LANG="en-US">:
these operations provide access to </SPAN><SPAN LANG="en-US"><I>head</I></SPAN><SPAN LANG="en-US">
of list </SPAN><SPAN LANG="en-US"><I>L</I></SPAN><SPAN LANG="en-US">
(its first element) and </SPAN><SPAN LANG="en-US"><I>tail</I></SPAN><SPAN LANG="en-US">
of list </SPAN><SPAN LANG="en-US"><I>L</I></SPAN><SPAN LANG="en-US">
(all elements except first) respectively. </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">In</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">LISP, </SPAN><SPAN LANG="en-US">equivalent
operations are</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><B>car</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>cdr</B></SPAN><SPAN LANG="en-US">.)
With</SPAN><SPAN LANG="en-US"> these functors, processing and
modifying lists as </SPAN><SPAN LANG="en-US"><I>binary trees</I></SPAN><SPAN LANG="en-US">
(which internally they are in fact) is </SPAN><SPAN LANG="en-US">easy</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=238>
	<COL WIDTH=387>
	<TR VALIGN=TOP>
		<TD WIDTH=238 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_head</B>(L)</FONT></P>
		</TD>
		<TD WIDTH=387 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Head of list
			<B>L</B><BR>(<SPAN LANG="en-US">always </SPAN>same as <B>L</B>[0])</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=238 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_tail</B>(L)</FONT></P>
		</TD>
		<TD WIDTH=387 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Tail of list
			<B>L</B><BR>(all elements of <B>L</B>, except first)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=238 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_head_by</B>(n,
			L)</FONT></P>
		</TD>
		<TD WIDTH=387 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>l_head</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">&nbsp;</SPAN></SPAN><I>(<B>L</B>),
			<SPAN LANG="en-US">repeated</SPAN> <B>n</B> times</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=238 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_tail_by</B>(n,
			L)</FONT></P>
		</TD>
		<TD WIDTH=387 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>l_tail</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">&nbsp;</SPAN></SPAN><I>(<B>L</B>),
			<SPAN LANG="en-US">repeated</SPAN> <B>n</B> times</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The final accessors have basically same effect, as
<B>l_head</B>^<B>l_head</B>^...^<B>l_head</B><SPAN STYLE="font-weight: normal">&nbsp;</SPAN>(<I>L</I>)
(<I>n</I> times total) and <B>l_tail</B>^<B>l_tail</B>^...^<B>l_tail</B><SPAN STYLE="font-weight: normal">&nbsp;</SPAN>(<I>L</I>)
(<I>n</I> times total). When <I>n</I>&nbsp;==&nbsp;1, these are just
equivalent to  <B>l_head</B>(<I>L</I>) and <B>l_tail</B>(<I>L</I>).
When <I>n</I>&nbsp;==&nbsp;0, these are just the same as <I>L</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Attention: this operations treat list as binary tree, not linear
sequence! (It's a mistake to think <B>l_head_by</B>(<I>n</I>, <I>L)</I>
must return first <I>n</I> elements of list <I>L</I> &ndash; it does
not.) Another important thing to keep in mind is: these functors do
not create some new data, just access elements of <I>L</I>. This
means any changes applied to their result &ndash; affect entire list
<I>L</I> as well.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US"><I>Eager a</I></SPAN><I>ssignment</I> <SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><B>set</B></SPAN><SPAN LANG="en-US">)
</SPAN>can be applied not only to scalar values. For example, any
list of mutables is <SPAN LANG="en-US">considered </SPAN>mutable too,
<SPAN LANG="en-US">and</SPAN> list of any values may be assigned to
it:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[a b c] = [10 20 30];</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Thes</SPAN><SPAN LANG="en-US">e
</SPAN><SPAN LANG="en-GB">assigns 3&nbsp;</SPAN><SPAN LANG="en-US">scalar
</SPAN><SPAN LANG="en-GB">values </SPAN><SPAN LANG="en-US">(10, 20,
30) </SPAN><SPAN LANG="en-GB">to 3&nbsp;variables </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>a</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>b</I></SPAN><SPAN LANG="en-US">, </SPAN><SPAN LANG="en-US"><I>c</I></SPAN><SPAN LANG="en-US">)
</SPAN><SPAN LANG="en-GB">at once.</SPAN> <SPAN LANG="en-GB">All
assignments are performed </SPAN><SPAN LANG="en-US">instantly</SPAN><SPAN LANG="en-GB">,
so:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">[x
y] = [y x];</SPAN></SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">is
</SPAN><SPAN LANG="en-US">a valid</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">way
</SPAN><SPAN LANG="en-GB">to swap values of </SPAN><SPAN LANG="en-GB"><I>x</I></SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-GB"><I>y</I></SPAN><SPAN LANG="en-GB">. </SPAN><SPAN LANG="en-US">Of
course, in this simple case </SPAN><SPAN LANG="en-US"><B>swap</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>x</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>y</I></SPAN><SPAN LANG="en-US">) </SPAN><SPAN LANG="en-US">is
easier</SPAN><SPAN LANG="en-US">. However, sometimes list assignment</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">are the easiest way to do some task</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[x y] = (x*Xx + y*Xy + X, x*Yx +
y*Yy + Y);</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This does multiply vector (<I>x</I>, <I>y</I>) by 2*3 matrix ((<I>Xx</I>,
<I>Xy</I>, <I>X</I>), (<I>Yx</I>, <I>Yy</I>, <I>Y</I>)) in place
(without need for any temporary variables).</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Also</SPAN><SPAN LANG="en-GB">,
list of values in assignment can be </SPAN><SPAN LANG="en-GB"><I>shorter</I></SPAN><SPAN LANG="en-GB">
than list of mutables</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-GB">
in this case, all extra mutables are set to </SPAN><SPAN LANG="en-GB"><B>undef</B></SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">For example:</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[x y z] = [10.1 20.2];</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">After
this operation, x&nbsp;==&nbsp;10.1; y&nbsp;==&nbsp;20.2 and z is
</SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Or list of values can be <I>longer&nbsp;</I>&ndash; and in this case
the final value gets all the unassigned values in the list form. For
example:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[a b c] = ['Aa' 'Bb' 'Cc' 'Dd'];</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
After this operation, <I>a</I> equals to string 'Aa'; <I>b</I> equals
to string 'Bb' and <I>c</I> is equal to list ('Cc', 'Dd').</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The lists (both in left and in right part of the assignment) can be
nested: in this case, list assignment rules are applied <I>recursively</I>.
The semantics of list assignment is important, because it is also
applied to functor arguments passing, and returned value (explained
below).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are some operations affecting entire lists:</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=162>
	<COL WIDTH=161>
	<COL WIDTH=294>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">#L</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_len</B><SPAN STYLE="font-weight: normal">(L</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Length of list <B>L</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">L&nbsp;[+]&nbsp;M</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_cat</B>(L,
			M)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Concatenation of
			lists <B>L</B> and <B>M</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">L&nbsp;[*]&nbsp;n</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_rep</B>(n,
			L)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Replication of
			list <B>L</B> <SPAN LANG="en-US">(</SPAN><B>n</B> times <SPAN LANG="en-US">total</SPAN><SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">[~]&nbsp;L</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_rev</B>(L)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Revers<SPAN LANG="en-US">ion
			</SPAN>of list <B>L</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">[+]&nbsp;L</FONT></P>
		</TD>
		<TD WIDTH=161 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_copy</B>(L)</FONT></P>
		</TD>
		<TD WIDTH=294 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Copy of list <B>L</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">All
</SPAN><SPAN LANG="en-US">these</SPAN><SPAN LANG="en-US"> operations
</SPAN><SPAN LANG="en-US">are </SPAN><SPAN LANG="en-US">interpret</SPAN><SPAN LANG="en-US">ing</SPAN><SPAN LANG="en-US">
() as list of length 0, and any scalar value</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-US">as list of length 1. For example, </SPAN><SPAN LANG="en-US"><I>#value</I></SPAN><SPAN LANG="en-US">
is </SPAN><SPAN LANG="en-US">a </SPAN><SPAN LANG="en-US">simplest way
of checking value: it returns 0, if value is </SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-US">;
1, if value is any scalar; and 2 or more, if value is a </SPAN><SPAN LANG="en-US">(real)
</SPAN><SPAN LANG="en-US">list.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Here are some examples:</P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[1 2 3 4]&nbsp;[+]&nbsp;[9 8 7];</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">returns
list</SPAN><SPAN LANG="en-US"> (1, 2, 3, 4, 9, 8, 7).</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">['abc' 'def' 'xyz']&nbsp;[*]&nbsp;3;</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">returns
list</SPAN><SPAN LANG="en-US"> ('abc', 'def', 'xyz', 'abc', 'def',
'xyz', 'abc', 'def', 'xyz').</SPAN></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">[~]&nbsp;[1 'aA' 2 'bB' 3 'cC']</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">returns
list</SPAN><SPAN LANG="en-US"> ('cC', 3, 'bB', 2, 'aA', 1).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Application of unary [+] results in <I>exact copy</I> of the list
operand <SPAN LANG="ru-RU">(</SPAN><SPAN LANG="en-GB">includ</SPAN><SPAN LANG="en-GB">i</SPAN>ng<SPAN LANG="en-GB">
</SPAN>all nested list elements). In fact, <B>l_copy</B>(<I>List</I>)
does the same as <B>l_cat</B>(<I>List</I>, ()).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Iterators are available for lists as well:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=273>
	<COL WIDTH=352>
	<TR VALIGN=TOP>
		<TD WIDTH=273 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_loop</B><SPAN STYLE="font-weight: normal">(var</SPAN>,
			List, @Loop)</FONT></P>
		</TD>
		<TD WIDTH=352 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Forward
			l</SPAN>ist iterator:<BR>for <SPAN LANG="en-US"><B>var</B></SPAN><SPAN LANG="en-US">
			= </SPAN><SPAN LANG="en-US">(</SPAN>all elements <SPAN LANG="en-US">in</SPAN>
			<SPAN LANG="en-US"><B>List</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">)
			</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">do</SPAN></SPAN><SPAN STYLE="font-weight: normal">
			</SPAN><B>Loop</B><SPAN STYLE="font-weight: normal"><BR></SPAN>(in
			direct order)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=273 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_loop_r</B><SPAN STYLE="font-weight: normal">(var,
			List, @Loop</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=352 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Reverse list
			iterator:<BR>for <SPAN LANG="en-US"><B>var</B></SPAN><SPAN LANG="en-US">
			= </SPAN><SPAN LANG="en-US">(</SPAN>all elements of <B>List</B><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">)
			</SPAN></SPAN>do <B>Loop</B><BR>(in reverse order)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>List
iterators</I></SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><B>l_loop</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>l_loop_r</B></SPAN><SPAN LANG="en-US">
allows looping through all elements of list, </SPAN><SPAN LANG="en-US">setting</SPAN><SPAN LANG="en-US">
loop variable </SPAN><SPAN LANG="en-US"><I>var</I></SPAN><SPAN LANG="en-US">
to each element before evaluation of </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">List elements are traversed </SPAN><SPAN LANG="en-US">either
</SPAN><SPAN LANG="en-US">in direct order </SPAN><SPAN LANG="en-US">from
</SPAN><SPAN LANG="en-US"><I>first</I></SPAN><SPAN LANG="en-US"> to
</SPAN><SPAN LANG="en-US"><I>last</I></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-US"><B>l_loop</B></SPAN><SPAN LANG="en-US">)
or </SPAN><SPAN LANG="en-US">in reverse order </SPAN><SPAN LANG="en-US">from
</SPAN><SPAN LANG="en-US"><I>last</I></SPAN><SPAN LANG="en-US"> to
</SPAN><SPAN LANG="en-US"><I>first</I></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-US"><B>l_loop_r</B></SPAN><SPAN LANG="en-US">).
</SPAN><SPAN LANG="en-US">As with all iterators, t</SPAN><SPAN LANG="en-US">he
returned value </SPAN><SPAN LANG="en-US">equals to</SPAN><SPAN LANG="en-US">
result of last evaluation of </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">(Or (), if </SPAN><SPAN LANG="en-US"><I>List</I></SPAN><SPAN LANG="en-US">
is empty, and </SPAN><SPAN LANG="en-US"><I>Loop</I></SPAN><SPAN LANG="en-US">
never was evaluated.)</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Several built-in functors operate with list as with the <I>stack</I>
(with the <I>first</I> element as the top).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=185>
	<COL WIDTH=216>
	<COL WIDTH=216>
	<TR VALIGN=TOP>
		<TD WIDTH=185 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">L&nbsp;[&lt;-]&nbsp;(A,
			B, C, &hellip;)</FONT></P>
		</TD>
		<TD WIDTH=216 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>push</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">L</SPAN></SPAN>,
			<SPAN LANG="en-US">A, B, C, &hellip;</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=216 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Push values <B>A</B>,
			<B>B</B>, <B>C</B>... into list <B>L</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=185 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">L&nbsp;[-&gt;]&nbsp;(vA,
			vB, vC, &hellip;)</FONT></P>
		</TD>
		<TD WIDTH=216 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>pop</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">L</SPAN></SPAN><SPAN STYLE="font-weight: normal">,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">vA</SPAN></SPAN><SPAN STYLE="font-weight: normal">,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">vB,
			vC, &hellip;</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=216 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Pop values from
			list <B>L</B> into mutables <B>vA</B>, <B>vB</B>, <B>vC</B>...</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>l_push</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(L,
val1, val2, ... valN)</SPAN></SPAN></FONT><SPAN LANG="en-GB"> inserts
</SPAN><SPAN LANG="en-GB"><I>N</I></SPAN><SPAN LANG="en-GB"> values
(</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">val1...valN</SPAN></FONT><SPAN LANG="en-GB">)
at start of list </SPAN><SPAN LANG="en-GB"><I>L</I></SPAN><SPAN LANG="en-GB">
(in </SPAN><SPAN LANG="en-GB"><I>reverse</I></SPAN><SPAN LANG="en-GB">
order, so </SPAN><SPAN LANG="en-GB"><I>valN</I></SPAN><SPAN LANG="en-GB">
becomes first </SPAN><SPAN LANG="en-US">in the list!</SPAN><SPAN LANG="en-GB">)
and </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>l_pop</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(L,
var1, var2, ... varN)</SPAN></SPAN></FONT><SPAN LANG="en-GB"> removes
</SPAN><SPAN LANG="en-GB"><I>N</I></SPAN><SPAN LANG="en-GB"> values
from start of list </SPAN><SPAN LANG="en-GB"><I>L</I></SPAN><SPAN LANG="en-GB">,
assigning them to mutables </SPAN><SPAN LANG="en-GB"><I>var1 ... varN</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
in direct order</SPAN></SPAN><SPAN LANG="en-GB">. </SPAN><SPAN LANG="en-US">These
</SPAN><SPAN LANG="en-GB">operations </SPAN><SPAN LANG="en-US">may be
combined </SPAN><SPAN LANG="en-GB">with list accessor
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>l_tail_by</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">(n,&nbsp;L)</SPAN></FONT><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-US">mak</SPAN><SPAN LANG="en-US">ing</SPAN><SPAN LANG="en-GB">
easy to insert/remove elements at </SPAN><SPAN LANG="en-GB"><I>any</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">position</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">in</SPAN><SPAN LANG="en-GB">
the list.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Most scalar operations also treat list argument(s) as a stack. So,
application of any unary scalar functor (<B>un_func</B>) to list
operand affects <I>only first</I> (top) list operand, returning other
unchanged:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>un_</B><SPAN LANG="en-US"><B>func</B></SPAN><B>&nbsp;</B>(<I>first_elem</I>,
<I>other_elems</I>)&nbsp;==<BR>(<B>un_</B><SPAN LANG="en-US"><B>func</B></SPAN><B>&nbsp;</B><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>first_elem</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">)</SPAN></SPAN><SPAN LANG="en-US">,</SPAN>
<I>other_elems</I>)</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Application of any binary scalar functor (<B>bin_func</B>) to list
operand affects <I>only first pair</I> of list operands, returning
other unchanged:</P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>bin_</B><B>func</B><B>&nbsp;</B>(<I>first_elem</I>,
<I>second_elem</I>, <I>other_elems</I>)&nbsp;==<BR>(<B>bin_</B><B>func</B><B>&nbsp;</B>(<I>first_elem,
second_elem</I><SPAN STYLE="font-style: normal">)</SPAN>,
<I>other_elems</I>)</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
As easy to see, the &ldquo;standard&rdquo; behavior of unary and
binary functors is just a special case of their &ldquo;list&rdquo;
behavior: when <I>other_elems</I> is ().</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Directly accessing non-existent element of the list results in an
error. To make list longer (or shorter), there is a special functor:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=211>
	<COL WIDTH=414>
	<TR VALIGN=TOP>
		<TD WIDTH=211 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>resize</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">L,
			</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">n</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=414 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Shrink (or expand)
			list <B>L</B> to length <B>n</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This operation either <I>truncates</I> list <I>L</I> to length <I>n</I>
(if it was longer), or <I>expands</I> list <I>L</I> to length <I>n</I>
(if it was shorter) with trailing <B>undef</B>'s.</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">L = [1 2 3 4 5];<BR>l_resize (L,
8);</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
After this operation, list <I>L</I> is: (1, 2, 3, 4, 5, (), (), (),
). If you do:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">l_resize (L, <SPAN LANG="en-US">3</SPAN>);</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
list <I>L</I> becomes: (1, 2, 3, ). Truncation of list is destructive
operation: values of all truncated elements are lost forever.</P>
<H3 LANG="en-GB" CLASS="western">Basic input/output</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">As
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">almost</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
anything in </SPAN><SPAN LANG="en-US">AWL</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB"><I>input</I></SPAN><SPAN LANG="en-GB"> and
</SPAN><SPAN LANG="en-GB"><I>output</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">operations </SPAN><SPAN LANG="en-GB">are
implemented </SPAN><SPAN LANG="en-US">with</SPAN><SPAN LANG="en-GB">
functors. As opposite to so-called </SPAN><SPAN LANG="en-GB"><I>pure</I></SPAN><SPAN LANG="en-GB">
functors</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB">input/output ones do have an obvious
</SPAN><SPAN LANG="en-GB"><I>side-effect</I></SPAN><SPAN LANG="en-GB">,
changing some</SPAN><SPAN LANG="en-US">thing</SPAN><SPAN LANG="en-GB">
outside program. </SPAN><SPAN LANG="en-US">T</SPAN><SPAN LANG="en-GB">o
communicate with external world, special </SPAN><SPAN LANG="en-US">type
of data </SPAN><SPAN LANG="en-US">items</SPAN><SPAN LANG="en-GB">
(</SPAN><SPAN LANG="en-GB"><I>streams</I></SPAN><SPAN LANG="en-GB">)
is used. Some </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">standard</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
streams are </SPAN><SPAN LANG="en-GB"><I>pre-defined</I></SPAN><SPAN LANG="en-GB">,
some other need to be assigned by opening </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">or
creating</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB"> file
(or device, or network interface).</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For most commonly used stream <SPAN LANG="en-US">operations</SPAN>,
alternative operator syntax is <SPAN LANG="en-US">provided.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=177>
	<COL WIDTH=188>
	<COL WIDTH=252>
	<TR VALIGN=TOP>
		<TD WIDTH=177 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">O_Str&nbsp;&lt;:&nbsp;(Val1,
			Val2, ... ValN);</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>f_put&nbsp;</B>(O_Str,
			Val1, Val2, ... ValN);</FONT></P>
		</TD>
		<TD WIDTH=252 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Output list of
			values (<B>Val1</B><SPAN LANG="en-US">&hellip;</SPAN><B>ValN</B><SPAN LANG="en-US">)</SPAN><BR>to
			output stream <B>O_Str</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=177 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">I_Str&nbsp;:&gt;&nbsp;(Mut1,
			Mut2, ... MutN);</FONT></P>
		</TD>
		<TD WIDTH=188 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>f_get</B><SPAN STYLE="font-weight: normal">(I_Str</SPAN>,
			Mut1, Mut2, ... MutN)</FONT></P>
		</TD>
		<TD WIDTH=252 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Input strings from
			input stream <B>I_Str</B><BR>to <SPAN LANG="en-US">mutables
			</SPAN>(<B>Mut1</B><SPAN LANG="en-US">&hellip;</SPAN><B>MutN</B>) </I>
			</P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-GB">For </SPAN><SPAN LANG="en-GB"><B>f_put</B></SPAN><SPAN LANG="en-GB">,
operands in list are normally </SPAN><SPAN LANG="en-GB"><I>scalars</I></SPAN><SPAN LANG="en-GB">
(</SPAN><SPAN LANG="en-GB">a</SPAN>lthough <SPAN LANG="en-GB">nested
lists are allowed too). They are written </SPAN><SPAN LANG="en-GB">t</SPAN>o
<I>O_Str</I><SPAN LANG="en-GB"> </SPAN>in <SPAN LANG="en-GB">string
</SPAN>form,<SPAN LANG="en-GB"> according to standard coercion rules.
Output stream argument (</SPAN><SPAN LANG="en-GB"><I>O_Str</I></SPAN><SPAN LANG="en-GB">)
is optional: if operand is omitted, </SPAN><SPAN LANG="en-GB"><I>standard
output</I></SPAN><SPAN LANG="en-GB"> stream is implied.</SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN STYLE="font-style: normal">Functor</SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>f_put</B></SPAN></SPAN><SPAN LANG="en-GB">
doesn't add final newline to output, </SPAN>or insert anything
between list elements<SPAN LANG="en-GB">. Return</SPAN>ed value<SPAN LANG="en-GB">
is </SPAN><I>integer</I>: it is total <SPAN LANG="en-GB">number of
scalar values successfully written </SPAN>(including elements in all
nested lists, if any)<SPAN LANG="en-GB">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-GB">For </SPAN><SPAN LANG="en-GB"><B>f_get</B></SPAN><SPAN LANG="en-GB">,
the input units are always lines of text </SPAN>(separated by
system-defined end of line character)<SPAN LANG="en-GB">. </SPAN><SPAN LANG="en-GB">T</SPAN>hey<SPAN LANG="en-GB">
are assigned to mutables in list </SPAN>of <SPAN LANG="en-GB">operands,
</SPAN>in sequence<SPAN LANG="en-GB">. No coercion is </SPAN><SPAN LANG="en-GB">d</SPAN>one<SPAN LANG="en-GB">:
</SPAN><SPAN LANG="en-GB">i</SPAN>nput values<SPAN LANG="en-GB">
assigned as strings (with </SPAN>final <SPAN LANG="en-GB">newlines
</SPAN><SPAN LANG="en-GB">r</SPAN>emoved<SPAN LANG="en-GB">). Input
stream argument (</SPAN><SPAN LANG="en-GB"><I>I_Str</I></SPAN><SPAN LANG="en-GB">)
is optional: if operand is omitted, </SPAN><SPAN LANG="en-GB"><I>standard
input</I></SPAN><SPAN LANG="en-GB"> stream is implied. Return value
is number of lines </SPAN>successfully <SPAN LANG="en-GB">read and
assigned. </SPAN>(<SPAN LANG="en-GB">If end of file reached, </SPAN><SPAN LANG="en-GB"><B>undef</B></SPAN><SPAN LANG="en-GB">
are assigned </SPAN>to mutables in argument list.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Although standard input and output are usually <I>implicit</I>, these
streams may be referenced directly:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=215>
	<COL WIDTH=410>
	<TR VALIGN=TOP>
		<TD WIDTH=215 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>f_in&nbsp;</B>()</FONT></P>
		</TD>
		<TD WIDTH=410 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Standard input
			stream</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=215 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>f_out&nbsp;</B><SPAN STYLE="font-weight: normal">(</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=410 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Standard output
			stream</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=215 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>f_err&nbsp;</B>()</FONT></P>
		</TD>
		<TD WIDTH=410 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Standard error
			stream</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">(</SPAN>There's much more built-ins, associated
with input/output, which are not detailed here.<SPAN LANG="en-US">)</SPAN></P>
<H3 LANG="en-US" CLASS="western">Using list constructor syntax for
functor calls</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">To
make code more readable (and looking more </SPAN><SPAN LANG="en-US">a</SPAN><SPAN LANG="en-US">like
</SPAN><SPAN LANG="en-US">the</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">common
procedural languages)</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-US">some special syntax with list constructors
may be used. Note, what list constructor has </SPAN><SPAN LANG="en-US"><I>lower
syntax priority</I></SPAN><SPAN LANG="en-US">, than functor </SPAN><SPAN LANG="en-US">call</SPAN><SPAN LANG="en-US">.
This means, what </SPAN><SPAN LANG="en-US"><B>func1</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg1</I></SPAN><SPAN LANG="en-US">)::</SPAN><SPAN LANG="en-US"><B>func2</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg2</I></SPAN><SPAN LANG="en-US">)
is parsed as </SPAN><SPAN LANG="en-US"><B>func1</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg1</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><B>func2</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg2</I></SPAN><SPAN LANG="en-US">))
(</SPAN><SPAN LANG="en-US">but</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><I>not</I></SPAN><SPAN LANG="en-US">
as (</SPAN><SPAN LANG="en-US"><B>func1</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg1</I></SPAN><SPAN LANG="en-US">),
</SPAN><SPAN LANG="en-US"><B>func2</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>arg2</I></SPAN><SPAN LANG="en-US">)).
</SPAN><SPAN LANG="en-US">But, i</SPAN><SPAN LANG="en-US">f you
really need the later</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-US">put brackets around call to </SPAN><SPAN LANG="en-US"><B>func</B></SPAN><SPAN LANG="en-US"><B>1</B></SPAN><SPAN LANG="en-US">.)</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For example, to make conditionals more readable, the following
syntax:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>if&nbsp;</B></SPAN><SPAN LANG="en-US">(cond)::
Then :: Else;<BR></SPAN><SPAN LANG="en-US"><B>unless&nbsp;</B></SPAN><SPAN LANG="en-US">(cond)::
Else :: Then;</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">may be
used instead of:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>if&nbsp;</B></SPAN><SPAN LANG="en-US">(cond,
Then, Else);<BR></SPAN><SPAN LANG="en-US"><B>unless&nbsp;</B></SPAN><SPAN LANG="en-US">(cond,
Else, Then);</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">Likewise,
if you want some more convenient syntax for loops:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>while&nbsp;</B>(cond)::
Loop;<BR><B>until&nbsp;</B>(cond):: Loop;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
instead of:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>while&nbsp;</B>(cond,
Loop);<BR><B>until&nbsp;</B>(cond, Loop);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Even
</SPAN><SPAN LANG="en-US"><B>for_</B></SPAN><SPAN LANG="en-US"> and
</SPAN><SPAN LANG="en-US"><B>l_loop</B></SPAN><SPAN LANG="en-US">
iterators can be written this way (although, it's a bit of overkill).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For example:</P>
<P LANG="zxx" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>for_inc&nbsp;</B></SPAN><SPAN LANG="en-US">(i)::(10..20)::
</SPAN><SPAN LANG="en-US"><B>f_out</B></SPAN><SPAN LANG="en-US">((),
i*10, &ldquo;\n&rdquo;);</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
does the same as:</P>
<P LANG="zxx" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>for_inc&nbsp;</B></SPAN><SPAN LANG="en-US">(i,
10..20, </SPAN><SPAN LANG="en-US"><B>f_out</B></SPAN><SPAN LANG="en-US">((),
i*10, &ldquo;\n&rdquo;));</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">(But
</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">beware</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">:
it is a serious mistake to write </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">something
like</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">:</SPAN></FONT></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT SIZE=3><SPAN LANG="en-US"><B>for_inc&nbsp;</B></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(i,
10..20):: </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><B>f_out</B></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">((),
i*10, &ldquo;\n&rdquo;)</SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><FONT SIZE=3><SPAN LANG="en-US">because
i</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">t groups its argument</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">s</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
like</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">:</SPAN></FONT></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT SIZE=3><SPAN LANG="en-US"><B>for_inc&nbsp;</B></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">(</SPAN></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">(i,
10..20), </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><B>f_out</B></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">((),
i*10, &ldquo;\n&rdquo;))</SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">&ndash;
<FONT SIZE=3><SPAN LANG="en-US">which</SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
is definitely not what </SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US"><B>for_inc</B></SPAN></FONT><FONT SIZE=3><SPAN LANG="en-US">
expects!)</SPAN></FONT></P>
<H3 LANG="en-GB" CLASS="western">User-defined functors</H3>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
All functors presented before were <I>built-in</I>, as integral part
of the core language. <I>User functors</I> can be defined and used as
well, making language easily expandable.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The most common syntax for <I>user functor definition</I> looks like
this:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">! </SPAN><SPAN LANG="en-US"><B>myfunc</B></SPAN><SPAN LANG="en-US">(par1
par2 &hellip; parN) : [loc1 loc2 &hellip; locM] = body;</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Where:</P>
<UL>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><B>myfunc</B></SPAN></SPAN><SPAN LANG="en-US">
	is a </SPAN><SPAN LANG="en-US"><I>name</I></SPAN><SPAN LANG="en-US">
	of new functor </SPAN><SPAN LANG="en-US">defined</SPAN><SPAN LANG="en-US">;</SPAN></P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>par1&hellip;parN</I></SPAN><SPAN LANG="en-US">
	</SPAN><SPAN LANG="en-US">is list</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">of
	</SPAN><SPAN LANG="en-US">functor </SPAN><SPAN LANG="en-US"><I>parameters</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">;</SPAN></SPAN></P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>loc1&hellip;locM</I></SPAN>
	<SPAN LANG="en-US">is list of</SPAN><SPAN LANG="en-GB"> functor
	</SPAN><SPAN LANG="en-GB"><I>local variables</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">,</SPAN></SPAN></P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">and
	</SPAN></SPAN><SPAN LANG="en-GB"><I>body</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
	must be </SPAN></SPAN><SPAN LANG="en-GB"><I>any</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
	valid expression, de</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">fining</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
	functor evaluation</SPAN></SPAN><SPAN LANG="en-GB">.</SPAN></P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Functor
</SPAN><SPAN LANG="en-US">always</SPAN><SPAN LANG="en-GB"> has his
own </SPAN><SPAN LANG="en-GB"><I>name space</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">(actually, even </SPAN><SPAN LANG="en-US"><I>two</I></SPAN><SPAN LANG="en-US">
name spaces).</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">B</SPAN><SPAN LANG="en-US">oth
</SPAN><SPAN LANG="en-GB">parameters and local variables belong </SPAN><SPAN LANG="en-GB">t</SPAN><SPAN LANG="en-US">o
first of them</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">together</SPAN><SPAN LANG="en-US">,
they </SPAN><SPAN LANG="en-US">form</SPAN><SPAN LANG="en-US">
functor's </SPAN><SPAN LANG="en-US"><I>local context</I></SPAN><SPAN LANG="en-US">).</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-GB">These names </SPAN><SPAN LANG="en-US">are</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">accessible</SPAN><SPAN LANG="en-GB"> only
in </SPAN><SPAN LANG="en-US">functor</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><I>body</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(</SPAN></SPAN><SPAN LANG="en-GB">overrid</SPAN><SPAN LANG="en-US">ing</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">co</SPAN><SPAN LANG="en-US">nflict</SPAN><SPAN LANG="en-US">ing
</SPAN><SPAN LANG="en-GB">external names, if </SPAN><SPAN LANG="en-US">any</SPAN><SPAN LANG="en-GB">).</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
To invoke user functor, <SPAN LANG="en-US">the</SPAN> same syntax <SPAN LANG="en-US">is
used</SPAN>, as for <SPAN LANG="en-US">all </SPAN>built-ins:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>myfunc</B>(10, 20, 30);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">This
results in user functor </SPAN><SPAN LANG="en-GB"><B>myfunc</B></SPAN><SPAN LANG="en-GB">
being invoked with parameters </SPAN><SPAN LANG="en-GB"><I>par1</I></SPAN><SPAN LANG="en-GB">&nbsp;=&nbsp;10,
</SPAN><SPAN LANG="en-GB"><I>par2</I></SPAN><SPAN LANG="en-GB">&nbsp;=&nbsp;20
and so on. </SPAN><SPAN LANG="en-US">In g</SPAN><SPAN LANG="en-US">eneral,
the list assignment semantics (explained above) in used for assigning
arguments to parameters.</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">A</SPAN><SPAN LANG="en-GB">ll
</SPAN><SPAN LANG="en-US">functor </SPAN><SPAN LANG="en-GB">local
variables </SPAN><SPAN LANG="en-US">are set to </SPAN><SPAN LANG="en-US"><B>undef</B></SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">Functor</SPAN><SPAN LANG="en-GB"> call
returns result of evaluation of </SPAN><SPAN LANG="en-GB"><I>body</I></SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">As with any
expression, body can have any side-effect, </SPAN><SPAN LANG="en-US">and/</SPAN><SPAN LANG="en-US">or
return </SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-US">meaningful
value.</SPAN><SPAN LANG="en-US">)</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Here
are some examples. Functors</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><B>FtoC</B></SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-GB"><B>CtoF</B></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">are usable</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">temperature </SPAN><SPAN LANG="en-US">conversion</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">from</SPAN><SPAN LANG="en-GB"> Fahrenheit
to Celsius scale, and vice versa:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>FtoC</B></SPAN><SPAN LANG="en-GB">(temp)
= (temp&ndash;32)&nbsp;*&nbsp;(5/9);<BR>! </SPAN><SPAN LANG="en-GB"><B>CtoF</B></SPAN><SPAN LANG="en-GB">(temp)
= (temp&nbsp;*&nbsp;(9/5))+32;</SPAN></FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Another t<SPAN LANG="en-US">rivial</SPAN><SPAN LANG="en-US"> </SPAN>example:
functor <B>dist</B> calculates distance between <SPAN LANG="en-US">Cartesian
</SPAN>points (<I>x0</I>,&nbsp;<I>y0</I>) and (<I>x1</I>,&nbsp;<I>y1</I>):</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>dist</B></SPAN><SPAN LANG="en-GB">(x0
y0 x1 y1) = </SPAN><SPAN LANG="en-GB"><B>sqr</B></SPAN><SPAN LANG="en-GB">((x1-x0)*(x1-x0)&nbsp;+&nbsp;(y1-y0)*(y1-y0));</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">However,
more efficient way is </SPAN><SPAN LANG="en-US">using</SPAN><SPAN LANG="en-US">
built-in </SPAN><SPAN LANG="en-US">functor</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><B>rad</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>dx</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>dy</I></SPAN><SPAN LANG="en-US">),
calculating value of </SPAN><SPAN LANG="en-US"><B>sqr</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>dx</I></SPAN><SPAN LANG="en-US">*</SPAN><SPAN LANG="en-US"><I>dx</I></SPAN><SPAN LANG="en-US">&nbsp;+&nbsp;</SPAN><SPAN LANG="en-US"><I>dy</I></SPAN><SPAN LANG="en-US">*</SPAN><SPAN LANG="en-US"><I>dy</I></SPAN><SPAN LANG="en-US">)
</SPAN><SPAN LANG="en-US">with better accuracy</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>dist</B></SPAN><SPAN LANG="en-GB">(x0
y0 x1 y1) = </SPAN><SPAN LANG="en-GB"><B>rad</B></SPAN><SPAN LANG="en-GB">(x1-x0,
y1-y0);</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
To join two string arguments, surrounding them with brackets, and
separating with comma:</P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>j</B></SPAN><B>oin2</B><SPAN LANG="en-GB">(s</SPAN>1
s2<SPAN LANG="en-GB">) = </SPAN>'('&nbsp;+$&nbsp;s1&nbsp;+$&nbsp;',
'&nbsp;+$&nbsp;s2&nbsp;+$&nbsp;')'<SPAN LANG="en-GB">;</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Any functor parameter may have <I>default initiali</I><I>s</I><I>er</I><SPAN STYLE="font-style: normal">,</SPAN>
as in following example:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">!
</SPAN><SPAN LANG="en-US"><B>draw</B></SPAN><B>_shape</B>(Color=Red
Shape=Rectangular) = { ... };</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Even expression is permitted as default initialiser (but any
non-trivial expression must be in brackets). Default initialiser is
substituted, if argument value is either <B>undef</B>, or just
omitted:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>draw_shape</B><SPAN STYLE="font-weight: normal">();</SPAN><B>			</B><I><B>`
draw_shape</B></I><I><SPAN STYLE="font-weight: normal">(Red,
Rectangular) </SPAN></I><I><B>`</B></I><B><BR>draw_shape</B>(Green);		<I>`
</I><I><B>draw_shape</B></I><I>(Green, Rectangular) `</I><BR><SPAN LANG="en-US"><B>draw_shape</B></SPAN><SPAN LANG="en-US">((),
Circular)</SPAN>;	<I>` </I><I><B>draw_shape</B></I><I>(Red, Circular)
`</I></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">If
functor argument has neither explicit nor default initiali</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">er,
it </SPAN><SPAN LANG="en-US">i</SPAN><SPAN LANG="en-US">s </SPAN><SPAN LANG="en-US">initialised
to</SPAN><SPAN LANG="en-US"> ().</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Obviously</SPAN><SPAN LANG="en-US">,
functor definitions may be </SPAN><SPAN LANG="en-US"><I>recursive</I></SPAN><SPAN LANG="en-US">.
Any invocation of recursive functor has his own </SPAN><SPAN LANG="en-US">local
context </SPAN><SPAN LANG="en-US">(e.g. </SPAN><SPAN LANG="en-US">own
</SPAN><SPAN LANG="en-US">set of parameters and locals</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.
Here is a recursive definition </SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US">
factorial</SPAN><SPAN LANG="en-US">,</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">with</SPAN><SPAN LANG="en-US">
integer</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">argument
</SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(assumed
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">to
be </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">positive)</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">:</SPAN></SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <B>factorial</B>(n) = n?
n*<B>factorial</B>(n&ndash;1) : 1;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Binomial coefficients (for <I>n</I>, <I>m</I>) also can be defined
recursively:</P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <B>binomial</B>(n m) = (0 &lt;
m &amp;&amp; m &lt; n)?<BR><B>binomial</B>(n-1, m) + <B>binomial</B>(n-1,
m-1) : 1;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There&rsquo;s even a special syntax to define <I>functor group</I><I>s</I>,
which separates functors name list from all other functors
attributes:</P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! { <I><B>functor1 functor2
functor3</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>functorM</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
} = </SPAN></SPAN>{<BR>	(<I><B>par11</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>par1N</B></I>) : [<I><B>loc11</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>loc1N</B></I>] = <I><B>body1</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">,</SPAN></SPAN><I><B><BR></B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">	(</SPAN></SPAN><I><B>par21</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>par2N</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">)
: [</SPAN></SPAN><I><B>loc21</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>loc2N</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">]
= </SPAN></SPAN><I><B>body2</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">,<BR>	&hellip;<BR>	(</SPAN></SPAN><I><B>parM1</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>parMN</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">)
: [</SPAN></SPAN><I><B>locM1</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">
&hellip; </SPAN></SPAN><I><B>locMN</B></I><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">]
= </SPAN></SPAN><I><B>bodyM</B></I><BR>	}</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
It does (basically) the same, as declaring all listed functors
separately:</P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <I><B>functor1</B></I> (<I><B>par11</B></I>
&hellip; <I><B>par1N</B></I>) : [<I><B>loc11</B></I> &hellip; <I><B>loc1N</B></I>]
= <I><B>body1</B></I>;<BR>! <I><B>functor2</B></I> (<I><B>par21</B></I>
&hellip; <I><B>par2N</B></I>) : [<I><B>loc21</B></I> &hellip; <I><B>loc2N</B></I>]
= <I><B>body2</B></I>;<BR><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><SPAN STYLE="font-weight: normal">&hellip;</SPAN></SPAN></SPAN><BR>!
<I><B>functorM</B></I> (<I><B>parM1</B></I> &hellip; <I><B>parMN</B></I>)
: [<I><B>locM1</B></I> &hellip; <I><B>locMN</B></I>] = <I><B>bodyM</B></I>;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
However, <I>all</I> declared functions became callable <I>even before</I>
first definition is complete. This is mostly useful to define group
of <I>mutually-recursive</I> functors, where each defined functor can
invoke all others (including itself). For example:</P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! { is_even is_odd } = {<BR>	`
is_even =&gt; `<BR>	(n) = abs(n) &lt;= 1 ? n == 0 : is_odd  (n &gt; 0
? n-1 : n+1),<BR>	<BR>	` is_odd =&gt; `<BR>	(n) = abs(n) &lt;= 1 ? n
&lt;&gt; 0 : is_even (n &gt; 0 ? n-1 : n+1)<BR>	};</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Definitions here are <I>mutually recursive</I>: predicate <B>is_even</B>
calls <B>is_odd</B>, and <B>is_odd</B> calls <B>is_even</B>, until
the argument value is reduced into range -1..1. (This is a very
impractical way to check for even/odd integers, but it works.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Functor can return not only scalar, but any other value. Lists are
useful as return values, too:</P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">!
</SPAN><SPAN LANG="en-US"><B>transform_pt</B></SPAN><SPAN LANG="en-US">(x
y) = (a*x + b*y + c, d*x + e*y + f);</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">returns
result of linear transformation of point (</SPAN><SPAN LANG="en-US"><I>x</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>y</I></SPAN><SPAN LANG="en-US">) (</SPAN><SPAN LANG="en-US">as
</SPAN><SPAN LANG="en-US">defined by </SPAN><SPAN LANG="en-US">matrix
</SPAN><SPAN LANG="en-US">coefficients </SPAN><SPAN LANG="en-US"><I>a</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>b</I></SPAN><SPAN LANG="en-US">, </SPAN><SPAN LANG="en-US"><I>c</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>d</I></SPAN><SPAN LANG="en-US">, </SPAN><SPAN LANG="en-US"><I>e</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>f</I></SPAN><SPAN LANG="en-US">).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Another
example of recursive functor, </SPAN><SPAN LANG="en-US">expecting</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">and returning</SPAN><SPAN LANG="en-GB">
list, is </SPAN><SPAN LANG="en-GB"><I>list flattening</I></SPAN><SPAN LANG="en-GB">
operation. Functor </SPAN><SPAN LANG="en-GB"><B>l_flatten</B></SPAN><SPAN LANG="en-GB">
returns linear list of all atomic (non-list) elements of list </SPAN><SPAN LANG="en-GB"><I>L</I></SPAN><SPAN LANG="en-GB">,
collected recursively:</SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <B>l_flatten</B>(L) =
<B>is_list</B>(L)?<BR><B>l_flatten</B>(<B>l_head</B>(L))&nbsp;[+]&nbsp;<B>l_flatten</B>(<B>l_tail</B>(L))
: L;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
So, for example, <B>l_flatten</B> (((1, 2), 3), 4) results in list
(1, 2, 3, 4).</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Functor declarations may be <I>nested</I>. When functor definition is
included into other functor definition, it creates its own local
scope (actually, two scopes: for own parameters/locals and for its
own nested functors). All outer scopes are accessible from inner
functor definitions. During any variable or functor <SPAN LANG="en-US">lookup</SPAN>,
search is <SPAN LANG="en-US">always </SPAN>performed from <I>inner</I>
scopes to <I>outer</I> ones, up to module global scope. Inner
definitions <SPAN LANG="en-US">always </SPAN>override outer ones.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Here
is a functor </SPAN><SPAN LANG="en-US">definition</SPAN><SPAN LANG="en-US">,
solving &ldquo;</SPAN><SPAN LANG="en-US"><I>Towers of Hanoi</I></SPAN><SPAN LANG="en-US">&rdquo;
problem.</SPAN><SPAN LANG="en-GB"> (</SPAN><SPAN LANG="en-US">Most of
work done with recursive</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><B>move_disks</B></SPAN><SPAN LANG="en-US">,</SPAN><SPAN LANG="en-GB">
declared as local functor </SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><B>hanoi_solve</B></SPAN><SPAN LANG="en-GB">):</SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <B>hanoi_solve</B>(N): [count]
= {<BR>! <B>move_disks</B>(n from to via) =<BR>	n ? {<BR>	count =
<B>move_disks</B>(n-1, [from via to]);<BR>	&lt;: [&quot;\t#&quot; n
&quot;: &quot; from &quot; =&gt; &quot; to &quot;\n&quot;];<BR>	++
count;<BR>	count + <B>move_disks</B>(n-1, [via to from])<BR>	} :
0;<BR><BR>&lt;: [&quot;\nTowers of Hanoi: &quot; N &quot;
disks...\n\n&quot;];<BR>count = <B>move_disks</B>(N, ['A' 'B'
'C']);<BR>&lt;: [&quot;\nPuzzle solved in: &quot; count &quot;
steps.\n&quot;]<BR>};</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Just
i</SPAN><SPAN LANG="en-GB">nvoke </SPAN><SPAN LANG="en-GB"><B>hanoi_solve</B></SPAN><SPAN LANG="en-GB">(N)
to get a full solution for N disks. </SPAN><SPAN LANG="en-US">For
example, </SPAN><SPAN LANG="en-GB"><B>hanoi_solve</B></SPAN><SPAN LANG="en-GB">(</SPAN><SPAN LANG="en-US">3</SPAN><SPAN LANG="en-GB">)
</SPAN><SPAN LANG="en-US">results in following output:</SPAN></P>
<P LANG="en-GB" ALIGN=LEFT STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0.25cm; margin-bottom: 0.5cm; background: #cccccc; page-break-before: auto">
<FONT FACE="Courier New, monospace">Towers of Hanoi<BR>(3
disks)...<BR><BR>	#1: A =&gt; B<BR>	#2: A =&gt; C<BR>	#1: B =&gt;
C<BR>	#3: A =&gt; B<BR>	#1: C =&gt; A<BR>	#2: C =&gt; B<BR>	#1: A =&gt;
B<BR><BR>Puzzle solved <SPAN LANG="en-US">in</SPAN>: 7 steps.</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Another
</SPAN><SPAN LANG="en-US">simple </SPAN><SPAN LANG="en-GB">functor
example is recursive </SPAN><SPAN LANG="en-GB"><I>permutations
generator</I></SPAN><SPAN LANG="en-GB">. Invoking </SPAN><SPAN LANG="en-GB"><B>permute</B></SPAN><SPAN LANG="en-GB">
will generate (</SPAN><SPAN LANG="en-US">in</SPAN><SPAN LANG="en-GB">
list </SPAN><SPAN LANG="en-US">form</SPAN><SPAN LANG="en-GB">) all
permutations of integers in range </SPAN><SPAN LANG="en-GB"><I>0..N</I></SPAN><SPAN LANG="en-GB">,
and calls functor referenced with </SPAN><SPAN LANG="en-GB"><I>action</I></SPAN><SPAN LANG="en-GB">,
with each permutation as argument. </SPAN><SPAN LANG="en-US">Again,
</SPAN><SPAN LANG="en-US">here </SPAN><SPAN LANG="en-US">nested
functor </SPAN><SPAN LANG="en-US"><B>r_perm</B></SPAN><SPAN LANG="en-US">
is called recursively.</SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">! <B>permute</B> (N action):
[index] = {<BR><SPAN LANG="en-GB">index = 0 [*] N;<BR></SPAN>!
<B>r_perm</B>(n): [i] =<BR>	n &lt;&gt; N ? {<BR>		index[n] = n;<BR><SPAN LANG="en-GB">		n
++;<BR></SPAN>		<B>for_dec</B>(i, 1..n, index[i] :=:
index[i-1]);<BR><SPAN LANG="en-GB">		</SPAN><SPAN LANG="en-GB"><B>r_perm</B></SPAN><SPAN LANG="en-GB">(n);<BR></SPAN>		<B>for_inc</B>(i,
1..n, {<BR>			index[i] :=: index[i-1];<BR><SPAN LANG="en-GB">			</SPAN><SPAN LANG="en-GB"><B>r_perm</B></SPAN><SPAN LANG="en-GB">(n)<BR></SPAN>			})<BR>		}
:<SPAN LANG="en-GB"><BR></SPAN>	<I>` end of recursion: call 'action'
with 'index' `</I><BR>	action ! Index;<BR><BR><I>` Algorithm entry
point: `</I><BR><B>r_perm</B>(0);<BR>};	<I>` -- permute `</I></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Note,
what most of work here is done by local functor </SPAN><SPAN LANG="en-GB"><B>r_perm</B></SPAN><SPAN LANG="en-GB">,
which is invoked recursively.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">To
list all </SPAN><SPAN LANG="en-US">6</SPAN><SPAN LANG="en-GB">
permutations of numbers (0, 1, 2), invoke it as </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>permute</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">(</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">3</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">,
!(list) = (&lt;:&nbsp;(list, &ldquo;\n&rdquo;)))</SPAN></FONT><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">This results in:</SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0.25cm; margin-bottom: 0.5cm; background: #cccccc; page-break-before: auto">
<FONT FACE="Courier New, monospace">210<BR>120<BR>102<BR>201<BR>021<BR>012</FONT></P>
<H3 LANG="en-US" CLASS="western">Functors references</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><I>Reference
to functor</I></SPAN><SPAN LANG="en-GB"> is an another kind of data.
</SPAN><SPAN LANG="en-US">Remember</SPAN><SPAN LANG="en-GB">, what
AWL always uses </SPAN><SPAN LANG="en-GB"><I>separate name spaces</I></SPAN><SPAN LANG="en-GB">
for variables and functors. So, to refer to functor </SPAN><SPAN LANG="en-GB"><B>myfunc</B></SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-GB">special </SPAN><SPAN LANG="en-US">form
of </SPAN><SPAN LANG="en-GB">syntax is required:</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-GB">!</SPAN><SPAN LANG="en-GB"><B>myfunc</B></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-weight: normal">
(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">because
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">just</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-weight: normal">
</SPAN></SPAN><SPAN LANG="en-GB"><I><SPAN STYLE="font-weight: normal">myfunc</SPAN></I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-weight: normal">
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">refers
to</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-weight: normal">
</SPAN></SPAN><SPAN LANG="en-GB"><I><SPAN STYLE="font-weight: normal">variable</SPAN></I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-weight: normal">
named so)</SPAN></SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">This
reference can be treated as any other data item: assigned to
variable, contained in list </SPAN><SPAN LANG="en-US">(or other
container)</SPAN><SPAN LANG="en-GB">, or passed to other functor
(making functors a </SPAN><SPAN LANG="en-GB"><I>first-class values</I></SPAN><SPAN LANG="en-GB">).
The most obvious thing to do with functor reference is, of course, to
invoke it </SPAN><SPAN LANG="en-US">(with some arguments):</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=150>
	<COL WIDTH=211>
	<COL WIDTH=256>
	<TR VALIGN=TOP>
		<TD WIDTH=150 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">funcref
			! args</FONT></P>
		</TD>
		<TD WIDTH=211 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>apply</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">funcref</SPAN></SPAN><SPAN STYLE="font-weight: normal">,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">args</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=256 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Do call functor
			(referenced by <B>funcref</B>),<BR>with argument(s) <B>args</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">This
</SPAN><SPAN LANG="en-US">has</SPAN><SPAN LANG="en-US"> the same
</SPAN><SPAN LANG="en-US">effect</SPAN><SPAN LANG="en-US">, as
invoking this functor directly </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">passing
the same arguments, </SPAN><SPAN LANG="en-US">having same
side-effect, </SPAN><SPAN LANG="en-US">and returning same value</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-GB">Here is a </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">rather
trivial</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">)</SPAN></SPAN><SPAN LANG="en-GB">
example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">result =
(!</SPAN><SPAN LANG="en-GB"><B>add</B></SPAN><SPAN LANG="en-GB">,
!</SPAN><SPAN LANG="en-GB"><B>sub</B></SPAN><SPAN LANG="en-GB">,
!</SPAN><SPAN LANG="en-GB"><B>mul</B></SPAN><SPAN LANG="en-GB">,
!</SPAN><SPAN LANG="en-GB"><B>div</B></SPAN><SPAN LANG="en-GB">)[op_code]
! (x, y);</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Depending
from </SPAN><SPAN LANG="en-GB"><I>op_code</I></SPAN><SPAN LANG="en-GB">
(expected to be </SPAN><SPAN LANG="en-US">integer </SPAN><SPAN LANG="en-GB">in
range 0..4), it sets </SPAN><SPAN LANG="en-GB"><I>result</I></SPAN><SPAN LANG="en-GB">
to </SPAN><SPAN LANG="en-GB"><I>x+y</I></SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-GB"><I>x-y</I></SPAN><SPAN LANG="en-GB">, </SPAN><SPAN LANG="en-GB"><I>x*y</I></SPAN><SPAN LANG="en-GB">
or </SPAN><SPAN LANG="en-GB"><I>x/y</I></SPAN><SPAN LANG="en-GB">. </SPAN><SPAN LANG="en-US">As</SPAN><SPAN LANG="en-GB">
another example, if we need to check </SPAN><SPAN LANG="en-US">pair
of </SPAN><SPAN LANG="en-GB">numeric values (</SPAN><SPAN LANG="en-GB"><I>valA</I></SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-GB"><I>valB</I></SPAN><SPAN LANG="en-GB">) for
being </SPAN><SPAN LANG="en-US">either </SPAN><SPAN LANG="en-GB">in
ascending </SPAN><SPAN LANG="en-US">or </SPAN><SPAN LANG="en-GB">descending
order, depending from boolean </SPAN><SPAN LANG="en-GB"><I>flag</I></SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB">we can write something like </SPAN><SPAN LANG="en-US">this</SPAN><SPAN LANG="en-GB">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">test_result = (flag ? !<B>lt</B>
: !<B>gt</B>) ! (valA, valB)</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">which
may be quickest way to perform such test, if </SPAN><SPAN LANG="en-GB"><I>valA</I></SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-GB"><I>valB</I></SPAN><SPAN LANG="en-GB">
are complex expressions.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Because all control structures in AWL are functors &ndash; they can
be invoked indirectly, too. For example:</P>
<P LANG="en-US" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">(direction ? !<B>for_inc</B> :
!<B>for_dec</B>) ! (I, 10..20, &lt;: I)</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This will just print all values from (inclusive) 10 to 19, but order
(incremental or decremental) is defined by <I>direction</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">When
</SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-GB">functor
reference is used only once, there is no obvious need to name it.
</SPAN><SPAN LANG="en-GB"><I>Anonymous functor references</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">is</SPAN><SPAN LANG="en-GB"> another kind
of expressions, similar to </SPAN><SPAN LANG="en-GB"><I>lambda-expressions</I></SPAN><SPAN LANG="en-GB">
in LISP, Python and other languages. For example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">func_list =
(!(x y) = (2*x&nbsp;+&nbsp;3*y), !(x y) = (5*x&nbsp;&ndash;&nbsp;y)</SPAN>);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">creates
</SPAN><SPAN LANG="en-GB"><I>func_list</I></SPAN><SPAN LANG="en-GB">
as a list of two references to anonymous functors. Any of them may be
invoked </SPAN><SPAN LANG="en-US">via </SPAN><SPAN LANG="en-US"><B>apply</B></SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-GB">or example,
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">func_list[1]&nbsp;!&nbsp;(5,
7)</SPAN></SPAN></FONT><SPAN LANG="zxx"> evaluates to 31, and
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">func_list[1]&nbsp;!&nbsp;(5,
7)</SPAN></SPAN></FONT><SPAN LANG="en-GB"> evaluates to 18.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">As
</SPAN><SPAN LANG="en-US">clear</SPAN><SPAN LANG="en-GB"> from this
example, definition of anonymous functor looks like ordinary functor
definition </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">although
it is an expression</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-US">but </SPAN><SPAN LANG="en-GB">functor name
</SPAN><SPAN LANG="en-US">is omitted </SPAN><SPAN LANG="en-GB">and
(attention!) functor's body must </SPAN><SPAN LANG="en-US">have</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><I>closed </I></SPAN><SPAN LANG="en-US"><I>syntax</I></SPAN><SPAN LANG="en-US">
(which is not necessary for normal functor definitions)</SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">In all other aspects, nameless functors can
do everything as named ones.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Some
built-in </SPAN><SPAN LANG="en-US">functors</SPAN><SPAN LANG="en-US">
expect functor references as arguments.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=235>
	<COL WIDTH=390>
	<TR VALIGN=TOP>
		<TD WIDTH=235 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>map</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">func_ref,
			list</SPAN></SPAN></SPAN></FONT>)</FONT></P>
		</TD>
		<TD WIDTH=390 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Create new list,
			using <B>func_ref</B> to map elements of <B>list</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">N</SPAN><SPAN LANG="en-US">ew
list </SPAN><SPAN LANG="en-US">is</SPAN><SPAN LANG="en-US">
constructed by applying </SPAN><SPAN LANG="en-US"><I>func_ref</I></SPAN><SPAN LANG="en-US">
to all elements of </SPAN><SPAN LANG="en-US"><I>list</I></SPAN><SPAN LANG="en-US">
in sequence. </SPAN><SPAN LANG="en-US">For example</SPAN><SPAN LANG="en-US">,
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><B>l_map</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US">(!(x)
= (2*x&nbsp;+&nbsp;5), [5&nbsp;7&nbsp;9])</SPAN></SPAN></FONT><SPAN LANG="en-US">
returns list (15, 19, 23); and </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><B>l_map</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US">(!(s)
= (&ldquo;{&rdquo;&nbsp;+$&nbsp;s&nbsp;+$&nbsp;&ldquo;}&rdquo;),
['aa' 'ee' 'ii'])</SPAN></SPAN></FONT><SPAN LANG="en-US"> returns
list (&ldquo;{aa}&rdquo;, &ldquo;{ee}&rdquo;, &ldquo;{ii}&rdquo;).
</SPAN><SPAN LANG="en-US">The easy way to convert all scalar elements
of list </SPAN><SPAN LANG="en-US"><I>L</I></SPAN><SPAN LANG="en-US">
to strings is to use </SPAN><SPAN LANG="en-US"><B>l_map</B></SPAN><SPAN LANG="en-US">
(!</SPAN><SPAN LANG="en-US"><B>string</B></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US"><I>L</I></SPAN><SPAN LANG="en-US">).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">T</SPAN><SPAN LANG="en-US">he
following functors are converting range to list of values:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=289>
	<COL WIDTH=336>
	<TR VALIGN=TOP>
		<TD WIDTH=289 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>range</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Range,
			[</SPAN></SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">func_ref</SPAN></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">]</SPAN></SPAN></SPAN></FONT>)</FONT></P>
		</TD>
		<TD WIDTH=336 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Convert integer <B>Range</B> to ascending list<BR>(with
			optional <B>func_ref</B> for mapping)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=289 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>l_</B><SPAN LANG="en-US"><B>range_r</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Range,
			[</SPAN></SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">func_ref</SPAN></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">]</SPAN></SPAN></SPAN></FONT>)</FONT></P>
		</TD>
		<TD WIDTH=336 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Convert integer <B>Range</B> to descending list<BR>(with
			optional <B>func_ref</B> for mapping)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-US">irst
operand must be </SPAN><SPAN LANG="en-US"><I>Range</I></SPAN><SPAN LANG="en-US">,
in the same form as in </SPAN><SPAN LANG="en-US"><B>for_inc</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>for_dec</B></SPAN><SPAN LANG="en-US">.
Second operand is optional, and, when present, must be reference to
some functor. The result is list of all values in range (in ascending
order with </SPAN><SPAN LANG="en-US"><B>for_inc</B></SPAN><SPAN LANG="en-US">,
or descending with </SPAN><SPAN LANG="en-US"><B>for_dec</B></SPAN><SPAN LANG="en-US">),
with </SPAN><SPAN LANG="en-US"><I>func_ref</I></SPAN><SPAN LANG="en-US">
applied to each value, if it it provided. For example,
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_range</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">(10..15,
)</SPAN></FONT><SPAN LANG="en-US"> results in list (10, 11, 12, 13,
14), and result of </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_range_r</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">(-4..4,
!</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>string</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">)</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
is list (&ldquo;3&rdquo;, &ldquo;2&rdquo;, &ldquo;1&rdquo;, &ldquo;0&rdquo;,
&ldquo;-1&rdquo;, &ldquo;-2&rdquo;, &ldquo;-3&rdquo;, &ldquo;-4&rdquo;).
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">(</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">Note,
what even when second argument is omitted, comma after </SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US"><I>Range</I></SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">
</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">is
mandatory)</SPAN></FONT><FONT FACE="Times New Roman, serif"><SPAN LANG="en-US">!</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=641 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=261>
	<COL WIDTH=362>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=261 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_while</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=362 STYLE="border: 1px solid #000000; padding: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Locate
				first (from the beginning) element of </SPAN></SPAN><SPAN LANG="en-US"><B>List</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">,<BR>for
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				fails (evaluates to false).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=261 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_while_r</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=362 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Locate
				last (from the end) element of </SPAN></SPAN><SPAN LANG="en-US"><B>List</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">,<BR>for
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				fails (evaluates to false).</SPAN></SPAN></I></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=261 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_until</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=362 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Locate
				first (from the beginning) element of </SPAN></SPAN><SPAN LANG="en-US"><B>List</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">,<BR>for
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				succeeds (evaluates to true).</SPAN></SPAN></I></P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=261 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_until_r</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=362 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Locate
				last (from the end) element of </SPAN></SPAN><SPAN LANG="en-US"><B>List</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">,<BR>for
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				succeeds (evaluates to true).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>These functors
perform list searching for first (or last) element in <I>List </I>to
match (or NOT to match) predicate <I>Pred</I>. For <B>l_while</B>
predicate is checked <I>positively</I> (== while returns <B>true</B>),
for <B>l_until</B> it is checked <I>negatively</I> (== while returns
<B>false</B>). Two functors with <B>_r</B> suffix perform search in
<I>reverse</I> direction, other two &ndash; directly. Returned value
always is element index (first element is 0).</FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<TABLE WIDTH=641 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=348>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_filter_in</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=348 STYLE="border: 1px solid #000000; padding: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Select all
				elements of</SPAN> <B>L</B><SPAN LANG="en-US"><B>ist</B></SPAN><SPAN LANG="en-US">,<BR></SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				succeeds (evaluates to true).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=275 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_filter_ex</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=348 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Select all
				elements of</SPAN> <B>L</B><SPAN LANG="en-US"><B>ist</B></SPAN><SPAN LANG="en-US">,<BR></SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">fails</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				(evaluates to </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">false</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman"><FONT SIZE=3>These functors return new
list, constructed from elements of <I>List</I>, matching <I>Pred</I>
(for <B>l_filter_in</B>) or NOT matching it (for <B>l_filter_ex</B>)<SPAN LANG="ru-RU">,
</SPAN>in the same order.</FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<TABLE WIDTH=641 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=262>
	<COL WIDTH=361>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=262 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>count</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>_in</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=361 STYLE="border: 1px solid #000000; padding: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Count</SPAN><SPAN LANG="en-US">
				all elements of</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><B>L</B></SPAN><SPAN LANG="en-US"><B>ist</B></SPAN><SPAN LANG="en-US">,<BR></SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				succeeds (evaluates to true).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=262 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>count</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>_ex</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">Pred,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=361 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Count</SPAN><SPAN LANG="en-US">
				all elements of</SPAN> <B>L</B><SPAN LANG="en-US"><B>ist</B></SPAN><SPAN LANG="en-US">,<BR></SPAN><SPAN LANG="en-US">for</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				which </SPAN></SPAN><SPAN LANG="en-US"><B>Pred</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">fails</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				(evaluates to </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">false</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">).</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman"><FONT SIZE=3>These functors count
elements of <I>List</I>, matching <I>Pred</I> (for <B>l_</B><B>count</B><B>_in</B>)
or NOT matching it (for <B>l_</B><B>count</B><B>_ex</B>).</FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<TABLE WIDTH=641 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=265>
	<COL WIDTH=358>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=265 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
				<P CLASS="ww-содержимое-таблицы111111111111111111111111-western" ALIGN=CENTER>
				<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>l_</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>cmp</B></SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace">C</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">omp</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">,
				</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">List</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-US">L,
				ListR</SPAN></FONT><FONT FACE="Courier New, monospace">)</FONT></P>
			</TD>
			<TD WIDTH=358 STYLE="border: 1px solid #000000; padding: 0.1cm">
				<P CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Compare</SPAN><SPAN LANG="en-US">
				</SPAN><SPAN LANG="en-US"><B>L</B></SPAN><SPAN LANG="en-US"><B>ist</B></SPAN><SPAN LANG="en-US"><B>L</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				and </SPAN></SPAN><SPAN LANG="en-US"><B>ListR</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">element
				by element</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">)</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">,</SPAN></SPAN><SPAN LANG="en-US"><BR></SPAN><SPAN LANG="en-US">applying</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				</SPAN></SPAN><SPAN LANG="en-US"><B>Comp</B></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
				</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">to
				compare each pair of elements</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">.</SPAN></SPAN></I></P>
			</TD>
		</TR>
	</THEAD>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>This functor
compares two list operands, applying its first operand <I>Comp</I> as
<I>comparator </I><I>functor</I> (accepting two operands, and
expected to return numeric value). When this value is negative, first
operand is &ldquo;less than&rdquo; second; when it is positive, first
operand is &ldquo;greater than&rdquo; second; than it is zero, they
are equal. List operands are compared element by element, until first
difference is found (comparator returns non-zero value), or any of
the lists ends prematurely.</FONT></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=282>
	<COL WIDTH=343>
	<TR VALIGN=TOP>
		<TD WIDTH=282 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><SPAN LANG="en-US"><B>func</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=343 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is</SPAN> <SPAN LANG="en-US">reference
			to functor</SPAN><SPAN LANG="en-US">?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>This predicate
checks <I>v</I>, returning <B>true</B> (1) only of it is valid
reference to functor.</FONT></FONT></P>
<H3 LANG="en-GB" CLASS="western"><SPAN LANG="en-US">Evaluation on
d</SPAN>emand</H3>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Like in LISP and related languages<I>&nbsp;</I>&ndash; in AWL all
expressions (including variables, terms and blocks) are data items.
They may be treated as such: assigned to variables, embedded into
complex data structures, passed to functors as arguments and/or
returned from them. Evaluation of data is usually implicit. But there
are also special operations to perform evaluation (or to inhibit it):</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=149>
	<COL WIDTH=177>
	<COL WIDTH=291>
	<TR VALIGN=TOP>
		<TD WIDTH=149 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">@Expr</FONT></P>
		</TD>
		<TD WIDTH=177 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>deval</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Expr</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=291 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Devaluation (do not evaluate <B>Expr</B>)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=149 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">^Expr</FONT></P>
		</TD>
		<TD WIDTH=177 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>reval</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Expr</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=291 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Revaluation (evaluate <B>Expr</B> twice)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><I>Devaluation</I></SPAN><SPAN LANG="en-US">
is an unary functor </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>deval</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(expr)</SPAN></SPAN></FONT><SPAN LANG="en-US">
(with operator syntax: </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">@expr</SPAN></SPAN></FONT><SPAN LANG="en-US">).
Its effect is </SPAN><SPAN LANG="en-US"><I>inhibition</I></SPAN><SPAN LANG="en-US">
of operand evaluation: </SPAN><SPAN LANG="en-US">it </SPAN><SPAN LANG="en-US">return</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-US">
value </SPAN><SPAN LANG="en-US">of</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US"><I>expr</I></SPAN><SPAN LANG="en-US">
itself </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">instead
of result of </SPAN><SPAN LANG="en-US"><I>expr</I></SPAN><SPAN LANG="en-US">).
</SPAN><SPAN LANG="en-GB">The following example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">x_ref = @<B>sqr&nbsp;</B>(x*x &ndash;
y*y);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">makes
expression </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>sqr&nbsp;</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(x*x
&ndash; y*y)</SPAN></SPAN></FONT><SPAN LANG="en-GB"> the actual value
of variable </SPAN><SPAN LANG="en-GB"><I>x_ref</I></SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Effect
of </SPAN><SPAN LANG="en-GB"><I>revaluation</I></SPAN><SPAN LANG="en-GB">
is exactly opposite. </SPAN><SPAN LANG="en-US">Unary </SPAN><SPAN LANG="en-GB">functor
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>reval</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(expr)</SPAN></SPAN></FONT><SPAN LANG="en-GB">
(with operator syntax: </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">^expr</SPAN></SPAN></FONT><SPAN LANG="en-GB">)
evaluates result of </SPAN><SPAN LANG="en-GB"><I>expr</I></SPAN><SPAN LANG="en-GB">
evaluation (</SPAN><SPAN LANG="en-US">in fact</SPAN><SPAN LANG="en-GB">,
evaluating it twice). So, considering the example above:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">value = ^x_ref;</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
has exactly same effect, as</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">value =
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-GB"><B>sqr&nbsp;</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="en-GB">(x*x
&ndash; y*y)</SPAN></SPAN></FONT><SPAN LANG="en-GB">;</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">if
the value of </SPAN><SPAN LANG="en-GB"><I>x_ref</I></SPAN><SPAN LANG="en-GB">
was unchanged </SPAN><SPAN LANG="en-US">after assignment)</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Because
</SPAN><SPAN LANG="en-GB"><I>lazy assignments</I></SPAN><SPAN LANG="en-GB">
are needed frequently, there&rsquo;s a special replacement for
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">var&nbsp;=&nbsp;@expr</SPAN></SPAN></FONT><SPAN LANG="en-GB">.
Using </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">var&nbsp;:=&nbsp;expr</SPAN></SPAN></FONT><SPAN LANG="en-GB">
(or </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>let</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(var,
expr)</SPAN></SPAN></FONT><SPAN LANG="en-GB">) has exactly same
effect: assigning </SPAN><SPAN LANG="en-GB"><I>expr</I></SPAN><SPAN LANG="en-GB">
to mutable </SPAN><SPAN LANG="en-GB"><I>var</I></SPAN><SPAN LANG="en-GB">
without evaluation.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=162>
	<COL WIDTH=164>
	<COL WIDTH=291>
	<TR VALIGN=TOP>
		<TD WIDTH=162 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">V&nbsp;:=&nbsp;W</FONT></P>
		</TD>
		<TD WIDTH=164 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>let</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">V,
			W</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=291 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Assign <B>W</B> (without evaluation) to <B>V</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">As
well, u</SPAN><SPAN LANG="en-US">ser functors </SPAN><SPAN LANG="en-US">are
allowed</SPAN><SPAN LANG="en-US"> to have </SPAN><SPAN LANG="en-US"><I>demand-evaluated
parameters</I></SPAN><SPAN LANG="en-US"> (like many language
built-ins). </SPAN><SPAN LANG="en-US">B</SPAN><SPAN LANG="en-US">y
default, all parameters </SPAN><SPAN LANG="en-US">of funtors </SPAN><SPAN LANG="en-US">are
evaluated </SPAN><SPAN LANG="en-US"><I>before</I></SPAN><SPAN LANG="en-US">
evaluation of functor body</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-US">but </SPAN><SPAN LANG="en-GB">if parameter
is preceded with @, it's evaluation is considered </SPAN><SPAN LANG="en-GB"><I>functor's
responsibility</I></SPAN><SPAN LANG="en-GB"> (and may be performed
any time).</SPAN> <SPAN LANG="en-GB">For example</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB">although AWL have no built-in equivalent to
C++/Java </SPAN><SPAN LANG="en-GB"><B>for</B></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">statement</SPAN><SPAN LANG="en-US"><I>&nbsp;</I></SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB">it is easy to emulate one:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` C-like </I><I><B>for</B></I><I>
iterator `</I><BR>! <B>c_for</B>(@Init @Cond @Iter @Body) =<BR>{^Init;
^Cond?? {^Body; ^Iter}};</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">I</SPAN>terator <SPAN LANG="en-US">defined this
way </SPAN>can be used <SPAN LANG="en-US">almost </SPAN>as easily, as
<SPAN LANG="en-US">any </SPAN>built-in one:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>c_for</B>(I&nbsp;=&nbsp;1,
I&nbsp;&lt;=&nbsp;10, ++&nbsp;I, &lt;:&nbsp;[&quot;I = &quot; I
&quot;\n&quot;]);</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">prints
all</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">integers</SPAN><SPAN LANG="en-GB">
from 1 to 10, </SPAN><SPAN LANG="en-US">in sequence</SPAN><SPAN LANG="en-GB">.</SPAN>
<SPAN LANG="en-GB">Lazily evaluated </SPAN><SPAN LANG="en-GB"><I>functor
arguments</I></SPAN><SPAN LANG="en-GB"> can be used to implement many
language extensions, including </SPAN><SPAN LANG="en-US">some
</SPAN><SPAN LANG="en-GB">non-standard conditionals and iterators.
</SPAN><SPAN LANG="en-US">Here is another example: &ldquo;arithmetic
if&rdquo; </SPAN><SPAN LANG="en-US">functor (</SPAN><SPAN LANG="en-US">Fortran-style</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` </I><SPAN LANG="en-US"><I>Arithmetic</I></SPAN><I>
</I><SPAN LANG="en-US"><I><B>if</B></I></SPAN><I> </I><SPAN LANG="en-US"><I>conditional</I></SPAN><I>
`</I><BR>! <SPAN LANG="en-US"><B>a_if</B></SPAN>(<SPAN LANG="en-US">Value</SPAN>
@<SPAN LANG="en-US">WhenPos</SPAN> @<SPAN LANG="en-US">WhenNeg
@WhenZero</SPAN>) =<BR>V<SPAN LANG="en-US">alue&nbsp;&lt;&nbsp;0 ?
^WhenNeg : Value&nbsp;&gt;&nbsp;0 ? ^WhenPos : ^WhenZero</SPAN>;</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This functor treats its first argument <I>Value</I> as numeric, and
evaluates (and returns) one of three following arguments (depending
on <I>Value</I> happens to be negative, positive or zero). Note, what
<I>only one</I> of three final arguments is evaluated.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Lazy
evaluation is also</SPAN><SPAN LANG="en-GB"> useful to implement
</SPAN><SPAN LANG="en-GB"><I>wrappers</I></SPAN><SPAN LANG="en-GB">:
functors, </SPAN><SPAN LANG="en-US">which</SPAN><SPAN LANG="en-GB">
surround evaluation </SPAN><SPAN LANG="en-US">of its argument(s) </SPAN><SPAN LANG="en-GB">with
some </SPAN><SPAN LANG="en-US">initial</SPAN><SPAN LANG="en-US">ising</SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-GB">&ldquo;</SPAN><SPAN LANG="en-GB"><I>prologue</I></SPAN><SPAN LANG="en-GB">&rdquo;</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-US">final</SPAN><SPAN LANG="en-US">ising</SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-GB">&ldquo;</SPAN><SPAN LANG="en-GB"><I>epilogue</I></SPAN><SPAN LANG="en-GB">&rdquo;</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
actions. To give some idea, how wrappers work, here is a very trivial
example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>R_brackets</B></SPAN><SPAN LANG="en-GB">
(@arg) = { &lt;: '('; ^arg; &lt;: ')'; };<BR>! </SPAN><SPAN LANG="en-GB"><B>S_brackets</B></SPAN><SPAN LANG="en-GB">
(@arg) = { &lt;: '['; ^arg; &lt;: ']'; };</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">Functors
</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>R_brackets</B></SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
and </SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>S_brackets</B></SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
are </SPAN></SPAN><SPAN LANG="en-GB"><I>wrappers</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">,
&ldquo;enclosing&rdquo; evaluation of its argument in round and
square brackets. If their invocations are nested, all
&ldquo;prologue/epilogue&rdquo; actions are arranged in proper order.
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">S</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">omething
like </SPAN></SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>R_brackets</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">(</SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>S_brackets</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">(&lt;:
&ldquo;Hello&rdquo;))</SPAN></SPAN></FONT><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
will result in outputting &ldquo;([Hello])&rdquo;. </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">N</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">ote,
what argument here is not just a value, </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">but
</SPAN></SPAN><SPAN LANG="en-US"><I>evaluation</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
with side-effect! </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">Using
of wrappers make sure, what this side effect takes place after all
prologue actions, and before all epilogue ones.</SPAN></SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">D</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">emand-evaluation
must NOT be confused with calling functors by reference. These are
completely different language devices.</SPAN></SPAN></P>
<H3 CLASS="western">Arrays</H3>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Although lists <SPAN LANG="en-US">provide</SPAN> easiest way <SPAN LANG="en-US">to</SPAN>
aggregat<SPAN LANG="en-US">e</SPAN> data, AWL supports other <SPAN LANG="en-US">methods
of data </SPAN><SPAN LANG="en-US">structuring</SPAN>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><I>Arrays</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB">p</SPAN><SPAN LANG="en-US">rovide</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">convenient </SPAN><SPAN LANG="en-US">way</SPAN><SPAN LANG="en-GB">
to </SPAN><SPAN LANG="en-US">store</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><I>multidimensional</I></SPAN><SPAN LANG="en-GB">
data </SPAN><SPAN LANG="en-US">in the same place</SPAN><SPAN LANG="en-GB">.
As lists, array are </SPAN><SPAN LANG="en-GB"><I>heterogenic</I></SPAN><SPAN LANG="en-GB">:
</SPAN><SPAN LANG="en-US">array elements can be of different types</SPAN><SPAN LANG="en-GB">.
Standard way to create array is </SPAN><SPAN LANG="en-US">to use</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><I>array constructor</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>array</B></SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">same
as</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal"><B>a_create</B></SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">)</SPAN></SPAN><SPAN LANG="en-GB">:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=272>
	<COL WIDTH=353>
	<TR VALIGN=TOP>
		<TD WIDTH=272 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>array</B></SPAN><B>&nbsp;</B>(Dim0,
			Dim1, &hellip;, DimN)</FONT></P>
		</TD>
		<TD WIDTH=353 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Array constructor:
			create and return new array<BR>(with dimension list <B>Dim0</B>&nbsp;&hellip;&nbsp;<B>DimN</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">The
arguments </SPAN><SPAN LANG="en-GB"><I>Dim0&nbsp;&hellip;&nbsp;DimN</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">must be scalar </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">which
are evaluated and coerced to integers</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.
They provide </SPAN><SPAN LANG="en-GB"><I>dimensions</I></SPAN><SPAN LANG="en-GB">
of the created array: </SPAN><SPAN LANG="en-GB"><I>Dim0</I></SPAN><SPAN LANG="en-GB">
is the </SPAN><SPAN LANG="en-US">most</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><I>inner</I></SPAN><SPAN LANG="en-GB">
dimension, </SPAN><SPAN LANG="en-GB"><I>DimN</I></SPAN><SPAN LANG="en-GB">
is the </SPAN><SPAN LANG="en-US">most</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><I>outer</I></SPAN><SPAN LANG="en-GB">
one. Total number of array dimensions </SPAN><SPAN LANG="en-US">(in
this case, </SPAN><SPAN LANG="en-US"><I>N</I></SPAN><SPAN LANG="en-US">+1)
</SPAN><SPAN LANG="en-GB">is called </SPAN><SPAN LANG="en-GB"><I>rank</I></SPAN><SPAN LANG="en-GB">
of the array. </SPAN><SPAN LANG="en-US">As opposite to list, any
array dimension can be 1 (or even 0). </SPAN><SPAN LANG="en-GB">All
elements of the </SPAN><SPAN LANG="en-US">newly </SPAN><SPAN LANG="en-GB">created
array are </SPAN><SPAN LANG="en-US"><I>empty</I></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-GB">set to ()</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Of
course, a</SPAN><SPAN LANG="en-US">ll a</SPAN><SPAN LANG="en-US">rray
elements are </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">and accessible for change</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=181>
	<COL WIDTH=186>
	<COL WIDTH=250>
	<TR VALIGN=TOP>
		<TD WIDTH=181 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">Array
			{Inx0, Inx1,  &hellip;, InxN}</FONT></P>
		</TD>
		<TD WIDTH=186 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>a_</B></SPAN><SPAN LANG="en-US"><B>elem</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Array,
			Inx0, </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Inx1,</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">
			&hellip;, InxN</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=250 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Accessor for <B>Array</B>
			element<BR>(with index list: <B>Inx0</B>&nbsp;&hellip;&nbsp;<B>InxN</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">This</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><I>array accessor</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-GB">provides mutable access to the
element of </SPAN><SPAN LANG="en-GB"><I>Array</I></SPAN><SPAN LANG="en-GB">
with indexes </SPAN><SPAN LANG="en-GB"><I>Inx0&nbsp;&hellip;&nbsp;InxN</I></SPAN>
<SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">corresponding to
appropriate array dimensions, </SPAN><SPAN LANG="en-US"><I>Inx0</I></SPAN><SPAN LANG="en-US">
is the inner index, and </SPAN><SPAN LANG="en-US"><I>InxN</I></SPAN><SPAN LANG="en-US">
is the outer one</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">Number of indices in list must be equal to
array rank. </SPAN><SPAN LANG="en-GB">Indexing starts from 0,
negative index values are not </SPAN><SPAN LANG="en-US">permitted</SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">When any of the indices is out of range,
appropriate array element do not exist (results in ()).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The operations listed below provide some information about array:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_dims</B><SPAN STYLE="font-weight: normal">(Array</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Return list of
			<B>Array</B> dimensions<BR>(same <SPAN LANG="en-US">list</SPAN>,
			as was used <SPAN LANG="en-US">in array constructor</SPAN>)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_rank</B>(Array)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Return rank of
			<B>Array</B><BR>(<SPAN LANG="en-US">equals to</SPAN>
			#&nbsp;<B>a_dims</B>(<B>Array</B>))</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_total</B>(Array)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Return total
			number of elements in <B>Array</B><BR>(same, as
			<B>Dim0</B>*<B>Dim1</B>*&nbsp;&hellip;&nbsp;*<B>DimN</B>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The fastest way to fill entire array with some value is to use the
following mutator:</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_fill</B>(Array,
			Value)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Fill <B>Array</B>
			with <B>Value</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
New <I>Value</I> is assigned to all elements of <I>Array</I>.
(Caution: if <I>Value</I> is mutable, all array elements share it!)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
To convert quickly between lists and arrays, the following operations
may be used:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=290>
	<COL WIDTH=335>
	<TR VALIGN=TOP>
		<TD WIDTH=290 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_load</B>(Array,
			List)</FONT></P>
		</TD>
		<TD WIDTH=335 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Load all elements
			from <B>List</B> to <B>Array</B><BR>(if <B>List</B> is too short,
			final <SPAN LANG="en-US">array </SPAN>elements remain unchanged)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=290 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_save</B>(Array)</FONT></P>
		</TD>
		<TD WIDTH=335 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Save elements from
			<B>Array</B> as list<BR>(same elements order<SPAN LANG="en-US">ing</SPAN>,
			as in <B>a_load</B>)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=290 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_copy</B>(Array)</FONT></P>
		</TD>
		<TD WIDTH=335 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Make
			exact copy of</SPAN> <B>Array</B><BR>(with same rank, dimensions
			and elemen<SPAN LANG="en-US">t values</SPAN>)</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Functor <B>a_save</B> saves array contents (in the form of flattened
list, with each list element corresponding to each array element).
The elements are ordered with most &ldquo;inner&rdquo; array index
changing first, and most &ldquo;outer&rdquo; index changing last. The
resulting list is <I>always</I> <I>open</I>, and normally contains
<B>a_rank</B>(<I>Array</I>) elements (but it may be shorter, because
final empty elements may be truncated). The <B>a_load</B> does the
reverse to <B>a_save</B>: it loads array with the flattened list of
elements, in the same order as they are saved.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Functor <B>a_copy</B> makes and returns exact copy of its array
operand, with same rank, list of dimensions, and elements. (Warning:
when elements are mutable, both array copies share them!)</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The following functor provides less trivial way to fill array with
elements:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=248>
	<COL WIDTH=377>
	<TR VALIGN=TOP>
		<TD WIDTH=248 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_init_all</B>(Array,
			Func)</FONT></P>
		</TD>
		<TD WIDTH=377 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Initialise all
			elements of <B>Array</B>,<BR>applying <B>Func</B> to list of
			indices</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
All elements of <I>Array</I> are assigned with results of <I>Func</I><SPAN STYLE="font-style: normal">
</SPAN><SPAN STYLE="font-style: normal">(must be reference to
functor)</SPAN>, called with the list of this element indices. (The
length of index list is the rank of <I>Array</I>.)</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there is separate iterator to walk over all elements of
<I>Array</I>:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=272>
	<COL WIDTH=353>
	<TR VALIGN=TOP>
		<TD WIDTH=272 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>a_loop</B>(Array,
			Var, @Body)</FONT></P>
		</TD>
		<TD WIDTH=353 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Iterate <SPAN LANG="en-US">through</SPAN>
			<B>Array</B>: for each element,<BR>assign it to <B>Var</B>, then
			evaluate <B>Body</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The <I>Body</I> is evaluated for any element of <I>Array</I> (so, the
total number of iterations equals to <B>a_total</B>(<I>Array</I>)).
On each iteration, the loop variable <I>Var</I> provides access to
current element. Array elements are processed in the same order, as
with <B>a_save</B> and <B>a_load</B>. As with all other iterators,
the result of evaluation is final result of the <I>Body</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">An</SPAN> example: the following <SPAN LANG="en-US">functor</SPAN>
creates and returns square identity matrix <SPAN LANG="en-US">(</SPAN>of
order <I>N</I><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">)</SPAN></SPAN>:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">!
</SPAN><SPAN LANG="en-GB"><B>identity_mtx</B></SPAN><SPAN LANG="en-GB">(N)
: [i matrix] = {<BR>matrix = </SPAN><SPAN LANG="en-GB"><B>array</B></SPAN><SPAN LANG="en-GB">(N,
N);<BR></SPAN><SPAN LANG="en-GB"><B>a_fill</B></SPAN><SPAN LANG="en-GB">(matrix,
0);<BR></SPAN><SPAN LANG="en-GB"><B>for_inc</B></SPAN><SPAN LANG="en-GB">(i,
N, matrix{i, i} = 1);<BR>matrix }</SPAN>;</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Although
arrays always can be replaced by </SPAN><SPAN LANG="en-US">several
levels of</SPAN><SPAN LANG="en-GB"> nested lists&nbsp;</SPAN><SPAN LANG="en-US">&ndash;
</SPAN><SPAN LANG="en-GB">they provide </SPAN><SPAN LANG="en-US">better</SPAN><SPAN LANG="en-GB">
way to store multi-dimensional data. Huge array </SPAN><SPAN LANG="en-US">usually
</SPAN><SPAN LANG="en-GB">require considerable less memory, than
equivalent combination of nested lists. Random access to array
elements is also faster, than to </SPAN><SPAN LANG="en-US">nested
</SPAN><SPAN LANG="en-GB">lists.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">However,
arrays have </SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-GB">drawback:
their reshaping may be </SPAN><SPAN LANG="en-GB"><I>slow</I></SPAN><SPAN LANG="en-GB">.
To add, insert or delete array elements, entire array must be
reshaped&nbsp;</SPAN><SPAN LANG="en-US">&ndash; for lists, elements
insertion and deletion </SPAN><SPAN LANG="en-US">are</SPAN><SPAN LANG="en-US">
much faster. (There are built-in operations to insert and/or delete
array elements, </SPAN><SPAN LANG="en-US">which are </SPAN><SPAN LANG="en-US">not
detailed here&nbsp;&ndash; but even these can be </SPAN><SPAN LANG="en-US">quite
</SPAN><SPAN LANG="en-US">slow for huge arrays.)</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Sometimes,
it is reasonable to collect </SPAN><SPAN LANG="en-US">set of elements</SPAN><SPAN LANG="en-US">
elements in list (when they are read from file </SPAN><SPAN LANG="en-US">or
</SPAN><SPAN LANG="en-US">input </SPAN><SPAN LANG="en-US">stream</SPAN><SPAN LANG="en-US">,
for example), and when </SPAN><SPAN LANG="en-US">they are collected</SPAN><SPAN LANG="en-US">
&ndash; re</SPAN><SPAN LANG="en-US">assemble them into array, for
fast</SPAN><SPAN LANG="en-US">er</SPAN><SPAN LANG="en-US"> access.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Array and scalars are NOT interchangeable (even if array contains
only one element, it remains array). There is a predicate to check
for arrays:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=282>
	<COL WIDTH=343>
	<TR VALIGN=TOP>
		<TD WIDTH=282 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><SPAN LANG="en-US"><B>array</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=343 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">evaluates to array</SPAN><SPAN LANG="en-US">?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>(This predicate
checks <I>v</I>, returning <B>true</B> (1) only of it is valid
reference to array.)</FONT></FONT></P>
<H3 LANG="en-GB" CLASS="western">Hashes (dictionaries)</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><I>Hash</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="ru-RU">(</SPAN><SPAN LANG="en-US">or dictionary</SPAN><SPAN LANG="ru-RU">)
</SPAN><SPAN LANG="en-US">is</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">an
</SPAN><SPAN LANG="en-GB">association between set of </SPAN><SPAN LANG="en-GB"><I>keys</I></SPAN><SPAN LANG="en-GB">,
and set of </SPAN><SPAN LANG="en-GB"><I>values</I></SPAN><SPAN LANG="en-GB">
corresponding to them. Both </SPAN><SPAN LANG="en-US">hash </SPAN><SPAN LANG="en-GB">keys
and </SPAN><SPAN LANG="en-US">hash </SPAN><SPAN LANG="en-GB">values
can be of arbitrary type (the only illegal value for a key is </SPAN><SPAN LANG="en-GB"><B>undef</B></SPAN><SPAN LANG="en-GB">).
</SPAN><SPAN LANG="en-US">Hashes are </SPAN><SPAN LANG="en-US"><I>mutable</I></SPAN><SPAN LANG="en-US">:
keys (with appropriate values) can be added to, or removed from.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Hash
is created by invoking hash constructor </SPAN><SPAN LANG="en-GB"><B>hash</B></SPAN><SPAN LANG="en-GB">
(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">also
available as</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-GB"><B>h_create</B></SPAN><SPAN LANG="en-GB">):</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">MyHash = <B>hash</B>();</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">The
only (optional) parameter of </SPAN><SPAN LANG="en-GB"><B>hash</B></SPAN><SPAN LANG="en-GB">
is the integer value, defining </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">initial</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
internal capacity of the hash.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=212>
	<COL WIDTH=413>
	<TR VALIGN=TOP>
		<TD WIDTH=212 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>hash&nbsp;</B>(<SPAN LANG="en-US">[Capacity]</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=413 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hash constructor:
			create and return new empty hash<BR><SPAN LANG="en-US">(with
			optional </SPAN><SPAN LANG="en-US"><B>Capacity</B></SPAN><SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Newly created hash is empty. The hash capacity is the internal number
of <I>hash buckets</I> (when omitted, default value is used).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
In order to match hash keys, the <I>identity check</I> for them is
applied. To check pair of values for either identity or difference,
the following predicates may be used:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=116>
	<COL WIDTH=208>
	<COL WIDTH=293>
	<TR VALIGN=TOP>
		<TD WIDTH=116 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">X&nbsp;[==]&nbsp;Y</FONT></P>
		</TD>
		<TD WIDTH=208 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>ident</B>(X,
			Y)</FONT></P>
		</TD>
		<TD WIDTH=293 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>X</B> is
			identical to <B>Y</B>?</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=116 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">X&nbsp;[&lt;&gt;]&nbsp;Y</FONT></P>
		</TD>
		<TD WIDTH=208 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>differ</B>(X,
			Y)</FONT></P>
		</TD>
		<TD WIDTH=293 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><B>X</B> is not
			identical to <B>Y</B>?</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The identity comparison always use <I>strict</I> approach: two value
are identical, if there is no way to tell first from second.
(However, for anything mutable, like lists, identity does not mean,
what they are same physically.) As opposite to scalar compare
operations, no implicit coercions are performed. So, numbers are
<I>never</I> identical to strings (12 is not equal to &ldquo;12&rdquo;),
and integer and float numbers differ (12 is not equal to 12.0). When
operands are of different internal types, they must be coerced to
same type <I>explicitly</I>, before checking for identity.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Checks for identity/difference can be applied to other types as well.
For example, lists are identical, if they have same length, and pairs
of elements in them are identical. (BTW, language provides no
standard way for <I>ordered</I> compare of arbitrary data.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">To
get mutable access to element of </SPAN><SPAN LANG="en-US"><I>Hash</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">associated with </SPAN><SPAN LANG="en-US">certain</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>Key</I></SPAN><SPAN LANG="en-US">,</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">accessor</SPAN><SPAN LANG="en-US">
</SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx"><B>h_elem</B></SPAN></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="zxx"><SPAN LANG="zxx">(Hash,
Key)</SPAN></SPAN></FONT><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">is
normally</SPAN><SPAN LANG="en-US"> used.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=124>
	<COL WIDTH=185>
	<COL WIDTH=308>
	<TR VALIGN=TOP>
		<TD WIDTH=124 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace">Hash-&gt;Key</FONT></P>
		</TD>
		<TD WIDTH=185 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_elem</B>(Hash,
			Key)</FONT></P>
		</TD>
		<TD WIDTH=308 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hash element
			accessor:<BR>provides mutable access<BR>to element of <B>Hash</B>,
			associated with <B>Key</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">I</SPAN><SPAN LANG="en-US">f
there was not element with </SPAN><SPAN LANG="en-US"><I>Key</I></SPAN><SPAN LANG="en-US">
in </SPAN><SPAN LANG="en-US"><I>Hash</I></SPAN><SPAN LANG="en-US"><I>
&ndash; </I></SPAN><SPAN LANG="en-US">it is created </SPAN><SPAN LANG="en-US">automatically
</SPAN><SPAN LANG="en-US">(with empty value </SPAN><SPAN LANG="en-US">bound
to it</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For example:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>h_elem</B></SPAN><SPAN LANG="en-US">(MyHash,
&ldquo;hundred&rdquo;)&nbsp;=&nbsp;100;<BR></SPAN><SPAN LANG="en-US"><B>h_elem</B></SPAN><SPAN LANG="en-US">(MyHash,
&ldquo;thousand&rdquo;)&nbsp;=&nbsp;1000;</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">U</SPAN><SPAN LANG="en-US">sing
</SPAN><SPAN LANG="en-US"><B>h_elem</B></SPAN><SPAN LANG="en-US">
sometimes has undesired side-effect: it </SPAN><SPAN LANG="en-US"><I>always</I></SPAN><SPAN LANG="en-US">
creates requested key (even when associated value was not changed
after). Functor </SPAN><SPAN LANG="en-US"><B>h_lookup</B></SPAN><SPAN LANG="en-US">
is safer: although its result is not mutable (</SPAN><SPAN LANG="en-US">it
</SPAN><SPAN LANG="en-US">provid</SPAN><SPAN LANG="en-US">es</SPAN><SPAN LANG="en-US">
read-only access to values), it </SPAN><SPAN LANG="en-US"><I>never</I></SPAN><SPAN LANG="en-US">
creates new key</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">.
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">When
the requested key is not </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">found</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
in hash, it just returns ().</SPAN></SPAN></P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_lookup</B>(Hash,
			Key)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Hash element
			lookup:<BR>locate element with <B>Key</B> <SPAN LANG="en-US">in
			</SPAN><SPAN LANG="en-US"><B>Hash</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">This
functor returns value, which was associated with <I>Key</I> (or (),
if <I>Key</I> was not found in hash).</P>
<P CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">And, just
to check for existence of specified key in hash, the following
predicate can be used:</P>
<P CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_</B><SPAN LANG="en-US"><B>exists</B></SPAN><SPAN STYLE="font-weight: normal">(Hash,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Key</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">True,
			if </SPAN><SPAN LANG="en-US"><B>Key</B></SPAN> <SPAN LANG="en-US">exists
			in </SPAN><B>Hash</B></I></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
As far, as new key is inserted in hash, it remains there (no matter
of which value is assigned to it). Even assigning () to value does
not remove this key. When needed, it must be removed explicitly:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=253>
	<COL WIDTH=372>
	<TR VALIGN=TOP>
		<TD WIDTH=253 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_remove</B>(Hash,
			Key)</FONT></P>
		</TD>
		<TD WIDTH=372 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Remove element
			with <B>Key</B> from <B>Hash</B>, if present</I></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">The result
of <B>h_remove</B> is value, which was stored with <I>Key</I>.</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">To get
total count of key/value pairs in hash, the following functor can be
used:</P>
<P CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_count</B><SPAN STYLE="font-weight: normal">(Hash</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Return number of
			elements stored in <B>Hash</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Also,
t</SPAN><SPAN LANG="en-US">here are ways to &ldquo;exports&rdquo; and
&ldquo;import&rdquo; data from hash, in the list form. The following
functors are used to export:</SPAN></P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_keys</B>(Hash)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Ret</SPAN><SPAN LANG="en-US">rieve</SPAN><SPAN LANG="en-US">
			l</SPAN>ist of all keys in <B>Hash</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_values</B>(Hash)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Ret</SPAN><SPAN LANG="en-US">rieve</SPAN><SPAN LANG="en-US">
			l</SPAN>ist of all values in <B>Hash</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_</B><SPAN LANG="en-US"><B>save</B></SPAN>(Hash)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Ret</SPAN><SPAN LANG="en-US">rieve</SPAN><SPAN LANG="en-US">
			l</SPAN>ist of all <SPAN LANG="en-US">key/</SPAN>value <SPAN LANG="en-US">pairs</SPAN>
			in <B>Hash</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The results of these are always <I>open lists</I>. First two
operations return (respectively) lists of hash <I>keys</I> and hash
<I>values</I>. For final operation (<B>h_save</B>) result is list of
hash <I>elements</I>, each of them is saved in the form of <I>Key</I>::<I>Value</I>
pair. The ordering of elements in these lists is <I>not predictable</I>
(but it is always the same for <B>h_keys</B>, <B>h_values</B> and
<B>h_save</B>).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Functor <B>h_load</B> is kind of reverse to <B>h_save</B>:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=258>
	<COL WIDTH=367>
	<TR VALIGN=TOP>
		<TD WIDTH=258 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_</B><SPAN LANG="en-US"><B>load</B></SPAN>(Hash,
			<SPAN LANG="en-US">Elem1,<BR>Elem2, &hellip;, </SPAN><SPAN LANG="en-US">ElemN</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=367 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Loads
			elements </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><B>Elem1</B></SPAN><SPAN LANG="en-US">&nbsp;&hellip;&nbsp;</SPAN><SPAN LANG="en-US"><B>ElemN</B></SPAN><SPAN LANG="en-US">)
			</SPAN><SPAN LANG="en-US">into</SPAN> <B>Hash</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This operation loads list of <I>Key</I>::<I>Value</I> elements into
<I>Hash</I>. (In the case the keys were already present in hash, the
new values silently override old ones.)</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm">Finally,
the following operation may be used for fast hash cleanup:</P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_clear</B>(Hash)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Clea<SPAN LANG="en-US">n</SPAN>
			<B>Hash</B> <SPAN LANG="en-US">up</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This operation removes <I>everything</I> from <I>Hash</I> (making it
completely empty).</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
As with arrays, there is designated iterator to loop through hash:</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=284>
	<COL WIDTH=341>
	<TR VALIGN=TOP>
		<TD WIDTH=284 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>h_loop</B>(Hash,
			Var, @Body)</FONT></P>
		</TD>
		<TD WIDTH=341 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Iterate <SPAN LANG="en-US">through</SPAN>
			<B>Hash</B>: for each element,<BR>assign it to <B>Var</B>, then
			evaluate <B>Body</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">This
i</SPAN><SPAN LANG="en-GB">terates through </SPAN><SPAN LANG="en-GB"><I><SPAN STYLE="font-weight: normal">Hash</SPAN></I></SPAN><SPAN LANG="en-GB">,
setting </SPAN><SPAN LANG="en-GB"><I>Var</I></SPAN><SPAN LANG="en-GB">
to </SPAN><SPAN LANG="en-GB"><I>Key::Value</I></SPAN><SPAN LANG="en-GB">
for each hash element </SPAN><SPAN LANG="en-US">just </SPAN><SPAN LANG="en-GB">before
invoking </SPAN><SPAN LANG="en-GB"><I>Body</I></SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">Total number of iterations is always
</SPAN><SPAN LANG="en-US"><B>h_count</B></SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US"><I>Hash</I></SPAN><SPAN LANG="en-US">),
but </SPAN><SPAN LANG="en-US">th</SPAN><SPAN LANG="en-US">eir</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">order is not predictable.</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US">Result </SPAN><SPAN LANG="en-US">of
iterator </SPAN><SPAN LANG="en-US">is the final result of </SPAN><SPAN LANG="en-US"><I>Body</I></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there is a way to change (internal) hash capacity:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=269>
	<COL WIDTH=356>
	<TR VALIGN=TOP>
		<TD WIDTH=269 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>h_</B></SPAN><SPAN LANG="en-US"><B>reh</B></SPAN><SPAN LANG="en-US"><B>ash</B></SPAN><B>&nbsp;</B>(<SPAN LANG="en-US">Hash,
			</SPAN><SPAN LANG="en-US">[Capacity]</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=356 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Rehash
			</SPAN><SPAN LANG="en-US"><B>Hash</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">to </SPAN><SPAN LANG="en-US">new</SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US"><B>Capacity</B></SPAN><SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This changes hash capacity, while preserving all the data present in
<I>H</I><I>ash</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Because hash keys may be lists, they may be changed. Generally, it's
bad idea to change mutable hash keys, because this invalidates
internal hash consistency. Note, what applying <B>h_rehash</B>
successfully revalidates hash.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finally, there is a predicate to check for hashes:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=282>
	<COL WIDTH=343>
	<TR VALIGN=TOP>
		<TD WIDTH=282 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><SPAN LANG="en-US"><B>hash</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=343 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">evaluates to </SPAN><SPAN LANG="en-US">hash</SPAN><SPAN LANG="en-US">?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>(This predicate
checks <I>v</I>, returning <B>true</B> (1) only of it is valid
reference to hash.)</FONT></FONT></P>
<H3 LANG="en-GB" CLASS="western">Patterns and <SPAN LANG="en-US">pattern
</SPAN>matching</H3>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<I>Patterns</I> are <SPAN LANG="en-US">a very </SPAN>special <SPAN LANG="en-US">kind</SPAN>
of data, <SPAN LANG="en-US">which is </SPAN>used mostly to <I>match</I>
<SPAN LANG="en-US">character </SPAN>strings <SPAN LANG="en-US">against
them</SPAN>. They <SPAN LANG="en-US">are us</SPAN><SPAN LANG="en-US">ed</SPAN>
like a regular expressions. (<SPAN LANG="en-US">A</SPAN>ctually,
there are library tools to parse PCRE-<SPAN LANG="en-US">format</SPAN>
<SPAN LANG="en-US">reg</SPAN><SPAN LANG="en-US">ular </SPAN><SPAN LANG="en-US">exp</SPAN><SPAN LANG="en-US">ressions</SPAN>,
<SPAN LANG="en-US">and </SPAN>convert them to patterns). However,
patterns <SPAN LANG="en-US">must</SPAN> be constructed <I>explicitly</I>,
by using a built-in set of <SPAN LANG="en-US"><I>pattern
</I></SPAN><I>constructors</I>. <SPAN LANG="en-US">Once created,
pattern may be </SPAN><SPAN LANG="en-US">matched</SPAN><SPAN LANG="en-US">
many times.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are constructors for most trivial patterns:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=213>
	<COL WIDTH=412>
	<TR VALIGN=TOP>
		<TD WIDTH=213 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_null</B>()</FONT></P>
		</TD>
		<TD WIDTH=412 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Null
			pattern<BR>(always <SPAN LANG="en-US">successfully </SPAN>matches
			empty string)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=213 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_char</B><SPAN STYLE="font-weight: normal">(code</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=412 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Single
			c</SPAN>haracter pattern: match only char<SPAN LANG="en-US">acter
			with</SPAN> <B>code</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=213 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_string</B><SPAN STYLE="font-weight: normal">(string</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=412 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>String pattern:
			match only <B>string</B><BR>(but <SPAN LANG="en-US">with </SPAN>respect
			to <SPAN LANG="en-US">active </SPAN>collation mode)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=213 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_any</B>()</FONT></P>
		</TD>
		<TD WIDTH=412 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Match any <SPAN LANG="en-US">(</SPAN>single<SPAN LANG="en-US">)</SPAN>
			character</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<SPAN LANG="en-US">Constructors </SPAN><SPAN LANG="en-US"><B>rx_char</B></SPAN><SPAN LANG="en-US">
and </SPAN><SPAN LANG="en-US"><B>rx_string</B></SPAN><SPAN LANG="en-US">
create single character </SPAN><SPAN LANG="en-US">pattern </SPAN><SPAN LANG="en-US">and
string pattern. </SPAN><SPAN LANG="en-US">Note: when simple string is
used, where pattern is expected, </SPAN><SPAN LANG="en-US"><B>rx_string</B></SPAN><SPAN LANG="en-US">
is applied to it implicitly. When numeric value is used instead of
pattern &ndash; </SPAN><SPAN LANG="en-US"><B>rx_char</B></SPAN><SPAN LANG="en-US">
is implicitly applied. (Note, what unlike in scalar operations &ndash;
value is converted in character code.)</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The following patterns match arbitrary <I>character classes</I>, as
specified by predicates:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=197>
	<COL WIDTH=428>
	<TR VALIGN=TOP>
		<TD WIDTH=197 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_any_in</B>(c_pred)</FONT></P>
		</TD>
		<TD WIDTH=428 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Check (inclusive)
			<SPAN LANG="en-US">for </SPAN>predicate: match any cha<SPAN LANG="en-US">racter<BR></SPAN>with
			<B>code</B>, for which <B>c_pred</B> ! (<B>code</B>) is <B>true</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=197 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_any_ex</B>(c_pred)</FONT></P>
		</TD>
		<TD WIDTH=428 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Check (exclusive)
			<SPAN LANG="en-US">for </SPAN>predicate: match any cha<SPAN LANG="en-US">racter<BR></SPAN>with
			<B>code</B>, for which <B>c_pred</B> ! (<B>code</B>) is <B>false</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
For <B>rx_any_in</B> and <B>rx_any_ex</B> operand is functional: this
is <I>predicate</I>, which expects <I>character code</I> (<SPAN LANG="en-US">number,
</SPAN>not string!) as its <SPAN LANG="en-US">only </SPAN>argument.
It checks character for belonging to some set: if predicate returns
<B>true</B>, character is included.</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<SPAN LANG="en-US">S</SPAN><SPAN LANG="en-US">ome built-in character
predicates </SPAN><SPAN LANG="en-US">are available</SPAN><SPAN LANG="en-US">:
for example, </SPAN><SPAN LANG="en-US"><B>is_digit</B></SPAN><SPAN LANG="en-US">
checks operand to be </SPAN><SPAN LANG="en-US">decimal </SPAN><SPAN LANG="en-US">digit,
</SPAN><SPAN LANG="en-US"><B>is_alpha</B></SPAN><SPAN LANG="en-US">
checks it to be alpha character, etc.</SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">For
example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>rx_any_in</B></SPAN><SPAN LANG="en-US">
(!</SPAN><SPAN LANG="en-US"><B>is_digit</B></SPAN><SPAN LANG="en-US">)</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
Match any decimal digit.</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>rx_any_ex</B></SPAN><SPAN LANG="en-US">
(!</SPAN><SPAN LANG="en-US"><B>is_alpha</B></SPAN><SPAN LANG="en-US">)</SPAN></FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
Match all characters, except alphabet ones.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
The following constructors accept pattern(s) as operands, and can
build complex patterns from simpler ones:</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=269>
	<COL WIDTH=356>
	<TR VALIGN=TOP>
		<TD WIDTH=269 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_alt</B>(first,
			second)</FONT></P>
		</TD>
		<TD WIDTH=356 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Patterns
			a</SPAN>lternation:<BR>match either <B>first</B> or <B>second</B>
			<SPAN LANG="en-US">pattern</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=269 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_cat</B>(head,
			tail)</FONT></P>
		</TD>
		<TD WIDTH=356 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Patterns
			</SPAN><SPAN LANG="ru-RU">c</SPAN><SPAN LANG="ru-RU">oncatenation</SPAN>:<BR>match
			<B>head</B>, followed by <B>tail</B> <SPAN LANG="en-US">pattern</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=269 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_rep</B>(pattern,<BR>mode,
			range)</FONT></P>
		</TD>
		<TD WIDTH=356 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Pattern
			r</SPAN>epetition:<BR>match <B>pattern</B>, <SPAN LANG="en-US">not
			</SPAN><SPAN LANG="ru-RU">more/</SPAN><SPAN LANG="en-US">less than
			</SPAN><B>range</B> times<BR><SPAN LANG="en-US">(</SPAN>with <B>mode</B>
			greediness<SPAN LANG="en-US">)</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<SPAN LANG="en-US">With</SPAN> <B>rx_alt</B> and <B>rx_cat</B>,
<I>alternation</I> and <I>concatenation</I> of patterns can be
constructed. <SPAN LANG="en-US">Result of </SPAN><SPAN LANG="en-US"><I>alternation</I></SPAN><SPAN LANG="en-US">
is the pattern, matching either first, or second operand. Result of
</SPAN><SPAN LANG="en-US"><I>concatenation</I></SPAN><SPAN LANG="en-US">
is the pattern, matching first operand, followed by second operand.</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<SPAN LANG="en-US">With</SPAN> <B>rx_rep</B> <I>repetition</I> of <SPAN LANG="en-US">any</SPAN>
pattern <SPAN LANG="en-US">can be matched</SPAN>. Argument <I>range</I>
limits <SPAN LANG="en-US">allowed </SPAN>number of repetitions: if
range <SPAN LANG="en-US">specified</SPAN> as <I>Min</I>..<I>Max</I>,
<SPAN LANG="en-US">it </SPAN>allows at least <I>Min</I>, and at most
<I>Max</I> repetition<SPAN LANG="en-US">s</SPAN> of <SPAN LANG="en-US">given
</SPAN>pattern. If <I>Min</I> is omitted, 0 is assumed; if <I>Max</I>
is omitted, number of repetitions is unlimited.<SPAN LANG="en-US">
The frequenly used repetition ranges are:</SPAN></P>
<UL>
	<LI><P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
	<SPAN LANG="en-US">0..1:	match </SPAN><SPAN LANG="en-US"><I>pattern</I></SPAN><SPAN LANG="en-US">
	optionally (either present, or not);</SPAN></P>
	<LI><P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
	<SPAN LANG="en-US">1..	match unlimited (but at least once!)
	repetition of </SPAN><SPAN LANG="en-US"><I>pattern</I></SPAN><SPAN LANG="en-US">;</SPAN></P>
	<LI><P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
	<SPAN LANG="en-US">0..	match unlimited (maybe, none at all)
	repetition of </SPAN><SPAN LANG="en-US"><I>pattern</I></SPAN><SPAN LANG="en-US">;</SPAN></P>
	<LI><P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
	<SPAN LANG="en-US">N..N	match </SPAN><SPAN LANG="en-US"><I>pattern</I></SPAN><SPAN LANG="en-US">
	repeated exactly N times.</SPAN></P>
</UL>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
Argument <I>mode</I> controls repetition &ldquo;greediness&rdquo;: if
it is <B>true</B>, repetition is &ldquo;greedy&rdquo; (<SPAN LANG="en-US">looks
for</SPAN> longest <SPAN LANG="en-US">possible </SPAN>match), <SPAN LANG="en-US">but
it is &ldquo;lazy&rdquo; (looks for shortest </SPAN><SPAN LANG="en-US">possible
</SPAN><SPAN LANG="en-US">match) otherwise.</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<I>Anchors</I> are a special kind of patterns, <SPAN LANG="en-US">which
are </SPAN>used to bind match to <SPAN LANG="en-US">some</SPAN>
contexts.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=263>
	<COL WIDTH=362>
	<TR VALIGN=TOP>
		<TD WIDTH=263 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_at_start</B>(offset)</FONT></P>
		</TD>
		<TD WIDTH=362 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t string <B>offset</B> from start</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=263 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_at_end</B>(offset)</FONT></P>
		</TD>
		<TD WIDTH=362 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t string <B>offset</B> from end</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
All anchors always match <I>empty</I> context, but only in certain
positions of subject string. For example, <B>rx_at_start</B>(0) and
<B>rx_at_end</B>(0) match start and end of subject string. (Non-zero
<I>offset</I> values match in appropriate position relative to
start/end of context string.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
There are anchors, associated with character sequences:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=233>
	<COL WIDTH=392>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_before_in</B><SPAN STYLE="font-weight: normal">(c_pred</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t start of sequence, matching <B>c_pred</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_before_ex</B><SPAN STYLE="font-weight: normal">(c_pred</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t start of sequence, <SPAN LANG="en-US">NOT</SPAN>
			matching <B>c_pred</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_after_in</B><SPAN STYLE="font-weight: normal">(c_pred</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t end of sequence, matching <B>c_pred</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_after_ex</B><SPAN STYLE="font-weight: normal">(c_pred</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			a</SPAN>t end of sequence, <SPAN LANG="en-US">NOT</SPAN> matching
			<B>c_pred</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Match start/end of character sequence, which is <I>inclusive</I>
(matching predicate <I>c_pred</I>) or <I>exclusive</I> (not matching
predicate <I>c_pred</I>). All predicates, usable with <B>rx_any_in</B>
and <B>rx_any_ex</B>, can be used here. Note, what <B>rx_before_</B>...
can match start of subject string (but never end), and <B>rx_after_</B>...
can match end of subject string (but never start). (Otherwise,
<B>rx_before_in</B> will be equivalent to <B>rx_after_ex</B>; and
<B>rx_before_ex</B> equivalent to <B>rx_after_in</B>.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=233>
	<COL WIDTH=392>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_is_before</B><SPAN STYLE="font-weight: normal">(text</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			p</SPAN>receded by <B>text</B> (not included in match)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_not_before</B><SPAN STYLE="font-weight: normal">(text</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			</SPAN><SPAN LANG="en-US">NOT</SPAN> preceded by <B>text</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_is_after</B><SPAN STYLE="font-weight: normal">(text</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			f</SPAN>ollowed by <B>text</B> (not included in match)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=233 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_not_after</B><SPAN STYLE="font-weight: normal">(text</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=392 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Match
			</SPAN><SPAN LANG="en-US">NOT</SPAN> followed by <B>text</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
Match at start/end of <I>text</I> (which is NOT part of match).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
There are internal registers for temporary storage of matched
context. They can be used in the following patterns:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=262>
	<COL WIDTH=363>
	<TR VALIGN=TOP>
		<TD WIDTH=262 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_</B><SPAN LANG="en-US"><B>store</B></SPAN>(<SPAN LANG="en-US">RegNo</SPAN>,
			<SPAN LANG="en-US">Pattern</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=363 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Store
			context matching</SPAN> <SPAN LANG="en-US"><B>P</B></SPAN><B>attern</B><SPAN STYLE="font-weight: normal">
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">(on
			success)<BR>to internal register </SPAN></SPAN><SPAN LANG="en-US"><B>RegNo</B></SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=262 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_</B><SPAN LANG="en-US"><B>recall</B></SPAN>(<SPAN LANG="en-US">RegNo</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=363 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER><I>Recall context,
			preserved in register <B>RegNo</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
By default, there are 4 context registers (numbered from 0 to 3)
supported (but their number my be extended). Matching
<B>rx_store</B><SPAN STYLE="font-weight: normal">&nbsp;</SPAN>(<I>RegNo</I>,
<I>Pattern</I>) does the same as just matching <I>Pattern</I> &ndash;
but, on successful match, the matched context is preserved in
register <I>RegNo</I>. This may be recalled: matching
<B>rx_recall</B><SPAN STYLE="font-weight: normal">&nbsp;</SPAN>(<I>RegNo</I>)
tries to match context, previously stored in register <I>RegNo</I>
(and just fails, if nothing was stored in this register). Registers
storage space is existing only during matching operation.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=262>
	<COL WIDTH=363>
	<TR VALIGN=TOP>
		<TD WIDTH=262 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_</B><SPAN LANG="en-US"><B>fail</B></SPAN>()</FONT></P>
		</TD>
		<TD WIDTH=363 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-US" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I>Failure pattern</I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
This primitive pattern always fails to match anything (useful mostly
for internal debugging).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
There are a lot of operations, <SPAN LANG="en-US">expecting</SPAN>
pattern(s) <SPAN LANG="en-US">as arguments</SPAN>. <SPAN LANG="en-US">Probably,
t</SPAN><SPAN LANG="en-US">he </SPAN><SPAN LANG="en-US">most basic</SPAN><SPAN LANG="en-US">
one is:</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=280>
	<COL WIDTH=345>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_match</B>(<SPAN LANG="en-US">P</SPAN>attern,
			<SPAN LANG="en-US">S</SPAN>tring)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Try matching
			<SPAN LANG="en-US"><B>S</B></SPAN><B>tring</B> to <SPAN LANG="en-US"><B>P</B></SPAN><B>attern</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Try to match <I>Pattern</I> against <I>String</I>. Pattern matched
only at beginning, with no attempt to search.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns value is length of match found (or -1, if failed to match).</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
These functors perform pattern search:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=280>
	<COL WIDTH=345>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_findfirst</B>(<SPAN LANG="en-US">P</SPAN>attern,
			<SPAN LANG="en-US">S</SPAN>tring)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Find first
			context, matching <SPAN LANG="en-US"><B>P</B></SPAN><B>attern</B>
			in <SPAN LANG="en-US"><B>S</B></SPAN><B>tring</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_findlast</B>(<SPAN LANG="en-US">P</SPAN>attern,
			<SPAN LANG="en-US">S</SPAN>tring)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Find last context,
			matching <SPAN LANG="en-US"><B>P</B></SPAN><B>attern</B> in <SPAN LANG="en-US"><B>S</B></SPAN><B>tring</B></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Try to find <I>Pattern</I> in <I>String</I>, in appropriate direction
(forward from start&nbsp;/&nbsp;backward from end). As opposite to
<B>s_findfirst&nbsp;</B>/&nbsp;<B>s_findlast</B>, return value is not
simple index, but <I>range</I><SPAN STYLE="font-style: normal"> of
indices</SPAN>, where pattern was located. Return value is empty (),
if <I>P</I><I>attern</I> was not found in <I>String</I>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Here are set of functors, performing <I>multiple</I> pattern search
in the same string:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=280>
	<COL WIDTH=345>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_</B><SPAN LANG="en-US"><B>locate</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">P</SPAN></SPAN><SPAN STYLE="font-weight: normal">attern,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">S</SPAN></SPAN><SPAN STYLE="font-weight: normal">tring,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Range,
			Dir</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Locate
			matches of</SPAN> <SPAN LANG="en-US"><B>P</B></SPAN><SPAN LANG="en-US"><B>at</B></SPAN><SPAN LANG="en-US"><B>t</B></SPAN><SPAN LANG="en-US"><B>ern</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">in </SPAN><SPAN LANG="en-US"><B>String</B></SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_split</B><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">P</SPAN></SPAN><SPAN STYLE="font-weight: normal">attern,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">S</SPAN></SPAN><SPAN STYLE="font-weight: normal">tring,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Range,
			Dir</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I>Split <SPAN LANG="en-US"><B>S</B></SPAN><B>tring</B>
			in the places, <SPAN LANG="en-US">where</SPAN> <SPAN LANG="en-US"><B>P</B></SPAN><SPAN LANG="en-US"><B>at</B></SPAN><SPAN LANG="en-US"><B>t</B></SPAN><SPAN LANG="en-US"><B>ern</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">is found</SPAN></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><B>rx_</B><SPAN LANG="en-US"><B>replace</B></SPAN><SPAN STYLE="font-weight: normal">(</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">P</SPAN></SPAN><SPAN STYLE="font-weight: normal">attern,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">S</SPAN></SPAN><SPAN STYLE="font-weight: normal">tring,
			</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">Subst,
			Range, Dir</SPAN></SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=345 STYLE="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US">Replace
			found</SPAN> <SPAN LANG="en-US"><B>P</B></SPAN><SPAN LANG="en-US"><B>at</B></SPAN><SPAN LANG="en-US"><B>t</B></SPAN><SPAN LANG="en-US"><B>ern</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">matches in </SPAN><SPAN LANG="en-US"><B>String</B></SPAN><SPAN LANG="en-US">
			by </SPAN><SPAN LANG="en-US"><B>Subst</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal">
Call to <B>rx_locate</B> finds all (or some) matches of <I>Pattern</I>
in <I>String</I>, and returns (always open) list of them. Call to
<B>rx_split</B> returns list of <I>String</I> fragments (split where
<I>Pattern</I> is found). Call to <B>rx_replace</B> returns <I>String</I>
with all matches of <I>Pattern</I> replaced by <I>Subst</I>. For all
listed functors, optional arguments <I>Range</I> and <I>Dir</I> allow
to filter list of matches found.</P>
<P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Here
are several examples of</SPAN> <SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="en-US" CLASS="western" STYLE="margin-bottom: 0cm"><BR>
</P>
<UL>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">0..</SPAN></SPAN><SPAN STYLE="font-style: normal">1</SPAN><SPAN LANG="en-US">,
	0):		</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">Locate
	only first occurrence </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">of
	</SPAN></SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">0..</SPAN></SPAN><SPAN STYLE="font-style: normal">1</SPAN><SPAN LANG="en-US">,
	</SPAN>1<SPAN LANG="en-US">):		</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">Locate
	only last occurrence </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">of
	</SPAN></SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	0..</SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US">,
	0):		</SPAN><SPAN LANG="en-US">Locate</SPAN> <SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US">
	</SPAN><SPAN LANG="en-US">first occurrences</SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	0..</SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US">,
	</SPAN>1<SPAN LANG="en-US">):		</SPAN><SPAN LANG="en-US">Locate</SPAN>
	<SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US"> </SPAN><SPAN LANG="en-US">last
	occurrences</SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>n</I></SPAN><SPAN LANG="en-US"><I>..</I></SPAN><SPAN LANG="en-US">,
	0):		</SPAN><SPAN LANG="en-US">Locate all occurrences</SPAN>, <SPAN LANG="en-US">except
	first</SPAN> <SPAN LANG="en-US"><I>n</I></SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>n..</I></SPAN><SPAN LANG="en-US">,
	</SPAN>1<SPAN LANG="en-US">):		</SPAN><SPAN LANG="en-US">Locate all
	occurrences</SPAN>, <SPAN LANG="en-US">except last</SPAN> <SPAN LANG="en-US"><I>n</I></SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(</SPAN></SPAN><SPAN STYLE="font-style: normal">)</SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US">0</SPAN><SPAN LANG="en-US">):		</SPAN><SPAN LANG="en-US">Locate
	all  occurrences</SPAN></P>
	<LI><P CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(</SPAN></SPAN><SPAN STYLE="font-style: normal">)</SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US">1</SPAN><SPAN LANG="en-US">):		</SPAN>(<SPAN LANG="en-US"><I>same
	as above</I></SPAN>)</P>
	<LI><P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><B>rx_locate</B></SPAN><SPAN LANG="en-US">
	(</SPAN><SPAN LANG="en-US"><I>Pattern</I></SPAN><SPAN LANG="en-US">,
	</SPAN><SPAN LANG="en-US"><I>String</I></SPAN><SPAN LANG="en-US">):			</SPAN>(<SPAN LANG="en-US"><I>same
	as above</I></SPAN>)</P>
</UL>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Here is an example:</P>
<P ALIGN=LEFT STYLE="margin-left: 0.5cm; margin-right: 0.5cm; margin-top: 0.5cm; margin-bottom: 0.25cm; background: #e6e6e6; font-weight: normal; page-break-inside: avoid; page-break-before: auto; page-break-after: avoid">
<FONT FACE="Courier New, monospace">rx_locate ('ain', &quot;The rain
in Spain falls mainly on a plain&quot;);</FONT></P>
<P ALIGN=LEFT STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0.25cm; margin-bottom: 0.5cm; background: #cccccc; page-break-before: auto">
<FONT FACE="Courier New, monospace">rx_locate:(&quot;ain&quot;, &quot;The
rain in Spain falls mainly on a plain&quot;) =&gt; ((5, 8), (14, 17),
(25, 28), (38, 41), );</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
To check any expression for pattern:</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=282>
	<COL WIDTH=343>
	<TR VALIGN=TOP>
		<TD WIDTH=282 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_</B></SPAN><SPAN LANG="en-US"><B>pattern</B></SPAN>(v)</FONT></P>
		</TD>
		<TD WIDTH=343 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER><I><SPAN LANG="en-US"><B>v</B></SPAN><SPAN LANG="en-US">
			</SPAN><SPAN LANG="en-US">evaluates to </SPAN><SPAN LANG="en-US">pattern</SPAN><SPAN LANG="en-US">?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm; font-style: normal; widows: 0; orphans: 0">
<FONT FACE="Times New Roman, serif"><FONT SIZE=3>(This predicate
checks <I>v</I>, returning <B>true</B> (1) only of it is valid
reference to pattern.)</FONT></FONT></P>
<H3 LANG="en-GB" CLASS="western">Classes and objects</H3>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">AWL
provides </SPAN><SPAN LANG="en-US">necessary</SPAN><SPAN LANG="ru-RU">
</SPAN><SPAN LANG="en-GB">support for </SPAN><SPAN LANG="en-GB"><I>object-oriented
programming</I></SPAN><SPAN LANG="en-GB">, </SPAN><SPAN LANG="en-US">which
is </SPAN><SPAN LANG="en-GB">based on </SPAN><SPAN LANG="en-US">idea</SPAN><SPAN LANG="en-GB">
of </SPAN><SPAN LANG="en-GB"><I>objects</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">as</SPAN><SPAN LANG="en-GB"> instances of
user-defined </SPAN><SPAN LANG="en-GB"><I>classes</I></SPAN><SPAN LANG="en-GB">.
Before any instances of </SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-GB">class
are created, </SPAN><SPAN LANG="en-GB"><I>class definition</I></SPAN><SPAN LANG="en-GB">
must be done. </SPAN><SPAN LANG="en-US">All built-in data (like
scalars, lists, etc.) are NOT objects.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB"><I>Class
definitions</I></SPAN><SPAN LANG="en-GB"> have </SPAN><SPAN LANG="en-US">a
lot</SPAN><SPAN LANG="en-GB"> in common with functor definitions </SPAN><SPAN LANG="en-US">(not
only in syntax, but semantically)</SPAN><SPAN LANG="en-GB">. The
basic syntax of class definition is outlined below:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">!!
</SPAN><SPAN LANG="en-US"><B>myclass</B></SPAN><SPAN LANG="en-US">(par1
par2 &hellip; par</SPAN><SPAN LANG="en-US">M</SPAN><SPAN LANG="en-US">):
[loc1 loc2 &hellip; locN]<BR>{ class_defs_list };</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Similarity
between class and functor definitions is not coincidental. As well as
functors, classes have list of </SPAN><SPAN LANG="en-US"><I>class
parameters</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
(</SPAN></SPAN><SPAN LANG="en-US"><I>par1&hellip;parN</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
which are initialized by arguments) and </SPAN></SPAN><SPAN LANG="en-US"><I>class
local members</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
(</SPAN></SPAN><SPAN LANG="en-US"><I>loc1&hellip;locN</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
which </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">remain</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
uninitialized by default). </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">Any
c</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">lass
definition also can have </SPAN></SPAN><SPAN LANG="en-US"><I>constructor</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
</SPAN></SPAN><SPAN LANG="en-US"><I>destructor</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
and </SPAN></SPAN><SPAN LANG="en-US"><I>list</I></SPAN><SPAN LANG="en-US"><I>
of virtuals</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">(</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">all
of them optional and preceding </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">class
body)</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">.</SPAN></SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">So,
definition of any class creates a constructor functor for this class
as well. </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">T</SPAN></SPAN><SPAN LANG="en-GB">o
instantiate any class, </SPAN><SPAN LANG="en-US">this functor</SPAN><SPAN LANG="en-GB">
must be </SPAN><SPAN LANG="en-GB"><I>invoked</I></SPAN><SPAN LANG="en-GB">
(with list of arguments to match class parameters), and new class
instance is returned as result. </SPAN><SPAN LANG="en-US">So</SPAN><SPAN LANG="en-GB">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><SPAN STYLE="font-weight: normal">object
= </SPAN></SPAN><SPAN LANG="en-US"><B>myclass</B></SPAN><SPAN LANG="en-US">(arg1,
arg2, &hellip; arg</SPAN><SPAN LANG="en-US">M</SPAN><SPAN LANG="en-US">);</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">creates
and returns new instance of </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>myclass</B></SPAN></FONT><SPAN LANG="en-US">
(initializing </SPAN><SPAN LANG="en-US">its </SPAN><SPAN LANG="en-US">parameters
</SPAN><SPAN LANG="en-US"><I>par1&nbsp;</I></SPAN><SPAN LANG="en-US">&hellip;&nbsp;</SPAN><SPAN LANG="en-US"><I>par</I></SPAN><SPAN LANG="en-US"><I>M</I></SPAN><SPAN LANG="en-US">
with arguments </SPAN><SPAN LANG="en-US"><I>arg1&nbsp;</I></SPAN><SPAN LANG="en-US">&hellip;&nbsp;</SPAN><SPAN LANG="en-US"><I>arg</I></SPAN><SPAN LANG="en-US"><I>M</I></SPAN><SPAN LANG="en-US">,
</SPAN><SPAN LANG="en-US">and setting its locals </SPAN><SPAN LANG="en-US"><I>loc1&nbsp;</I></SPAN><SPAN LANG="en-US">&hellip;&nbsp;</SPAN><SPAN LANG="en-US"><I>locN
</I></SPAN><SPAN LANG="en-US">to empty</SPAN><SPAN LANG="ru-RU">)</SPAN><SPAN LANG="en-US">.
</SPAN><SPAN LANG="en-US">Both class parameters and class locals are
later referred to as </SPAN><SPAN LANG="en-US"><I>class members</I></SPAN><SPAN LANG="en-US">
(the only difference between them is parameters are initialised, but
locals are not). </SPAN><SPAN LANG="en-US">Argument passing is done
exactly as with all other functor calls. The difference is, normal</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">functor
evaluation is </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">always
finished,</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">
returning result. </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">I</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">n
the case of class, evaluation is &ldquo;suspended&rdquo; in the form
of object</SPAN></SPAN><SPAN LANG="en-GB">, </SPAN><SPAN LANG="en-US">which
keeps</SPAN><SPAN LANG="en-GB"> values of parameters passed. </SPAN><SPAN LANG="en-US">Any
object can be treated as kind of functor with &ldquo;suspended&rdquo;
evaluation.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">M</SPAN><SPAN LANG="en-US">ost</SPAN><SPAN LANG="en-GB">
aspects of functor parameters </SPAN><SPAN LANG="en-US">can be
applied</SPAN><SPAN LANG="en-GB"> to class parameters. </SPAN><SPAN LANG="en-US">For
example, they also can be evaluated on demand (when preceded by '@'
in declaration) and may have default initializers (which are applied,
if corresponding argument is omitted or ()).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Class
</SPAN><SPAN LANG="en-US">body is</SPAN><SPAN LANG="en-GB"> list of
class internal definitions (</SPAN><SPAN LANG="en-GB"><I>class_defs_list</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">)</SPAN></SPAN><SPAN LANG="en-GB">,
which </SPAN><SPAN LANG="en-US">normally contains</SPAN><SPAN LANG="en-GB">
definitions of local functors </SPAN><SPAN LANG="en-US">(aka </SPAN><SPAN LANG="en-US"><I>class
</I></SPAN><SPAN LANG="en-GB"><I>methods</I></SPAN><SPAN LANG="en-GB">)
and </SPAN><SPAN LANG="en-US">(sometimes) </SPAN><SPAN LANG="en-GB">even
local classes.</SPAN> <SPAN LANG="en-US">It is important to n</SPAN><SPAN LANG="en-GB">ote,
what definitions in this list are </SPAN><SPAN LANG="en-US">always
</SPAN><SPAN LANG="en-GB">separated by </SPAN><SPAN LANG="en-GB"><I>commas</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">not semicolons</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">!</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">As
</SPAN><SPAN LANG="en-US">any </SPAN><SPAN LANG="en-GB">functor,
class has his own </SPAN><SPAN LANG="en-GB"><I>name space</I></SPAN><SPAN LANG="en-GB">
(actually, two distinct name spaces</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">one </SPAN><SPAN LANG="en-GB">for </SPAN><SPAN LANG="en-US">class
</SPAN><SPAN LANG="en-GB">members, and </SPAN><SPAN LANG="en-US">other
one </SPAN><SPAN LANG="en-GB">for local functors </SPAN><SPAN LANG="en-US">and
</SPAN><SPAN LANG="en-GB">classes). </SPAN><SPAN LANG="en-US">Both
name spaces are available by default inside class declaration. But</SPAN><SPAN LANG="en-GB">
a</SPAN><SPAN LANG="en-US">ny</SPAN><SPAN LANG="en-GB"> access to </SPAN><SPAN LANG="en-US">any
</SPAN><SPAN LANG="en-GB">class internal </SPAN><SPAN LANG="en-US">definition</SPAN><SPAN LANG="en-GB">
from outside must be </SPAN><SPAN LANG="en-GB"><I>qualified</I></SPAN><SPAN LANG="en-GB">,
with qualification expression looking like:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>myclass</B>!!expression</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">This
is an example of (relatively rare) </SPAN><SPAN LANG="en-GB"><I>compile-time
operations</I></SPAN><SPAN LANG="en-GB"> of AWL (</SPAN><SPAN LANG="en-US">which
has</SPAN><SPAN LANG="en-GB"> no </SPAN><SPAN LANG="en-US">&ldquo;</SPAN><SPAN LANG="en-GB">functional&rdquo;
</SPAN><SPAN LANG="en-US">equivalent, because it is done during
compile, not run time</SPAN><SPAN LANG="en-GB">). It forces
</SPAN><SPAN LANG="en-GB"><I>expression</I></SPAN><SPAN LANG="en-GB">
to be interpreted </SPAN><SPAN LANG="en-GB"><I>in </I></SPAN><SPAN LANG="en-US"><I>lexical
</I></SPAN><SPAN LANG="en-GB"><I>context of </I></SPAN><SPAN LANG="en-GB"><B>myclass</B></SPAN><SPAN LANG="en-GB">,
making all members and </SPAN><SPAN LANG="en-US">methods</SPAN><SPAN LANG="en-GB">
of </SPAN><SPAN LANG="en-GB"><B>myclass</B></SPAN><SPAN LANG="en-GB">
accessible there. Because all variable and functor names bindings are
performed at compile time, the qualifier expression must be processed
at compile time, too. (This is inevitable: because AWL is
weakly-typed language, there is no way interpreter can predict, what
some expression results in class instance, which is </SPAN><SPAN LANG="en-US">important</SPAN><SPAN LANG="en-GB">
for resolving names properly.)</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Let's
explain t</SPAN><SPAN LANG="en-GB">he most important feature of AWL
object system, </SPAN><SPAN LANG="en-US">which</SPAN><SPAN LANG="en-GB">
is </SPAN><SPAN LANG="en-GB"><I>instant class-object binding</I></SPAN><SPAN LANG="en-GB">.
Any class always has </SPAN><SPAN LANG="en-GB"><I>current instance</I></SPAN><SPAN LANG="en-GB">
associated with it (which is void initially).</SPAN> <SPAN LANG="en-GB">Language
allows only temporary modification of class current instance, by the
following operation:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-US">object.expr</SPAN>;</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">which
is </SPAN><SPAN LANG="en-GB">completely equivalent to functional
expression </SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>with</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">(object,
expr)</SPAN></FONT><SPAN LANG="en-GB">. </SPAN><SPAN LANG="en-US">Technically,
t</SPAN><SPAN LANG="en-GB">his is </SPAN><SPAN LANG="en-GB"><I>wrapper
operation</I></SPAN><SPAN LANG="en-GB"> for </SPAN><SPAN LANG="en-GB"><I>expr</I></SPAN><SPAN LANG="en-GB">:
it evaluates and returns </SPAN><SPAN LANG="en-GB"><I>expr</I></SPAN><SPAN LANG="en-GB">,
but with </SPAN><SPAN LANG="en-GB"><I>object</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">being</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">current
instance </SPAN></SPAN><SPAN LANG="en-GB">of its own class. </SPAN><SPAN LANG="en-US">Of
course, </SPAN><SPAN LANG="en-US"><I>expr</I></SPAN><SPAN LANG="en-US">
can be quite complex (and usually, although not necessary, is functor
call). </SPAN><SPAN LANG="en-GB">Current instance definition is
</SPAN><SPAN LANG="en-US">always </SPAN><SPAN LANG="en-GB"><I>temporary</I></SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-GB"><I>local</I></SPAN><SPAN LANG="en-GB">
for this expression: when evaluation of </SPAN><SPAN LANG="en-GB"><I>expr</I></SPAN><SPAN LANG="en-GB">
is complete, current instance of class is restored to what it was
before (so, there is no problems in nesting invocations of </SPAN><SPAN LANG="en-GB"><B>with</B></SPAN><SPAN LANG="en-GB">).</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Current
instance has effect </SPAN><SPAN LANG="en-GB">(</SPAN><SPAN LANG="en-GB">for
example</SPAN><SPAN LANG="en-GB">)</SPAN><SPAN LANG="en-GB"> for </SPAN><SPAN LANG="en-US">all
</SPAN><SPAN LANG="en-GB">class members: they are always accessing
members of current class instance (or </SPAN><SPAN LANG="en-GB"><B>undef</B></SPAN><SPAN LANG="en-GB">,
if there is no current instance of such class). This explains, how
class functors operate. Although, due to the tradition, the internal
functors of the class are termed </SPAN><SPAN LANG="en-GB"><I>methods</I></SPAN><SPAN LANG="en-GB">,
they are quite different from methods in conventional OO-languages.
(For example, they have no implicit argument to specify current class
instance, as conventional methods do, because current instance is
defined externally, without any relation to functor calls.) The only
actual difference between class &ldquo;methods&rdquo; and all other
functors is what class own functors have implicit access to class
definitions, but external functors must use qualification to access
any class. Beside this, there is no principal difference between
class methods and functors, </SPAN><SPAN LANG="en-US">defined outside
class</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
For example, we can define a <SPAN LANG="en-US">very </SPAN>simple
object (representing vectors in <SPAN LANG="en-US">cartesian </SPAN>3D
space):</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">!! </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
(x y z) {<BR>	</SPAN><SPAN LANG="en-GB"><I>` length of vector `</I></SPAN><SPAN LANG="en-GB"><BR>	!
</SPAN><SPAN LANG="en-GB"><B>length</B></SPAN><SPAN LANG="en-GB"> =
</SPAN><SPAN LANG="en-GB"><B>sqr</B></SPAN><SPAN LANG="en-GB">(x*x +
y*y + z*z)<BR></SPAN>	};</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Here,
class </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
does have parametric members </SPAN><SPAN LANG="en-GB"><I>x</I></SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-GB"><I>y</I></SPAN><SPAN LANG="en-GB">, </SPAN><SPAN LANG="en-GB"><I>z</I></SPAN><SPAN LANG="en-GB">
and </SPAN><SPAN LANG="en-US">single </SPAN><SPAN LANG="en-GB">internal
functor (</SPAN><SPAN LANG="en-US">or </SPAN><SPAN LANG="en-GB">&ldquo;method&rdquo;)
</SPAN><SPAN LANG="en-GB"><B>length</B></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">without
parameters</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">,
calculating length of vector. This functor operates on </SPAN><SPAN LANG="en-GB"><I>current
instance</I></SPAN><SPAN LANG="en-GB"> of </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">and </SPAN><SPAN LANG="en-GB">expect</SPAN><SPAN LANG="en-US">s</SPAN><SPAN LANG="en-GB">
it to be defined </SPAN><SPAN LANG="en-GB"><I>externally</I></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">,
by the caller</SPAN></SPAN><SPAN LANG="en-US">).</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">F</SPAN><SPAN LANG="en-GB">or example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">vec1 =
</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">(10,
20, 30);<BR>len1 = vec1.</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">!!</SPAN><SPAN LANG="en-GB"><B>length</B></SPAN><SPAN LANG="en-GB">();</SPAN></FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">There is a d</SPAN>ifferent approach to
calculating length of vector<SPAN LANG="en-US">:</SPAN> to <SPAN LANG="en-US">create</SPAN>
functor, receiving object as argument:</P>
<P LANG="en-GB" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">! <B>length</B>(v) = <B>sqr</B>(v.x*v.x
+ v.y*v.y + v.z*v.z)</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
However, this is an extremely clumsy (and inefficient) way to define
<SPAN LANG="en-US">it</SPAN>. Th<SPAN LANG="en-US">e following</SPAN>
definition does exactly the same, but is more in style of AWL (and
more efficient, <SPAN LANG="en-US">too</SPAN>):</P>
<P LANG="zxx" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">! </SPAN><SPAN LANG="en-GB"><B>length</B></SPAN><SPAN LANG="en-GB">(v)
= v.</SPAN><SPAN LANG="en-GB"><B>sqr</B></SPAN><SPAN LANG="en-GB">(x*x
+ y*y + z*z)</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Other
functors of </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
also may prefer to to use explicit parameters for objects.</SPAN> <SPAN LANG="en-GB">For
example, the following definitions may be added to the core of
</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
class:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` add 3D vectors `</I><BR>!
<B>add</B>(v1 v2) = <B>Vector3D</B>(v1.x+v2.x, v1.y+v2.y,
v1.z+v2.z),<BR><I>` subtract 3D vectors `</I><BR>! <B>sub</B>(v1 v2)
= <B>Vector3D</B>(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z)</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Both
functors expect instances of </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">
as their arguments. As above, this definition is a bit clumsy. </SPAN><SPAN LANG="en-US">H</SPAN><SPAN LANG="en-GB">ere
are two (</SPAN><SPAN LANG="en-US">functionally</SPAN><SPAN LANG="en-GB">
equivalent) shorter versions: </SPAN><SPAN LANG="en-US">either</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">! <B>add</B>(v1 v2) =
v1.<B>Vector3D</B>(x+v2.x, y+v2.y, z+v2.z),<BR>! <B>sub</B>(v1 v2) =
v1.<B>Vector3D</B>(x-v2.x, y-v2.y, z-v2.z)</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
or:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">! <B>add</B>(v1 v2) =
v2.<B>Vector3D</B>(v1.x+x, v1.y+y, v1.z+z),<BR>! <B>sub</B>(v1 v2) =
v2.<B>Vector3D</B>(v1.x-x, v1.y-y, v1.z-z)</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">But
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">n</SPAN><SPAN LANG="en-GB">o
matter how these functors are defined</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">!!</SPAN><SPAN LANG="en-GB"><B>add</B></SPAN><SPAN LANG="en-GB">(vec1,
</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">(40,
50, 60)) returns </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">(50,
70, 90); and </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">!!</SPAN><SPAN LANG="en-GB"><B>sub</B></SPAN><SPAN LANG="en-GB">(vec1,
</SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">(40,
50, 60)) returns </SPAN><SPAN LANG="en-GB"><B>Vector3D</B></SPAN><SPAN LANG="en-GB">(-30,
-30, -30).</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
The class logic can be quite easily extended with definition of
outside class functors. Even if definition of class <B>Vector3D</B>
does not include method length, it can be done afterwards:</P>
<P LANG="en-GB" ALIGN=JUSTIFY STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">! <B>length_</B><SPAN LANG="en-US"><B>Vector3D</B></SPAN>(v)
=<BR><B>Vector3D</B><SPAN STYLE="font-weight: normal">!!</SPAN><B>sqr</B>(v.x*v.x
+ v.y*v.y + v.z*v.z);</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Of course, this functor body includes <I>qualification</I> to specify
it is working with internals of <B>Vector3D</B>, and not some other
class.</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Classes
can have </SPAN><SPAN LANG="en-GB"><I>constructors</I></SPAN><SPAN LANG="en-GB">
and/or </SPAN><SPAN LANG="en-GB"><I>destructors</I></SPAN><SPAN LANG="en-GB">
associated </SPAN><SPAN LANG="en-US">with them</SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">As opposite</SPAN><SPAN LANG="en-GB"> to
languages like Java and C++, the</SPAN><SPAN LANG="en-US">y</SPAN><SPAN LANG="en-GB">
are NOT functors, but just an </SPAN><SPAN LANG="en-GB"><I>expressions</I></SPAN>
<SPAN LANG="en-GB">(which, obviously, can be </SPAN><SPAN LANG="en-US">complicated,
like </SPAN><SPAN LANG="en-GB">blocks of code). </SPAN><SPAN LANG="en-US">If
present, any </SPAN><SPAN LANG="en-US"><I>c</I></SPAN><SPAN LANG="en-GB"><I>lass
constructor</I></SPAN><SPAN LANG="en-GB"> is invoked </SPAN><SPAN LANG="en-GB"><I>after</I></SPAN><SPAN LANG="en-GB">
instance parametric members are initialized. </SPAN><SPAN LANG="en-US">I</SPAN><SPAN LANG="en-GB">ts
objective may be checking or modifying values </SPAN><SPAN LANG="en-US">of
class members </SPAN><SPAN LANG="en-GB">(to keep class instance
internally consistent)</SPAN>, <SPAN LANG="en-GB">initialization of
non-parametric members, or </SPAN><SPAN LANG="en-US">some </SPAN><SPAN LANG="en-GB">interaction
with outside world. If object instance allocates some external
resources </SPAN><SPAN LANG="en-US">(for example, opens files)</SPAN><SPAN LANG="en-GB">,
</SPAN><SPAN LANG="en-US"><I>class </I></SPAN><SPAN LANG="en-GB"><I>destructor</I></SPAN><SPAN LANG="en-GB">
can be used to release them. </SPAN><SPAN LANG="en-US">(Destructors
are rarely needed, because most of the resources are freed
automatically, when class instance is destroyed.) </SPAN><SPAN LANG="en-GB">Here
is an example of </SPAN><SPAN LANG="en-US">an extremely</SPAN><SPAN LANG="en-GB">
trivial class, but having both constructor and destructor:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">!! </SPAN><SPAN LANG="en-GB"><B>traced</B></SPAN><SPAN LANG="en-GB">
(A B)<BR> = { &lt;: ['\n[constructor: traced (' A ',' B ')]\n' ] }<BR>
~ { &lt;: ['\n[destructor: traced (' A ',' B ')]\n'] };</SPAN></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">All
instances of </SPAN><SPAN LANG="en-GB"><B>traced</B></SPAN><SPAN LANG="en-GB">
will report </SPAN><SPAN LANG="en-US">(to standard output) </SPAN><SPAN LANG="en-GB">their
creation and destruction. In AWL (unlike Java and some other
garbage-collection languages), the destruction of objects is
</SPAN><SPAN LANG="en-GB"><I>predictable</I></SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">object is
destroyed precisely when no </SPAN><SPAN LANG="en-US">valid
</SPAN><SPAN LANG="en-GB">references </SPAN><SPAN LANG="en-US">to
</SPAN><SPAN LANG="en-GB">left</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">A</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">nother
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">concept
of </SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">object-oriented
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">programming
</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">supported
</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">directly
by AWL </SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">is
</SPAN></SPAN><SPAN LANG="en-US"><I>c</I></SPAN><SPAN LANG="en-GB"><I>lass
inheritance</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">.
</SPAN></SPAN><SPAN LANG="en-GB">Any class can have </SPAN><SPAN LANG="en-GB"><I>superclass</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
(only one: </SPAN></SPAN><SPAN LANG="en-GB"><I>multiple inheritance</I></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">
</SPAN></SPAN><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">is
not supported</SPAN></SPAN><SPAN LANG="en-GB"><SPAN STYLE="font-style: normal">,
although this idea is considered)</SPAN></SPAN><SPAN LANG="en-GB">,
from which it borrows all member and functor declarations.
Declaration of </SPAN><SPAN LANG="en-GB"><I>derived class</I></SPAN><SPAN LANG="en-GB">
has the following syntax:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">!! [<B>SuperClass</B>] <B>SubClass</B><SPAN STYLE="font-weight: normal">
(params)&nbsp;:&nbsp;[members]</SPAN> { decls };</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">Besides</SPAN><SPAN LANG="en-US">
name of superclass (in square brackets), syntax does not differ from
&ldquo;normal&rdquo; class declaration. This declaration makes
</SPAN><SPAN LANG="en-US"><B>SuperClass</B></SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>ancestor</I></SPAN><SPAN LANG="en-US">
of </SPAN><SPAN LANG="en-US"><B>SubClass</B></SPAN><SPAN LANG="en-US">
(</SPAN><SPAN LANG="en-US">as well as</SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><B>SubClass</B></SPAN><SPAN LANG="en-US">
</SPAN><SPAN LANG="en-US"><I>descendant</I></SPAN><SPAN LANG="en-US">
of </SPAN><SPAN LANG="en-US"><B>SuperClass</B></SPAN><SPAN LANG="en-US">).
</SPAN><SPAN LANG="en-GB">Deriving </SPAN><SPAN LANG="en-GB"><B>SubClass</B></SPAN><SPAN LANG="en-GB">
from </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
means, what any instance of </SPAN><SPAN LANG="en-GB"><B>SubClass</B></SPAN><SPAN LANG="en-GB">
is an instance of </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
as well. Everything defined in </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
is inherited by </SPAN><SPAN LANG="en-GB"><B>SubClass</B></SPAN><SPAN LANG="en-US"><B>
&ndash; </B></SPAN><SPAN LANG="en-GB">including all class members
(both </SPAN><SPAN LANG="en-US">class </SPAN><SPAN LANG="en-GB">paramet</SPAN><SPAN LANG="en-US">ers</SPAN><SPAN LANG="en-GB">
and not), </SPAN><SPAN LANG="en-US">all internally-declared </SPAN><SPAN LANG="en-GB">functors
</SPAN><SPAN LANG="en-US">and </SPAN><SPAN LANG="en-US">all </SPAN><SPAN LANG="en-US">other
declarations</SPAN><SPAN LANG="en-GB">. When </SPAN><SPAN LANG="en-GB"><B>SubClass</B></SPAN><SPAN LANG="en-GB">
is used in qualifier expression</SPAN><SPAN LANG="en-US"> &ndash;
</SPAN><SPAN LANG="en-GB">internals of </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
are made accessible as well. </SPAN><SPAN LANG="en-US">The same is
true for run-time object access:</SPAN><SPAN LANG="en-GB"> when
instance of </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
is used </SPAN><SPAN LANG="en-US">as first argument of</SPAN><SPAN LANG="en-GB">
</SPAN><SPAN LANG="en-GB"><B>with</B></SPAN><SPAN LANG="en-GB">
functor</SPAN><SPAN LANG="en-US"> &ndash; </SPAN><SPAN LANG="en-GB">it
</SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">temporarily</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">
becomes current instance not only of </SPAN><SPAN LANG="en-GB"><B>SubClass</B></SPAN><SPAN LANG="en-GB">,
but of </SPAN><SPAN LANG="en-GB"><B>SuperClass</B></SPAN><SPAN LANG="en-GB">
as well </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">and </SPAN><SPAN LANG="en-US">even
</SPAN><SPAN LANG="en-US">for </SPAN><SPAN LANG="en-GB">all its
ancestor classes, </SPAN><SPAN LANG="en-US">if any)</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Functionality
of class constructors and destructors is </SPAN><SPAN LANG="en-US">automatically
</SPAN><SPAN LANG="en-GB">inherited, too. </SPAN><SPAN LANG="en-US">I</SPAN><SPAN LANG="en-GB">f
there are </SPAN><SPAN LANG="en-GB"><I>constructors</I></SPAN><SPAN LANG="en-GB">
for class ancestors, they are executed, when </SPAN><SPAN LANG="en-US">any
</SPAN><SPAN LANG="en-GB">class instance is created (constructors of
superclasses are invoked first, constructors of subclasses last). </SPAN><SPAN LANG="en-US">I</SPAN><SPAN LANG="en-GB">f
class has </SPAN><SPAN LANG="en-GB"><I>destructors</I></SPAN><SPAN LANG="en-GB">,
the order of their </SPAN><SPAN LANG="en-US">invokation</SPAN><SPAN LANG="en-GB">
is </SPAN><SPAN LANG="en-GB"><I>reverse</I></SPAN><SPAN LANG="en-US">:
</SPAN><SPAN LANG="en-GB">destructors of superclasses </SPAN><SPAN LANG="en-US">done
</SPAN><SPAN LANG="en-GB">last, </SPAN><SPAN LANG="en-US">and
</SPAN><SPAN LANG="en-GB">destructors of subclasses first</SPAN>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Finally</SPAN><SPAN LANG="en-US">
&ndash; </SPAN><SPAN LANG="en-GB">because class and its ancestors
normally needs </SPAN><SPAN LANG="en-US">some</SPAN><SPAN LANG="en-GB">
parameters to initialize their instances properly</SPAN><SPAN LANG="en-US">
&ndash; </SPAN><SPAN LANG="en-GB">the arguments of superclass are
</SPAN><SPAN LANG="en-US">always </SPAN><SPAN LANG="en-GB">supplied
as </SPAN><SPAN LANG="en-GB"><I>first argument</I></SPAN><SPAN LANG="en-GB">
in the list of subclass. So, when creating instance of subclass,
argument list </SPAN><SPAN LANG="en-US">does </SPAN><SPAN LANG="en-GB">look
like</SPAN><SPAN LANG="en-US">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>subclass</B></SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">((</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>superarg1</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">,
... </SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>superargN</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">),
</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>subarg1</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">,
... </SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>subargM</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)</SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">E</SPAN><SPAN LANG="en-GB">ven
when superclass does not need initializers, </SPAN><SPAN LANG="en-US">empty
</SPAN><SPAN LANG="en-GB">() </SPAN><SPAN LANG="en-GB"><I>must be</I></SPAN><SPAN LANG="en-GB">
supplied as list of arguments for it! When there </SPAN><SPAN LANG="en-US">is
a</SPAN><SPAN LANG="en-GB"> </SPAN><SPAN LANG="en-US">chain of</SPAN><SPAN LANG="en-GB">
class ancestors, the argument lists for them </SPAN><SPAN LANG="en-US">must
be</SPAN><SPAN LANG="en-GB"> nested, </SPAN><SPAN LANG="en-US">as
shown in the following example:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>subclass</B>(((<I>super-super-class
parameters...</I>), <I>proper super-class parameters...</I>), <I>proper
subclass parameters</I>)</FONT></P>
<P LANG="en-GB" CLASS="western" STYLE="margin-bottom: 0cm">and so on.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Here is the case, where &ldquo;list constructor&rdquo; notation may
be preferrable (with it all arguments list(s) are properly
separated):</P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>subclass</B></SPAN><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">(</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>superarg1</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">,
... </SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>superargN</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)::
</SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>subarg1</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">,
... </SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>subargM</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)</SPAN></FONT></FONT></P>
<P LANG="en-US" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><B>subclass</B></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">(</SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>super-super-class
parameters...</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)::
</SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>proper
super-class parameters...</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)::
</SPAN></FONT><FONT FACE="Courier New, monospace">(</FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB"><I>proper
subclass parameters</I></SPAN></FONT><FONT FACE="Courier New, monospace"><SPAN LANG="en-GB">)</SPAN></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">Ordinary
</SPAN><SPAN LANG="en-US">class </SPAN><SPAN LANG="en-GB">functors
</SPAN><SPAN LANG="en-US">(aka &ldquo;methods&rdquo;) </SPAN><SPAN LANG="en-GB">are
</SPAN><SPAN LANG="en-US">NOT</SPAN><SPAN LANG="en-GB"> polymorphic</SPAN>.
<SPAN LANG="en-US">This means i</SPAN><SPAN LANG="en-US">f they are
defined in superclass</SPAN><SPAN LANG="en-GB"> &ndash; </SPAN><SPAN LANG="en-US">they
are inherited by any derived class, and are working there well</SPAN><SPAN LANG="en-GB">
&ndash; </SPAN><SPAN LANG="en-US">but will do </SPAN><SPAN LANG="en-US"><I>only</I></SPAN><SPAN LANG="en-US">
what </SPAN><SPAN LANG="en-US">wa</SPAN><SPAN LANG="en-US">s
specified in superclass definition. For </SPAN><SPAN LANG="en-US">&ldquo;</SPAN><SPAN LANG="en-US">ordinary&rdquo;
class functors</SPAN><SPAN LANG="en-GB"> &ndash; </SPAN><SPAN LANG="en-US">there
is no way to change behaviour in the derived class. </SPAN><SPAN LANG="en-GB">To
add polymorphism to functors definitions, special language device &ndash;
</SPAN><SPAN LANG="en-GB"><I>virtual functors</I></SPAN><SPAN LANG="en-GB">
&ndash; is </SPAN><SPAN LANG="en-US">required</SPAN><SPAN LANG="en-GB">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Although for any &ldquo;normal&rdquo; functor declaration means
definition, virtual functors separate them. Each virtual always has
single declaration, but may have several definitions (in different
derived classes). <I>Declaration</I> of class virtuals has following
syntax:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">#{ virtual1 virtual2 ... virtualN
}</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
It must follow class header, constructor and destructor (if they are
available), but must precede class body. It just lists names (and
only names) of all virtuals, declared by this class. The class
declaring virtual is called <I>originator</I> of this virtual.</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">Definition(s) of virtuals looks as usual functor
definition, </SPAN>but name of <SPAN LANG="en-US">defined </SPAN>functor
must be name of virtual, <SPAN LANG="en-US">and</SPAN> preceded by
'#':</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">! #virtualX (par1 ... parN) :
[loc1 ... locM] = body;</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">Of course, this is considered an error, if there
is no </SPAN><SPAN LANG="en-US"><B>virtualX</B></SPAN><SPAN LANG="en-US">
declared as virtual </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-US">either
in this class or any of its ancestors</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-US">.
(It's </SPAN><SPAN LANG="en-US">an error</SPAN><SPAN LANG="en-US"> as
well to define same virtual more than once for a single class.)
</SPAN><SPAN LANG="en-US">Virtual must be (re)defined not more, than
once for any of derived classes.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">So,
any virtual functor is actually an &ldquo;umbrella&rdquo; functor,
with many different definitions behind same name. </SPAN><SPAN LANG="en-GB">When
any virtual functor is invoked, </SPAN><SPAN LANG="en-GB"><I>devirtualization</I></SPAN><SPAN LANG="en-GB">
takes place: the </SPAN><SPAN LANG="en-US">proper</SPAN><SPAN LANG="en-GB">
definition of virtual (taken from subclass, to which the </SPAN><SPAN LANG="en-GB"><I>current
instance</I></SPAN><SPAN LANG="en-GB"> of originator class belongs)
is invoked. </SPAN><SPAN LANG="en-US">In other words, the &ldquo;actual&rdquo;
version of virtual is based on the current instance of its originator
class.</SPAN></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-GB">When
subclass </SPAN><SPAN LANG="en-GB"><I>does not</I></SPAN><SPAN LANG="en-GB">
redefine virtual, it inherits its definition from superclass. </SPAN><SPAN LANG="en-US">It
is possible, when</SPAN><SPAN LANG="en-GB"> virtual remains
completely undefined &ndash; </SPAN><SPAN LANG="en-US">in this case,
</SPAN><SPAN LANG="en-GB">its invocation has no effect, returning </SPAN><SPAN LANG="en-US">()</SPAN><SPAN LANG="en-GB">.
</SPAN><SPAN LANG="en-US">However, this make become error in future
revisions of the language.</SPAN></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">And
h</SPAN><SPAN LANG="en-GB">ere is an example of </SPAN><SPAN LANG="en-US">quite
</SPAN><SPAN LANG="en-GB">simple class hierarchy, </SPAN><SPAN LANG="en-US">which
</SPAN><SPAN LANG="en-GB">us</SPAN><SPAN LANG="en-US">es</SPAN><SPAN LANG="en-GB">
virtuals to operate </SPAN><SPAN LANG="en-US">on</SPAN><SPAN LANG="en-GB">
basic geometric objects (</SPAN><SPAN LANG="en-US">&ldquo;</SPAN><SPAN LANG="en-GB">shapes&rdquo;).</SPAN>
<SPAN LANG="en-GB">First, we declare </SPAN><SPAN LANG="en-US">&ldquo;</SPAN><SPAN LANG="en-GB">abstract&rdquo;
superclass, implementing geometric &ldquo;shape&rdquo; </SPAN><SPAN LANG="en-US">(</SPAN><SPAN LANG="en-GB">having
description, perimeter and area</SPAN><SPAN LANG="en-US">)</SPAN><SPAN LANG="en-GB">:</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` Abstract shape superclass
`</I><BR>!! <B>Shape</B><BR>	# {<BR>	<B>put</B>		<I>` output brief
info about self `</I><BR>	<B>perimeter</B>	<I>` calc perimeter of
self `</I><BR>	<B>area</B>		<I>` calc area of self `</I><BR>	};</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">As we see, the declaration of superclass is
extremely simple: it just lists three virtuals, to be implemented in
the derived classes. These</SPAN> (implementing <SPAN LANG="en-US">some
</SPAN>real shapes) <SPAN LANG="en-US">must </SPAN>follow this
definition:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` Rectangle (A * B) `</I><BR>!!
[<B>Shape</B>] <B>Rectangle</B> (A B) {<BR>	! #<B>put</B> = &lt;:
['Rectangle (' A ' * ' B ')'],<BR>	! #<B>perimeter</B> =
2*(A&nbsp;+&nbsp;B),<BR>	! #<B>area</B> = A&nbsp;*&nbsp;B<BR>	};</FONT></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` Square (S * S) `</I><BR>!!
[<B>Shape</B>] <B>Square</B> (S) {<BR>	! #<B>put</B> = &lt;: ['Square
[' S ']'],<BR>	! #<B>perimeter</B> = 4*S,<BR>	! #<B>area</B> =
S&nbsp;*&nbsp;S<BR>	};</FONT></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` Circle (with radius R) `</I><BR>!!
[<B>Shape</B>] <B>Circle</B> (R) {<BR>	! #<B>put</B> = &lt;: ['Circle
[' R ']'],<BR>	! #<B>perimeter</B> = 2*<B>pi</B>(R),<BR>	! #<B>area</B>
= <B>pi</B>(R*R)<BR>	};</FONT></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><I>` Triangle (with sides A, B,
C) `</I><BR>!! [<B>Shape</B>] <B>Triangle</B> (A B C) {<BR>	! #<B>put</B>
= &lt;: ['Triangle (' A ',' B ',' C ')'],<BR>	! #<B>perimeter</B> =
A&nbsp;+&nbsp;B&nbsp;+&nbsp;C,<BR>	! #<B>area</B> : [p] =
{<BR>		<I>`(Heron's formula:)`</I><BR>		p =
<B>perimeter</B>()&nbsp;/&nbsp;2;<BR>		<B>sqr</B>(p*(p&nbsp;-&nbsp;A)*(p&nbsp;-&nbsp;B)*(p&nbsp;&ndash;&nbsp;C))<BR>		}<BR>	};</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">To see, how it works</SPAN>, we can create a list
of simple geometric shapes. (<SPAN LANG="en-US">N</SPAN>ote using ()
<SPAN LANG="en-US">as argument list for superclass &ndash; even if
superclass doesn't need arguments!)</SPAN></P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace">Figures = (<BR>	<B>Square</B>
((), 5),<BR>	<B>Rectangle</B> ((), 6, 9),<BR>	<B>Circle</B> ((),
10),<BR>	<B>Triangle</B> ((), 5, 12, 13)<BR>	);</FONT></P>
<P LANG="en-GB" CLASS="western" STYLE="margin-bottom: 0cm"><SPAN LANG="en-US">We
can list some </SPAN>information about these shapes:</P>
<P LANG="zxx" STYLE="margin-left: 1cm; margin-top: 0.5cm; margin-bottom: 0.5cm; page-break-before: auto">
<FONT FACE="Courier New, monospace"><B>Shape</B>!!<B>l_loop</B> (fig,
Figures, fig.{<BR>	<B>put</B> ();<BR>	&lt;: &quot;: &quot;;<BR>	&lt;:
(&quot;Perimeter = &quot;, <B>perimeter</B>(), &quot;; &quot;);<BR>	&lt;:
(&quot;Area = &quot;, <B>area</B>());<BR>	&lt;: &quot;\n&quot;;<BR>	});</FONT></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Note, what all this expression is &ldquo;qualified&rdquo; with
<B>Shape</B>!! (to make shape virtuals <B>put</B>, <B>perimeter</B>
and <B>area</B> accessible from outside). <SPAN LANG="en-GB">This
results in the following output:</SPAN></P>
<P ALIGN=LEFT STYLE="margin-left: 1cm; margin-right: 1cm; margin-top: 0.25cm; margin-bottom: 0.5cm; background: #cccccc; page-break-before: auto">
<FONT FACE="Courier New, monospace">Square [5]: Perimeter = 20; Area
= 25<BR>Rectange (6 * 9): Perimeter = 30; Area = 54<BR>Circle [10]:
Perimeter = 62.831853; Area = 314.15927<BR>Triangle (5,12,13):
Perimeter = 30; Area = 30</FONT></P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<SPAN LANG="en-US">Finally</SPAN><SPAN LANG="en-US">:</SPAN><SPAN LANG="en-US">
t</SPAN>here are several built-in functors can provide information
about class<SPAN LANG="en-US">es</SPAN>/object<SPAN LANG="en-US">s</SPAN>
relationship. <SPAN LANG="en-US">Note, what technically any class is
</SPAN><SPAN LANG="en-US"><I>functor</I></SPAN><SPAN LANG="en-US">,
which name belongs to functors name space. So (to turn class name
into expression) this syntax is </SPAN><SPAN LANG="en-US">used</SPAN><SPAN LANG="en-US">:
!</SPAN><SPAN LANG="en-US"><B>classname</B></SPAN><SPAN LANG="en-US">.</SPAN></P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=350>
	<TR VALIGN=TOP>
		<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_class</B></SPAN>(<SPAN LANG="en-US">funcref</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=350 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US"><B>funcref</B></SPAN><SPAN LANG="en-US">
			references class?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns <B>true</B>, if <I>funcref</I> references not ordinary
functor, but class (and <B>false</B> otherwise). Reports an error, if
<I>funcref</I> is not reference to functor.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=350>
	<TR VALIGN=TOP>
		<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_object</B></SPAN>(<SPAN LANG="en-US">value</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=350 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US"><B>value</B></SPAN><SPAN LANG="en-US">
			evaluates to object?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns <B>true</B>, if <I>value</I> evaluates to object (instance of
any class), and <B>false</B> otherwise.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=350>
	<TR VALIGN=TOP>
		<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>class_of</B></SPAN>(<SPAN LANG="en-US">object</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=350 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">Detect class, to which </SPAN><SPAN LANG="en-US"><B>object</B></SPAN><SPAN LANG="en-US">
			belongs</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
If <I>object</I> is instance of some <B>class</B> &ndash; returns
!<B>class</B>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
(Reports error otherwise.)</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=308>
	<COL WIDTH=317>
	<TR VALIGN=TOP>
		<TD WIDTH=308 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>self</B></SPAN>(<SPAN LANG="en-US">class_ref</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=317 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">Detect current instance of </SPAN><SPAN LANG="en-US"><B>class_ref</B></SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Finds current class instance: for example, <B>self</B> (!<B>Shape</B>)
returns instance of class <B>Shape</B>.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns (), if class at this moment has no current instance.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=350>
	<TR VALIGN=TOP>
		<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>is_virtual</B></SPAN>(<SPAN LANG="en-US">func_ref</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=350 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US"><B>func_ref</B></SPAN><SPAN LANG="en-US">
			references virtual functor?</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns <B>true</B>, if <I>func_ref</I> reference virtual functor
(declared in any class), and <B>false</B> otherwise.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<TABLE WIDTH=643 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=275>
	<COL WIDTH=350>
	<TR VALIGN=TOP>
		<TD WIDTH=275 STYLE="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm">
			<P CLASS="western" ALIGN=CENTER><FONT FACE="Courier New, monospace"><SPAN LANG="en-US"><B>originator</B></SPAN>(<SPAN LANG="en-US">virtual_ref</SPAN>)</FONT></P>
		</TD>
		<TD WIDTH=350 STYLE="border: 1px solid #000000; padding: 0.1cm">
			<P LANG="en-GB" CLASS="western" ALIGN=CENTER STYLE="font-weight: normal">
			<I><SPAN LANG="en-US">Class, from which </SPAN><SPAN LANG="en-US"><B>virtual_ref</B></SPAN><SPAN LANG="en-US">
			originates</SPAN></I></P>
		</TD>
	</TR>
</TABLE>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
Returns originator class, in which <I>virtual_ref</I> is declared.</P>
<P LANG="en-US" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
(<I>To be continued...</I>)</P>
<P LANG="en-GB" CLASS="western" ALIGN=JUSTIFY STYLE="margin-bottom: 0cm">
<BR>
</P>
</BODY>
</HTML>